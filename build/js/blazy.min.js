/*!
  hey, [be]Lazy.js - v1.8.2 - 2016.10.25
  A fast, small and dependency free lazy load script (https://github.com/dinbror/blazy)
  (c) Bjoern Klinggaard - @bklinggaard - http://dinbror.dk/blazy
*/
;
(function(root, blazy) {
    if (typeof define === 'function' && define.amd) {
        // AMD. Register bLazy as an anonymous module
        define(blazy);
    } else if (typeof exports === 'object') {
        // Node. Does not work with strict CommonJS, but
        // only CommonJS-like environments that support module.exports,
        // like Node.
        module.exports = blazy();
    } else {
        // Browser globals. Register bLazy on window
        root.Blazy = blazy();
    }
})(this, function() {
    'use strict';

    //private vars
    var _source, _viewport, _isRetina, _supportClosest, _attrSrc = 'src', _attrSrcset = 'srcset';

    // constructor
    return function Blazy(options) {
        //IE7- fallback for missing querySelectorAll support
        if (!document.querySelectorAll) {
            var s = document.createStyleSheet();
            document.querySelectorAll = function(r, c, i, j, a) {
                a = document.all, c = [], r = r.replace(/\[for\b/gi, '[htmlFor').split(',');
                for (i = r.length; i--;) {
                    s.addRule(r[i], 'k:v');
                    for (j = a.length; j--;) a[j].currentStyle.k && c.push(a[j]);
                    s.removeRule(0);
                }
                return c;
            };
        }

        //options and helper vars
        var scope = this;
        var util = scope._util = {};
        util.elements = [];
        util.destroyed = true;
        scope.options = options || {};
        scope.options.error = scope.options.error || false;
        scope.options.offset = scope.options.offset || 100;
        scope.options.root = scope.options.root || document;
        scope.options.success = scope.options.success || false;
        scope.options.selector = scope.options.selector || '.b-lazy';
        scope.options.separator = scope.options.separator || '|';
        scope.options.containerClass = scope.options.container;
        scope.options.container = scope.options.containerClass ? document.querySelectorAll(scope.options.containerClass) : false;
        scope.options.errorClass = scope.options.errorClass || 'b-error';
        scope.options.breakpoints = scope.options.breakpoints || false;
        scope.options.loadInvisible = scope.options.loadInvisible || false;
        scope.options.successClass = scope.options.successClass || 'b-loaded';
        scope.options.validateDelay = scope.options.validateDelay || 25;
        scope.options.saveViewportOffsetDelay = scope.options.saveViewportOffsetDelay || 50;
        scope.options.srcset = scope.options.srcset || 'data-srcset';
        scope.options.src = _source = scope.options.src || 'data-src';
        _supportClosest = Element.prototype.closest;
        _isRetina = window.devicePixelRatio > 1;
        _viewport = {};
        _viewport.top = 0 - scope.options.offset;
        _viewport.left = 0 - scope.options.offset;


        /* public functions
         ************************************/
        scope.revalidate = function() {
            initialize(scope);
        };
        scope.load = function(elements, force) {
            var opt = this.options;
            if (elements && elements.length === undefined) {
                loadElement(elements, force, opt);
            } else {
                each(elements, function(element) {
                    loadElement(element, force, opt);
                });
            }
        };
        scope.destroy = function() {            
            var util = scope._util;
            if (scope.options.container) {
                each(scope.options.container, function(object) {
                    unbindEvent(object, 'scroll', util.validateT);
                });
            }
            unbindEvent(window, 'scroll', util.validateT);
            unbindEvent(window, 'resize', util.validateT);
            unbindEvent(window, 'resize', util.saveViewportOffsetT);
            util.count = 0;
            util.elements.length = 0;
            util.destroyed = true;
        };

        //throttle, ensures that we don't call the functions too often
        util.validateT = throttle(function() {
            validate(scope);
        }, scope.options.validateDelay, scope);
        util.saveViewportOffsetT = throttle(function() {
            saveViewportOffset(scope.options.offset);
        }, scope.options.saveViewportOffsetDelay, scope);
        saveViewportOffset(scope.options.offset);

        //handle multi-served image src (obsolete)
        each(scope.options.breakpoints, function(object) {
            if (object.width >= window.screen.width) {
                _source = object.src;
                return false;
            }
        });

        // start lazy load
        setTimeout(function() {
            initialize(scope);
        }); // "dom ready" fix

    };


    /* Private helper functions
     ************************************/
    function initialize(self) {
        var util = self._util;
        // First we create an array of elements to lazy load
        util.elements = toArray(self.options);
        util.count = util.elements.length;
        // Then we bind resize and scroll events if not already binded
        if (util.destroyed) {
            util.destroyed = false;
            if (self.options.container) {
                each(self.options.container, function(object) {
                    bindEvent(object, 'scroll', util.validateT);
                });
            }
            bindEvent(window, 'resize', util.saveViewportOffsetT);
            bindEvent(window, 'resize', util.validateT);
            bindEvent(window, 'scroll', util.validateT);
        }
        // And finally, we start to lazy load.
        validate(self);
    }

    function validate(self) {
        var util = self._util;
        for (var i = 0; i < util.count; i++) {
            var element = util.elements[i];
            if (elementInView(element, self.options) || hasClass(element, self.options.successClass)) {
                self.load(element);
                util.elements.splice(i, 1);
                util.count--;
                i--;
            }
        }
        if (util.count === 0) {
            self.destroy();
        }
    }

    function elementInView(ele, options) {
        var rect = ele.getBoundingClientRect();

        if(options.container && _supportClosest){
            // Is element inside a container?
            var elementContainer = ele.closest(options.containerClass);
            if(elementContainer){
                var containerRect = elementContainer.getBoundingClientRect();
                // Is container in view?
                if(inView(containerRect, _viewport)){
                    var top = containerRect.top - options.offset;
                    var right = containerRect.right + options.offset;
                    var bottom = containerRect.bottom + options.offset;
                    var left = containerRect.left - options.offset;
                    var containerRectWithOffset = {
                        top: top > _viewport.top ? top : _viewport.top,
                        right: right < _viewport.right ? right : _viewport.right,
                        bottom: bottom < _viewport.bottom ? bottom : _viewport.bottom,
                        left: left > _viewport.left ? left : _viewport.left
                    };
                    // Is element in view of container?
                    return inView(rect, containerRectWithOffset);
                } else {
                    return false;
                }
            }
        }      
        return inView(rect, _viewport);
    }

    function inView(rect, viewport){
        // Intersection
        return rect.right >= viewport.left &&
               rect.bottom >= viewport.top && 
               rect.left <= viewport.right && 
               rect.top <= viewport.bottom;
    }

    function loadElement(ele, force, options) {
        // if element is visible, not loaded or forced
        if (!hasClass(ele, options.successClass) && (force || options.loadInvisible || (ele.offsetWidth > 0 && ele.offsetHeight > 0))) {
            var dataSrc = getAttr(ele, _source) || getAttr(ele, options.src); // fallback to default 'data-src'
            if (dataSrc) {
                var dataSrcSplitted = dataSrc.split(options.separator);
                var src = dataSrcSplitted[_isRetina && dataSrcSplitted.length > 1 ? 1 : 0];
                var srcset = getAttr(ele, options.srcset);
                var isImage = equal(ele, 'img');
                var parent = ele.parentNode;
                var isPicture = parent && equal(parent, 'picture');
                // Image or background image
                if (isImage || ele.src === undefined) {
                    var img = new Image();
                    // using EventListener instead of onerror and onload
                    // due to bug introduced in chrome v50 
                    // (https://productforums.google.com/forum/#!topic/chrome/p51Lk7vnP2o)
                    var onErrorHandler = function() {
                        if (options.error) options.error(ele, "invalid");
                        addClass(ele, options.errorClass);
                        unbindEvent(img, 'error', onErrorHandler);
                        unbindEvent(img, 'load', onLoadHandler);
                    };
                    var onLoadHandler = function() {
                        // Is element an image
                        if (isImage) {
                            if(!isPicture) {
                                handleSources(ele, src, srcset);
                            }
                        // or background-image
                        } else {
                            ele.style.backgroundImage = 'url("' + src + '")';
                        }
                        itemLoaded(ele, options);
                        unbindEvent(img, 'load', onLoadHandler);
                        unbindEvent(img, 'error', onErrorHandler);
                    };
                    
                    // Picture element
                    if (isPicture) {
                        img = ele; // Image tag inside picture element wont get preloaded
                        each(parent.getElementsByTagName('source'), function(source) {
                            handleSource(source, _attrSrcset, options.srcset);
                        });
                    }
                    bindEvent(img, 'error', onErrorHandler);
                    bindEvent(img, 'load', onLoadHandler);
                    handleSources(img, src, srcset); // Preload

                } else { // An item with src like iframe, unity games, simpel video etc
                    ele.src = src;
                    itemLoaded(ele, options);
                }
            } else {
                // video with child source
                if (equal(ele, 'video')) {
                    each(ele.getElementsByTagName('source'), function(source) {
                        handleSource(source, _attrSrc, options.src);
                    });
                    ele.load();
                    itemLoaded(ele, options);
                } else {
                    if (options.error) options.error(ele, "missing");
                    addClass(ele, options.errorClass);
                }
            }
        }
    }

    function itemLoaded(ele, options) {
        addClass(ele, options.successClass);
        if (options.success) options.success(ele);
        // cleanup markup, remove data source attributes
        removeAttr(ele, options.src);
        removeAttr(ele, options.srcset);
        each(options.breakpoints, function(object) {
            removeAttr(ele, object.src);
        });
    }

    function handleSource(ele, attr, dataAttr) {
        var dataSrc = getAttr(ele, dataAttr);
        if (dataSrc) {
            setAttr(ele, attr, dataSrc);
            removeAttr(ele, dataAttr);
        }
    }

    function handleSources(ele, src, srcset){
        if(srcset) {
            setAttr(ele, _attrSrcset, srcset); //srcset
        }
        ele.src = src; //src 
    }

    function setAttr(ele, attr, value){
        ele.setAttribute(attr, value);
    }

    function getAttr(ele, attr) {
        return ele.getAttribute(attr);
    }

    function removeAttr(ele, attr){
        ele.removeAttribute(attr); 
    }

    function equal(ele, str) {
        return ele.nodeName.toLowerCase() === str;
    }

    function hasClass(ele, className) {
        return (' ' + ele.className + ' ').indexOf(' ' + className + ' ') !== -1;
    }

    function addClass(ele, className) {
        if (!hasClass(ele, className)) {
            ele.className += ' ' + className;
        }
    }

    function toArray(options) {
        var array = [];
        var nodelist = (options.root).querySelectorAll(options.selector);
        for (var i = nodelist.length; i--; array.unshift(nodelist[i])) {}
        return array;
    }

    function saveViewportOffset(offset) {
        _viewport.bottom = (window.innerHeight || document.documentElement.clientHeight) + offset;
        _viewport.right = (window.innerWidth || document.documentElement.clientWidth) + offset;
    }

    function bindEvent(ele, type, fn) {
        if (ele.attachEvent) {
            ele.attachEvent && ele.attachEvent('on' + type, fn);
        } else {
            ele.addEventListener(type, fn, { capture: false, passive: true });
        }
    }

    function unbindEvent(ele, type, fn) {
        if (ele.detachEvent) {
            ele.detachEvent && ele.detachEvent('on' + type, fn);
        } else {
            ele.removeEventListener(type, fn, { capture: false, passive: true });
        }
    }

    function each(object, fn) {
        if (object && fn) {
            var l = object.length;
            for (var i = 0; i < l && fn(object[i], i) !== false; i++) {}
        }
    }

    function throttle(fn, minDelay, scope) {
        var lastCall = 0;
        return function() {
            var now = +new Date();
            if (now - lastCall < minDelay) {
                return;
            }
            lastCall = now;
            fn.apply(scope, arguments);
        };
    }
});
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiIiwic291cmNlcyI6WyJibGF6eS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAgaGV5LCBbYmVdTGF6eS5qcyAtIHYxLjguMiAtIDIwMTYuMTAuMjVcbiAgQSBmYXN0LCBzbWFsbCBhbmQgZGVwZW5kZW5jeSBmcmVlIGxhenkgbG9hZCBzY3JpcHQgKGh0dHBzOi8vZ2l0aHViLmNvbS9kaW5icm9yL2JsYXp5KVxuICAoYykgQmpvZXJuIEtsaW5nZ2FhcmQgLSBAYmtsaW5nZ2FhcmQgLSBodHRwOi8vZGluYnJvci5kay9ibGF6eVxuKi9cbjtcbihmdW5jdGlvbihyb290LCBibGF6eSkge1xuICAgIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICAgICAgLy8gQU1ELiBSZWdpc3RlciBiTGF6eSBhcyBhbiBhbm9ueW1vdXMgbW9kdWxlXG4gICAgICAgIGRlZmluZShibGF6eSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgLy8gTm9kZS4gRG9lcyBub3Qgd29yayB3aXRoIHN0cmljdCBDb21tb25KUywgYnV0XG4gICAgICAgIC8vIG9ubHkgQ29tbW9uSlMtbGlrZSBlbnZpcm9ubWVudHMgdGhhdCBzdXBwb3J0IG1vZHVsZS5leHBvcnRzLFxuICAgICAgICAvLyBsaWtlIE5vZGUuXG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gYmxhenkoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBCcm93c2VyIGdsb2JhbHMuIFJlZ2lzdGVyIGJMYXp5IG9uIHdpbmRvd1xuICAgICAgICByb290LkJsYXp5ID0gYmxhenkoKTtcbiAgICB9XG59KSh0aGlzLCBmdW5jdGlvbigpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICAvL3ByaXZhdGUgdmFyc1xuICAgIHZhciBfc291cmNlLCBfdmlld3BvcnQsIF9pc1JldGluYSwgX3N1cHBvcnRDbG9zZXN0LCBfYXR0clNyYyA9ICdzcmMnLCBfYXR0clNyY3NldCA9ICdzcmNzZXQnO1xuXG4gICAgLy8gY29uc3RydWN0b3JcbiAgICByZXR1cm4gZnVuY3Rpb24gQmxhenkob3B0aW9ucykge1xuICAgICAgICAvL0lFNy0gZmFsbGJhY2sgZm9yIG1pc3NpbmcgcXVlcnlTZWxlY3RvckFsbCBzdXBwb3J0XG4gICAgICAgIGlmICghZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCkge1xuICAgICAgICAgICAgdmFyIHMgPSBkb2N1bWVudC5jcmVhdGVTdHlsZVNoZWV0KCk7XG4gICAgICAgICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsID0gZnVuY3Rpb24ociwgYywgaSwgaiwgYSkge1xuICAgICAgICAgICAgICAgIGEgPSBkb2N1bWVudC5hbGwsIGMgPSBbXSwgciA9IHIucmVwbGFjZSgvXFxbZm9yXFxiL2dpLCAnW2h0bWxGb3InKS5zcGxpdCgnLCcpO1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IHIubGVuZ3RoOyBpLS07KSB7XG4gICAgICAgICAgICAgICAgICAgIHMuYWRkUnVsZShyW2ldLCAnazp2Jyk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoaiA9IGEubGVuZ3RoOyBqLS07KSBhW2pdLmN1cnJlbnRTdHlsZS5rICYmIGMucHVzaChhW2pdKTtcbiAgICAgICAgICAgICAgICAgICAgcy5yZW1vdmVSdWxlKDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gYztcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICAvL29wdGlvbnMgYW5kIGhlbHBlciB2YXJzXG4gICAgICAgIHZhciBzY29wZSA9IHRoaXM7XG4gICAgICAgIHZhciB1dGlsID0gc2NvcGUuX3V0aWwgPSB7fTtcbiAgICAgICAgdXRpbC5lbGVtZW50cyA9IFtdO1xuICAgICAgICB1dGlsLmRlc3Ryb3llZCA9IHRydWU7XG4gICAgICAgIHNjb3BlLm9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgICBzY29wZS5vcHRpb25zLmVycm9yID0gc2NvcGUub3B0aW9ucy5lcnJvciB8fCBmYWxzZTtcbiAgICAgICAgc2NvcGUub3B0aW9ucy5vZmZzZXQgPSBzY29wZS5vcHRpb25zLm9mZnNldCB8fCAxMDA7XG4gICAgICAgIHNjb3BlLm9wdGlvbnMucm9vdCA9IHNjb3BlLm9wdGlvbnMucm9vdCB8fCBkb2N1bWVudDtcbiAgICAgICAgc2NvcGUub3B0aW9ucy5zdWNjZXNzID0gc2NvcGUub3B0aW9ucy5zdWNjZXNzIHx8IGZhbHNlO1xuICAgICAgICBzY29wZS5vcHRpb25zLnNlbGVjdG9yID0gc2NvcGUub3B0aW9ucy5zZWxlY3RvciB8fCAnLmItbGF6eSc7XG4gICAgICAgIHNjb3BlLm9wdGlvbnMuc2VwYXJhdG9yID0gc2NvcGUub3B0aW9ucy5zZXBhcmF0b3IgfHwgJ3wnO1xuICAgICAgICBzY29wZS5vcHRpb25zLmNvbnRhaW5lckNsYXNzID0gc2NvcGUub3B0aW9ucy5jb250YWluZXI7XG4gICAgICAgIHNjb3BlLm9wdGlvbnMuY29udGFpbmVyID0gc2NvcGUub3B0aW9ucy5jb250YWluZXJDbGFzcyA/IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoc2NvcGUub3B0aW9ucy5jb250YWluZXJDbGFzcykgOiBmYWxzZTtcbiAgICAgICAgc2NvcGUub3B0aW9ucy5lcnJvckNsYXNzID0gc2NvcGUub3B0aW9ucy5lcnJvckNsYXNzIHx8ICdiLWVycm9yJztcbiAgICAgICAgc2NvcGUub3B0aW9ucy5icmVha3BvaW50cyA9IHNjb3BlLm9wdGlvbnMuYnJlYWtwb2ludHMgfHwgZmFsc2U7XG4gICAgICAgIHNjb3BlLm9wdGlvbnMubG9hZEludmlzaWJsZSA9IHNjb3BlLm9wdGlvbnMubG9hZEludmlzaWJsZSB8fCBmYWxzZTtcbiAgICAgICAgc2NvcGUub3B0aW9ucy5zdWNjZXNzQ2xhc3MgPSBzY29wZS5vcHRpb25zLnN1Y2Nlc3NDbGFzcyB8fCAnYi1sb2FkZWQnO1xuICAgICAgICBzY29wZS5vcHRpb25zLnZhbGlkYXRlRGVsYXkgPSBzY29wZS5vcHRpb25zLnZhbGlkYXRlRGVsYXkgfHwgMjU7XG4gICAgICAgIHNjb3BlLm9wdGlvbnMuc2F2ZVZpZXdwb3J0T2Zmc2V0RGVsYXkgPSBzY29wZS5vcHRpb25zLnNhdmVWaWV3cG9ydE9mZnNldERlbGF5IHx8IDUwO1xuICAgICAgICBzY29wZS5vcHRpb25zLnNyY3NldCA9IHNjb3BlLm9wdGlvbnMuc3Jjc2V0IHx8ICdkYXRhLXNyY3NldCc7XG4gICAgICAgIHNjb3BlLm9wdGlvbnMuc3JjID0gX3NvdXJjZSA9IHNjb3BlLm9wdGlvbnMuc3JjIHx8ICdkYXRhLXNyYyc7XG4gICAgICAgIF9zdXBwb3J0Q2xvc2VzdCA9IEVsZW1lbnQucHJvdG90eXBlLmNsb3Nlc3Q7XG4gICAgICAgIF9pc1JldGluYSA9IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvID4gMTtcbiAgICAgICAgX3ZpZXdwb3J0ID0ge307XG4gICAgICAgIF92aWV3cG9ydC50b3AgPSAwIC0gc2NvcGUub3B0aW9ucy5vZmZzZXQ7XG4gICAgICAgIF92aWV3cG9ydC5sZWZ0ID0gMCAtIHNjb3BlLm9wdGlvbnMub2Zmc2V0O1xuXG5cbiAgICAgICAgLyogcHVibGljIGZ1bmN0aW9uc1xuICAgICAgICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAgICAgICBzY29wZS5yZXZhbGlkYXRlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpbml0aWFsaXplKHNjb3BlKTtcbiAgICAgICAgfTtcbiAgICAgICAgc2NvcGUubG9hZCA9IGZ1bmN0aW9uKGVsZW1lbnRzLCBmb3JjZSkge1xuICAgICAgICAgICAgdmFyIG9wdCA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgICAgIGlmIChlbGVtZW50cyAmJiBlbGVtZW50cy5sZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxvYWRFbGVtZW50KGVsZW1lbnRzLCBmb3JjZSwgb3B0KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZWFjaChlbGVtZW50cywgZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICBsb2FkRWxlbWVudChlbGVtZW50LCBmb3JjZSwgb3B0KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgc2NvcGUuZGVzdHJveSA9IGZ1bmN0aW9uKCkgeyAgICAgICAgICAgIFxuICAgICAgICAgICAgdmFyIHV0aWwgPSBzY29wZS5fdXRpbDtcbiAgICAgICAgICAgIGlmIChzY29wZS5vcHRpb25zLmNvbnRhaW5lcikge1xuICAgICAgICAgICAgICAgIGVhY2goc2NvcGUub3B0aW9ucy5jb250YWluZXIsIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgICAgICAgICAgICAgICB1bmJpbmRFdmVudChvYmplY3QsICdzY3JvbGwnLCB1dGlsLnZhbGlkYXRlVCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB1bmJpbmRFdmVudCh3aW5kb3csICdzY3JvbGwnLCB1dGlsLnZhbGlkYXRlVCk7XG4gICAgICAgICAgICB1bmJpbmRFdmVudCh3aW5kb3csICdyZXNpemUnLCB1dGlsLnZhbGlkYXRlVCk7XG4gICAgICAgICAgICB1bmJpbmRFdmVudCh3aW5kb3csICdyZXNpemUnLCB1dGlsLnNhdmVWaWV3cG9ydE9mZnNldFQpO1xuICAgICAgICAgICAgdXRpbC5jb3VudCA9IDA7XG4gICAgICAgICAgICB1dGlsLmVsZW1lbnRzLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICB1dGlsLmRlc3Ryb3llZCA9IHRydWU7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy90aHJvdHRsZSwgZW5zdXJlcyB0aGF0IHdlIGRvbid0IGNhbGwgdGhlIGZ1bmN0aW9ucyB0b28gb2Z0ZW5cbiAgICAgICAgdXRpbC52YWxpZGF0ZVQgPSB0aHJvdHRsZShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhbGlkYXRlKHNjb3BlKTtcbiAgICAgICAgfSwgc2NvcGUub3B0aW9ucy52YWxpZGF0ZURlbGF5LCBzY29wZSk7XG4gICAgICAgIHV0aWwuc2F2ZVZpZXdwb3J0T2Zmc2V0VCA9IHRocm90dGxlKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgc2F2ZVZpZXdwb3J0T2Zmc2V0KHNjb3BlLm9wdGlvbnMub2Zmc2V0KTtcbiAgICAgICAgfSwgc2NvcGUub3B0aW9ucy5zYXZlVmlld3BvcnRPZmZzZXREZWxheSwgc2NvcGUpO1xuICAgICAgICBzYXZlVmlld3BvcnRPZmZzZXQoc2NvcGUub3B0aW9ucy5vZmZzZXQpO1xuXG4gICAgICAgIC8vaGFuZGxlIG11bHRpLXNlcnZlZCBpbWFnZSBzcmMgKG9ic29sZXRlKVxuICAgICAgICBlYWNoKHNjb3BlLm9wdGlvbnMuYnJlYWtwb2ludHMsIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgICAgICAgaWYgKG9iamVjdC53aWR0aCA+PSB3aW5kb3cuc2NyZWVuLndpZHRoKSB7XG4gICAgICAgICAgICAgICAgX3NvdXJjZSA9IG9iamVjdC5zcmM7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBzdGFydCBsYXp5IGxvYWRcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGluaXRpYWxpemUoc2NvcGUpO1xuICAgICAgICB9KTsgLy8gXCJkb20gcmVhZHlcIiBmaXhcblxuICAgIH07XG5cblxuICAgIC8qIFByaXZhdGUgaGVscGVyIGZ1bmN0aW9uc1xuICAgICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gICAgZnVuY3Rpb24gaW5pdGlhbGl6ZShzZWxmKSB7XG4gICAgICAgIHZhciB1dGlsID0gc2VsZi5fdXRpbDtcbiAgICAgICAgLy8gRmlyc3Qgd2UgY3JlYXRlIGFuIGFycmF5IG9mIGVsZW1lbnRzIHRvIGxhenkgbG9hZFxuICAgICAgICB1dGlsLmVsZW1lbnRzID0gdG9BcnJheShzZWxmLm9wdGlvbnMpO1xuICAgICAgICB1dGlsLmNvdW50ID0gdXRpbC5lbGVtZW50cy5sZW5ndGg7XG4gICAgICAgIC8vIFRoZW4gd2UgYmluZCByZXNpemUgYW5kIHNjcm9sbCBldmVudHMgaWYgbm90IGFscmVhZHkgYmluZGVkXG4gICAgICAgIGlmICh1dGlsLmRlc3Ryb3llZCkge1xuICAgICAgICAgICAgdXRpbC5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChzZWxmLm9wdGlvbnMuY29udGFpbmVyKSB7XG4gICAgICAgICAgICAgICAgZWFjaChzZWxmLm9wdGlvbnMuY29udGFpbmVyLCBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgYmluZEV2ZW50KG9iamVjdCwgJ3Njcm9sbCcsIHV0aWwudmFsaWRhdGVUKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJpbmRFdmVudCh3aW5kb3csICdyZXNpemUnLCB1dGlsLnNhdmVWaWV3cG9ydE9mZnNldFQpO1xuICAgICAgICAgICAgYmluZEV2ZW50KHdpbmRvdywgJ3Jlc2l6ZScsIHV0aWwudmFsaWRhdGVUKTtcbiAgICAgICAgICAgIGJpbmRFdmVudCh3aW5kb3csICdzY3JvbGwnLCB1dGlsLnZhbGlkYXRlVCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQW5kIGZpbmFsbHksIHdlIHN0YXJ0IHRvIGxhenkgbG9hZC5cbiAgICAgICAgdmFsaWRhdGUoc2VsZik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdmFsaWRhdGUoc2VsZikge1xuICAgICAgICB2YXIgdXRpbCA9IHNlbGYuX3V0aWw7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdXRpbC5jb3VudDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgZWxlbWVudCA9IHV0aWwuZWxlbWVudHNbaV07XG4gICAgICAgICAgICBpZiAoZWxlbWVudEluVmlldyhlbGVtZW50LCBzZWxmLm9wdGlvbnMpIHx8IGhhc0NsYXNzKGVsZW1lbnQsIHNlbGYub3B0aW9ucy5zdWNjZXNzQ2xhc3MpKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5sb2FkKGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIHV0aWwuZWxlbWVudHMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgIHV0aWwuY291bnQtLTtcbiAgICAgICAgICAgICAgICBpLS07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHV0aWwuY291bnQgPT09IDApIHtcbiAgICAgICAgICAgIHNlbGYuZGVzdHJveSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZWxlbWVudEluVmlldyhlbGUsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHJlY3QgPSBlbGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cbiAgICAgICAgaWYob3B0aW9ucy5jb250YWluZXIgJiYgX3N1cHBvcnRDbG9zZXN0KXtcbiAgICAgICAgICAgIC8vIElzIGVsZW1lbnQgaW5zaWRlIGEgY29udGFpbmVyP1xuICAgICAgICAgICAgdmFyIGVsZW1lbnRDb250YWluZXIgPSBlbGUuY2xvc2VzdChvcHRpb25zLmNvbnRhaW5lckNsYXNzKTtcbiAgICAgICAgICAgIGlmKGVsZW1lbnRDb250YWluZXIpe1xuICAgICAgICAgICAgICAgIHZhciBjb250YWluZXJSZWN0ID0gZWxlbWVudENvbnRhaW5lci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgICAgICAvLyBJcyBjb250YWluZXIgaW4gdmlldz9cbiAgICAgICAgICAgICAgICBpZihpblZpZXcoY29udGFpbmVyUmVjdCwgX3ZpZXdwb3J0KSl7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0b3AgPSBjb250YWluZXJSZWN0LnRvcCAtIG9wdGlvbnMub2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmlnaHQgPSBjb250YWluZXJSZWN0LnJpZ2h0ICsgb3B0aW9ucy5vZmZzZXQ7XG4gICAgICAgICAgICAgICAgICAgIHZhciBib3R0b20gPSBjb250YWluZXJSZWN0LmJvdHRvbSArIG9wdGlvbnMub2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGVmdCA9IGNvbnRhaW5lclJlY3QubGVmdCAtIG9wdGlvbnMub2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29udGFpbmVyUmVjdFdpdGhPZmZzZXQgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b3A6IHRvcCA+IF92aWV3cG9ydC50b3AgPyB0b3AgOiBfdmlld3BvcnQudG9wLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHQ6IHJpZ2h0IDwgX3ZpZXdwb3J0LnJpZ2h0ID8gcmlnaHQgOiBfdmlld3BvcnQucmlnaHQsXG4gICAgICAgICAgICAgICAgICAgICAgICBib3R0b206IGJvdHRvbSA8IF92aWV3cG9ydC5ib3R0b20gPyBib3R0b20gOiBfdmlld3BvcnQuYm90dG9tLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogbGVmdCA+IF92aWV3cG9ydC5sZWZ0ID8gbGVmdCA6IF92aWV3cG9ydC5sZWZ0XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIC8vIElzIGVsZW1lbnQgaW4gdmlldyBvZiBjb250YWluZXI/XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpblZpZXcocmVjdCwgY29udGFpbmVyUmVjdFdpdGhPZmZzZXQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gICAgICBcbiAgICAgICAgcmV0dXJuIGluVmlldyhyZWN0LCBfdmlld3BvcnQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluVmlldyhyZWN0LCB2aWV3cG9ydCl7XG4gICAgICAgIC8vIEludGVyc2VjdGlvblxuICAgICAgICByZXR1cm4gcmVjdC5yaWdodCA+PSB2aWV3cG9ydC5sZWZ0ICYmXG4gICAgICAgICAgICAgICByZWN0LmJvdHRvbSA+PSB2aWV3cG9ydC50b3AgJiYgXG4gICAgICAgICAgICAgICByZWN0LmxlZnQgPD0gdmlld3BvcnQucmlnaHQgJiYgXG4gICAgICAgICAgICAgICByZWN0LnRvcCA8PSB2aWV3cG9ydC5ib3R0b207XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbG9hZEVsZW1lbnQoZWxlLCBmb3JjZSwgb3B0aW9ucykge1xuICAgICAgICAvLyBpZiBlbGVtZW50IGlzIHZpc2libGUsIG5vdCBsb2FkZWQgb3IgZm9yY2VkXG4gICAgICAgIGlmICghaGFzQ2xhc3MoZWxlLCBvcHRpb25zLnN1Y2Nlc3NDbGFzcykgJiYgKGZvcmNlIHx8IG9wdGlvbnMubG9hZEludmlzaWJsZSB8fCAoZWxlLm9mZnNldFdpZHRoID4gMCAmJiBlbGUub2Zmc2V0SGVpZ2h0ID4gMCkpKSB7XG4gICAgICAgICAgICB2YXIgZGF0YVNyYyA9IGdldEF0dHIoZWxlLCBfc291cmNlKSB8fCBnZXRBdHRyKGVsZSwgb3B0aW9ucy5zcmMpOyAvLyBmYWxsYmFjayB0byBkZWZhdWx0ICdkYXRhLXNyYydcbiAgICAgICAgICAgIGlmIChkYXRhU3JjKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRhdGFTcmNTcGxpdHRlZCA9IGRhdGFTcmMuc3BsaXQob3B0aW9ucy5zZXBhcmF0b3IpO1xuICAgICAgICAgICAgICAgIHZhciBzcmMgPSBkYXRhU3JjU3BsaXR0ZWRbX2lzUmV0aW5hICYmIGRhdGFTcmNTcGxpdHRlZC5sZW5ndGggPiAxID8gMSA6IDBdO1xuICAgICAgICAgICAgICAgIHZhciBzcmNzZXQgPSBnZXRBdHRyKGVsZSwgb3B0aW9ucy5zcmNzZXQpO1xuICAgICAgICAgICAgICAgIHZhciBpc0ltYWdlID0gZXF1YWwoZWxlLCAnaW1nJyk7XG4gICAgICAgICAgICAgICAgdmFyIHBhcmVudCA9IGVsZS5wYXJlbnROb2RlO1xuICAgICAgICAgICAgICAgIHZhciBpc1BpY3R1cmUgPSBwYXJlbnQgJiYgZXF1YWwocGFyZW50LCAncGljdHVyZScpO1xuICAgICAgICAgICAgICAgIC8vIEltYWdlIG9yIGJhY2tncm91bmQgaW1hZ2VcbiAgICAgICAgICAgICAgICBpZiAoaXNJbWFnZSB8fCBlbGUuc3JjID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGltZyA9IG5ldyBJbWFnZSgpO1xuICAgICAgICAgICAgICAgICAgICAvLyB1c2luZyBFdmVudExpc3RlbmVyIGluc3RlYWQgb2Ygb25lcnJvciBhbmQgb25sb2FkXG4gICAgICAgICAgICAgICAgICAgIC8vIGR1ZSB0byBidWcgaW50cm9kdWNlZCBpbiBjaHJvbWUgdjUwIFxuICAgICAgICAgICAgICAgICAgICAvLyAoaHR0cHM6Ly9wcm9kdWN0Zm9ydW1zLmdvb2dsZS5jb20vZm9ydW0vIyF0b3BpYy9jaHJvbWUvcDUxTGs3dm5QMm8pXG4gICAgICAgICAgICAgICAgICAgIHZhciBvbkVycm9ySGFuZGxlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuZXJyb3IpIG9wdGlvbnMuZXJyb3IoZWxlLCBcImludmFsaWRcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRDbGFzcyhlbGUsIG9wdGlvbnMuZXJyb3JDbGFzcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB1bmJpbmRFdmVudChpbWcsICdlcnJvcicsIG9uRXJyb3JIYW5kbGVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVuYmluZEV2ZW50KGltZywgJ2xvYWQnLCBvbkxvYWRIYW5kbGVyKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9uTG9hZEhhbmRsZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElzIGVsZW1lbnQgYW4gaW1hZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0ltYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoIWlzUGljdHVyZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVTb3VyY2VzKGVsZSwgc3JjLCBzcmNzZXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9yIGJhY2tncm91bmQtaW1hZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlLnN0eWxlLmJhY2tncm91bmRJbWFnZSA9ICd1cmwoXCInICsgc3JjICsgJ1wiKSc7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtTG9hZGVkKGVsZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB1bmJpbmRFdmVudChpbWcsICdsb2FkJywgb25Mb2FkSGFuZGxlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB1bmJpbmRFdmVudChpbWcsICdlcnJvcicsIG9uRXJyb3JIYW5kbGVyKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIC8vIFBpY3R1cmUgZWxlbWVudFxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNQaWN0dXJlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbWcgPSBlbGU7IC8vIEltYWdlIHRhZyBpbnNpZGUgcGljdHVyZSBlbGVtZW50IHdvbnQgZ2V0IHByZWxvYWRlZFxuICAgICAgICAgICAgICAgICAgICAgICAgZWFjaChwYXJlbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3NvdXJjZScpLCBmdW5jdGlvbihzb3VyY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVTb3VyY2Uoc291cmNlLCBfYXR0clNyY3NldCwgb3B0aW9ucy5zcmNzZXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYmluZEV2ZW50KGltZywgJ2Vycm9yJywgb25FcnJvckhhbmRsZXIpO1xuICAgICAgICAgICAgICAgICAgICBiaW5kRXZlbnQoaW1nLCAnbG9hZCcsIG9uTG9hZEhhbmRsZXIpO1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGVTb3VyY2VzKGltZywgc3JjLCBzcmNzZXQpOyAvLyBQcmVsb2FkXG5cbiAgICAgICAgICAgICAgICB9IGVsc2UgeyAvLyBBbiBpdGVtIHdpdGggc3JjIGxpa2UgaWZyYW1lLCB1bml0eSBnYW1lcywgc2ltcGVsIHZpZGVvIGV0Y1xuICAgICAgICAgICAgICAgICAgICBlbGUuc3JjID0gc3JjO1xuICAgICAgICAgICAgICAgICAgICBpdGVtTG9hZGVkKGVsZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyB2aWRlbyB3aXRoIGNoaWxkIHNvdXJjZVxuICAgICAgICAgICAgICAgIGlmIChlcXVhbChlbGUsICd2aWRlbycpKSB7XG4gICAgICAgICAgICAgICAgICAgIGVhY2goZWxlLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdzb3VyY2UnKSwgZnVuY3Rpb24oc291cmNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVTb3VyY2Uoc291cmNlLCBfYXR0clNyYywgb3B0aW9ucy5zcmMpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgZWxlLmxvYWQoKTtcbiAgICAgICAgICAgICAgICAgICAgaXRlbUxvYWRlZChlbGUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmVycm9yKSBvcHRpb25zLmVycm9yKGVsZSwgXCJtaXNzaW5nXCIpO1xuICAgICAgICAgICAgICAgICAgICBhZGRDbGFzcyhlbGUsIG9wdGlvbnMuZXJyb3JDbGFzcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXRlbUxvYWRlZChlbGUsIG9wdGlvbnMpIHtcbiAgICAgICAgYWRkQ2xhc3MoZWxlLCBvcHRpb25zLnN1Y2Nlc3NDbGFzcyk7XG4gICAgICAgIGlmIChvcHRpb25zLnN1Y2Nlc3MpIG9wdGlvbnMuc3VjY2VzcyhlbGUpO1xuICAgICAgICAvLyBjbGVhbnVwIG1hcmt1cCwgcmVtb3ZlIGRhdGEgc291cmNlIGF0dHJpYnV0ZXNcbiAgICAgICAgcmVtb3ZlQXR0cihlbGUsIG9wdGlvbnMuc3JjKTtcbiAgICAgICAgcmVtb3ZlQXR0cihlbGUsIG9wdGlvbnMuc3Jjc2V0KTtcbiAgICAgICAgZWFjaChvcHRpb25zLmJyZWFrcG9pbnRzLCBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgICAgICAgIHJlbW92ZUF0dHIoZWxlLCBvYmplY3Quc3JjKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaGFuZGxlU291cmNlKGVsZSwgYXR0ciwgZGF0YUF0dHIpIHtcbiAgICAgICAgdmFyIGRhdGFTcmMgPSBnZXRBdHRyKGVsZSwgZGF0YUF0dHIpO1xuICAgICAgICBpZiAoZGF0YVNyYykge1xuICAgICAgICAgICAgc2V0QXR0cihlbGUsIGF0dHIsIGRhdGFTcmMpO1xuICAgICAgICAgICAgcmVtb3ZlQXR0cihlbGUsIGRhdGFBdHRyKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhhbmRsZVNvdXJjZXMoZWxlLCBzcmMsIHNyY3NldCl7XG4gICAgICAgIGlmKHNyY3NldCkge1xuICAgICAgICAgICAgc2V0QXR0cihlbGUsIF9hdHRyU3Jjc2V0LCBzcmNzZXQpOyAvL3NyY3NldFxuICAgICAgICB9XG4gICAgICAgIGVsZS5zcmMgPSBzcmM7IC8vc3JjIFxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldEF0dHIoZWxlLCBhdHRyLCB2YWx1ZSl7XG4gICAgICAgIGVsZS5zZXRBdHRyaWJ1dGUoYXR0ciwgdmFsdWUpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldEF0dHIoZWxlLCBhdHRyKSB7XG4gICAgICAgIHJldHVybiBlbGUuZ2V0QXR0cmlidXRlKGF0dHIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlbW92ZUF0dHIoZWxlLCBhdHRyKXtcbiAgICAgICAgZWxlLnJlbW92ZUF0dHJpYnV0ZShhdHRyKTsgXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXF1YWwoZWxlLCBzdHIpIHtcbiAgICAgICAgcmV0dXJuIGVsZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBzdHI7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaGFzQ2xhc3MoZWxlLCBjbGFzc05hbWUpIHtcbiAgICAgICAgcmV0dXJuICgnICcgKyBlbGUuY2xhc3NOYW1lICsgJyAnKS5pbmRleE9mKCcgJyArIGNsYXNzTmFtZSArICcgJykgIT09IC0xO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFkZENsYXNzKGVsZSwgY2xhc3NOYW1lKSB7XG4gICAgICAgIGlmICghaGFzQ2xhc3MoZWxlLCBjbGFzc05hbWUpKSB7XG4gICAgICAgICAgICBlbGUuY2xhc3NOYW1lICs9ICcgJyArIGNsYXNzTmFtZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvQXJyYXkob3B0aW9ucykge1xuICAgICAgICB2YXIgYXJyYXkgPSBbXTtcbiAgICAgICAgdmFyIG5vZGVsaXN0ID0gKG9wdGlvbnMucm9vdCkucXVlcnlTZWxlY3RvckFsbChvcHRpb25zLnNlbGVjdG9yKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IG5vZGVsaXN0Lmxlbmd0aDsgaS0tOyBhcnJheS51bnNoaWZ0KG5vZGVsaXN0W2ldKSkge31cbiAgICAgICAgcmV0dXJuIGFycmF5O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNhdmVWaWV3cG9ydE9mZnNldChvZmZzZXQpIHtcbiAgICAgICAgX3ZpZXdwb3J0LmJvdHRvbSA9ICh3aW5kb3cuaW5uZXJIZWlnaHQgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodCkgKyBvZmZzZXQ7XG4gICAgICAgIF92aWV3cG9ydC5yaWdodCA9ICh3aW5kb3cuaW5uZXJXaWR0aCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGgpICsgb2Zmc2V0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGJpbmRFdmVudChlbGUsIHR5cGUsIGZuKSB7XG4gICAgICAgIGlmIChlbGUuYXR0YWNoRXZlbnQpIHtcbiAgICAgICAgICAgIGVsZS5hdHRhY2hFdmVudCAmJiBlbGUuYXR0YWNoRXZlbnQoJ29uJyArIHR5cGUsIGZuKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVsZS5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGZuLCB7IGNhcHR1cmU6IGZhbHNlLCBwYXNzaXZlOiB0cnVlIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdW5iaW5kRXZlbnQoZWxlLCB0eXBlLCBmbikge1xuICAgICAgICBpZiAoZWxlLmRldGFjaEV2ZW50KSB7XG4gICAgICAgICAgICBlbGUuZGV0YWNoRXZlbnQgJiYgZWxlLmRldGFjaEV2ZW50KCdvbicgKyB0eXBlLCBmbik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlbGUucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBmbiwgeyBjYXB0dXJlOiBmYWxzZSwgcGFzc2l2ZTogdHJ1ZSB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGVhY2gob2JqZWN0LCBmbikge1xuICAgICAgICBpZiAob2JqZWN0ICYmIGZuKSB7XG4gICAgICAgICAgICB2YXIgbCA9IG9iamVjdC5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGwgJiYgZm4ob2JqZWN0W2ldLCBpKSAhPT0gZmFsc2U7IGkrKykge31cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRocm90dGxlKGZuLCBtaW5EZWxheSwgc2NvcGUpIHtcbiAgICAgICAgdmFyIGxhc3RDYWxsID0gMDtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIG5vdyA9ICtuZXcgRGF0ZSgpO1xuICAgICAgICAgICAgaWYgKG5vdyAtIGxhc3RDYWxsIDwgbWluRGVsYXkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsYXN0Q2FsbCA9IG5vdztcbiAgICAgICAgICAgIGZuLmFwcGx5KHNjb3BlLCBhcmd1bWVudHMpO1xuICAgICAgICB9O1xuICAgIH1cbn0pOyJdLCJmaWxlIjoiYmxhenkubWluLmpzIn0=
