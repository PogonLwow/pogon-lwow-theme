jQuery(function($) {

       function cardExcerpt() {
        $(".card__excerpt").text(function(index, currentText) {
          return currentText.substr(0, 125) + '\u2026';
        });
      }
      cardExcerpt();
      function featuredTitle() {
       $(".featured__title").text(function(index, currentText) {
         return currentText.substr(0, 72) + '\u2026';
       });
     }
     featuredTitle();

    $(document).ready(function() {

        (function() {
            $('.sportspress style').remove();
            $('.gallery-item a').addClass('link');
        
            $('.sp-team-name').each(function() {
                $(this).insertAfter($(this).parent().find('img'));
            });
        })();

            // $("#nav-mobile").html($("#nav-main").html());
            $("#nav-trigger .navicon-button").click(function() {
                console.info('Burger clicked');
                if ($(".topbar").hasClass("topbar--expanded")) {
                    $(".topbar").removeClass("topbar--expanded");
                    $(this).removeClass("open");
                } else {
                    $(".topbar").addClass("topbar--expanded");
                    $(this).addClass("open");
                }
            });

        
        var bLazy = new Blazy({
          offset: 20,
          selector: '.blazy',
          loadInvisible: false,
          breakpoints: [{
            width: 360, // Max-width
            src: 'data-src-small'
          }],
          success: function(element) {
            $(element).parent().removeClass('loading', 500);
            updateCounter();
          },
          error: function(element, msg) {
            if (msg === 'missing') {
              $(element).parent().removeClass('loading', 500); // Data-src is missing
              console.error("bLazy: data-src is missing");
            } else if (msg === 'invalid') {
              $(element).parent().removeClass('loading', 500);
              // Data-src is invalid
              console.error("bLazy: data-src is invalid");
        
            }
          }
        });
        // not needed, only here to illustrate amount of loaded images
        var imageLoaded = 0;
        
        function updateCounter() {
          imageLoaded++;
          console.info("bLazy: Images loaded: %d", imageLoaded);
        }
        
        // tabs(bLazy);

        (function() {
            var ajax_url = $('body').attr('data-ajax-url');
            var post_offset = 0;
            var incNumber = 6; // ilość postów do załadowania
        
            var projects = (function(setProjects) {
                var loaded;
                var total;
                return {
                    incLoaded: function() {
                        loaded = loaded + incNumber;
                    },
                    getLoaded: function() {
                        return loaded;
                    },
                    setLoaded: function(setProjects) {
                        loaded = setProjects;
                    },
                    setTotal: function(setProjects) {
                        total = setProjects;
                    },
                    getTotal: function() {
                        return total;
                    }
                };
            })();
            var loadingButton = (function(button){
                return {
                    showSpinner: function(button) {
                        button.html('Ładuję starsze...');
                    },
                    showCaption: function(button) {
                        button.html('Zobacz starsze');
                    },
                    hide: function(button) {
                        button.hide();
                    }
                };
            })();
        
            $('#load_more_posts').on('click', loadMore);
        
            function loadMore() {
                console.log('Clicked load_more');
                $(this).html('Ładuję...');
                post_offset = parseInt(post_offset) + 6;
                $.ajax({
                    url: ajax_url,
                    type: 'POST',
                    data: {
                        action: 'load_posts',
                        post_offset: post_offset,
                    },
                    success: function(data) {
                        $('#load_more_posts').html('Zobacz starsze');
                        $('#feed').append(data);
                        console.info('Ajax: OK');
                        bLazy.revalidate();
                        cardExcerpt();
                    }
                });
            }
        
        })();

    });
});

(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else {
		var a = factory();
		for(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];
	}
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(1);


/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; /* globals jQuery */
	
	exports.lory = lory;
	
	var _detectPrefixes = __webpack_require__(2);
	
	var _detectPrefixes2 = _interopRequireDefault(_detectPrefixes);
	
	var _dispatchEvent = __webpack_require__(3);
	
	var _dispatchEvent2 = _interopRequireDefault(_dispatchEvent);
	
	var _defaults = __webpack_require__(5);
	
	var _defaults2 = _interopRequireDefault(_defaults);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var slice = Array.prototype.slice;
	
	function lory(slider, opts) {
	    var position = void 0;
	    var slidesWidth = void 0;
	    var frameWidth = void 0;
	    var slides = void 0;
	
	    /**
	     * slider DOM elements
	     */
	    var frame = void 0;
	    var slideContainer = void 0;
	    var prevCtrl = void 0;
	    var nextCtrl = void 0;
	    var prefixes = void 0;
	    var transitionEndCallback = void 0;
	
	    var index = 0;
	    var options = {};
	
	    /**
	     * if object is jQuery convert to native DOM element
	     */
	    if (typeof jQuery !== 'undefined' && slider instanceof jQuery) {
	        slider = slider[0];
	    }
	
	    /**
	     * private
	     * set active class to element which is the current slide
	     */
	    function setActiveElement(slides, currentIndex) {
	        var _options = options;
	        var classNameActiveSlide = _options.classNameActiveSlide;
	
	
	        slides.forEach(function (element, index) {
	            if (element.classList.contains(classNameActiveSlide)) {
	                element.classList.remove(classNameActiveSlide);
	            }
	        });
	
	        slides[currentIndex].classList.add(classNameActiveSlide);
	    }
	
	    /**
	     * private
	     * setupInfinite: function to setup if infinite is set
	     *
	     * @param  {array} slideArray
	     * @return {array} array of updated slideContainer elements
	     */
	    function setupInfinite(slideArray) {
	        var _options2 = options;
	        var infinite = _options2.infinite;
	
	
	        var front = slideArray.slice(0, infinite);
	        var back = slideArray.slice(slideArray.length - infinite, slideArray.length);
	
	        front.forEach(function (element) {
	            var cloned = element.cloneNode(true);
	
	            slideContainer.appendChild(cloned);
	        });
	
	        back.reverse().forEach(function (element) {
	            var cloned = element.cloneNode(true);
	
	            slideContainer.insertBefore(cloned, slideContainer.firstChild);
	        });
	
	        slideContainer.addEventListener(prefixes.transitionEnd, onTransitionEnd);
	
	        return slice.call(slideContainer.children);
	    }
	
	    /**
	     * [dispatchSliderEvent description]
	     * @return {[type]} [description]
	     */
	    function dispatchSliderEvent(phase, type, detail) {
	        (0, _dispatchEvent2.default)(slider, phase + '.lory.' + type, detail);
	    }
	
	    /**
	     * translates to a given position in a given time in milliseconds
	     *
	     * @to        {number} number in pixels where to translate to
	     * @duration  {number} time in milliseconds for the transistion
	     * @ease      {string} easing css property
	     */
	    function translate(to, duration, ease) {
	        var style = slideContainer && slideContainer.style;
	
	        if (style) {
	            style[prefixes.transition + 'TimingFunction'] = ease;
	            style[prefixes.transition + 'Duration'] = duration + 'ms';
	
	            if (prefixes.hasTranslate3d) {
	                style[prefixes.transform] = 'translate3d(' + to + 'px, 0, 0)';
	            } else {
	                style[prefixes.transform] = 'translate(' + to + 'px, 0)';
	            }
	        }
	    }
	
	    /**
	     * slidefunction called by prev, next & touchend
	     *
	     * determine nextIndex and slide to next postion
	     * under restrictions of the defined options
	     *
	     * @direction  {boolean}
	     */
	    function slide(nextIndex, direction) {
	        var _options3 = options;
	        var slideSpeed = _options3.slideSpeed;
	        var slidesToScroll = _options3.slidesToScroll;
	        var infinite = _options3.infinite;
	        var rewind = _options3.rewind;
	        var rewindSpeed = _options3.rewindSpeed;
	        var ease = _options3.ease;
	        var classNameActiveSlide = _options3.classNameActiveSlide;
	
	
	        var duration = slideSpeed;
	
	        var nextSlide = direction ? index + 1 : index - 1;
	        var maxOffset = Math.round(slidesWidth - frameWidth);
	
	        dispatchSliderEvent('before', 'slide', {
	            index: index,
	            nextSlide: nextSlide
	        });
	
	        if (typeof nextIndex !== 'number') {
	            if (direction) {
	                nextIndex = index + slidesToScroll;
	            } else {
	                nextIndex = index - slidesToScroll;
	            }
	        }
	
	        nextIndex = Math.min(Math.max(nextIndex, 0), slides.length - 1);
	
	        if (infinite && direction === undefined) {
	            nextIndex += infinite;
	        }
	
	        var nextOffset = Math.min(Math.max(slides[nextIndex].offsetLeft * -1, maxOffset * -1), 0);
	
	        if (rewind && Math.abs(position.x) === maxOffset && direction) {
	            nextOffset = 0;
	            nextIndex = 0;
	            duration = rewindSpeed;
	        }
	
	        /**
	         * translate to the nextOffset by a defined duration and ease function
	         */
	        translate(nextOffset, duration, ease);
	
	        /**
	         * update the position with the next position
	         */
	        position.x = nextOffset;
	
	        /**
	         * update the index with the nextIndex only if
	         * the offset of the nextIndex is in the range of the maxOffset
	         */
	        if (slides[nextIndex].offsetLeft <= maxOffset) {
	            index = nextIndex;
	        }
	
	        if (infinite && (nextIndex === slides.length - infinite || nextIndex === 0)) {
	            if (direction) {
	                index = infinite;
	            }
	
	            if (!direction) {
	                index = slides.length - infinite * 2;
	            }
	
	            position.x = slides[index].offsetLeft * -1;
	
	            transitionEndCallback = function transitionEndCallback() {
	                translate(slides[index].offsetLeft * -1, 0, undefined);
	            };
	        }
	
	        if (classNameActiveSlide) {
	            setActiveElement(slice.call(slides), index);
	        }
	
	        dispatchSliderEvent('after', 'slide', {
	            currentSlide: index
	        });
	    }
	
	    /**
	     * public
	     * setup function
	     */
	    function setup() {
	        dispatchSliderEvent('before', 'init');
	
	        prefixes = (0, _detectPrefixes2.default)();
	        options = _extends({}, _defaults2.default, opts);
	
	        var _options4 = options;
	        var classNameFrame = _options4.classNameFrame;
	        var classNameSlideContainer = _options4.classNameSlideContainer;
	        var classNamePrevCtrl = _options4.classNamePrevCtrl;
	        var classNameNextCtrl = _options4.classNameNextCtrl;
	        var enableMouseEvents = _options4.enableMouseEvents;
	        var classNameActiveSlide = _options4.classNameActiveSlide;
	
	
	        frame = slider.getElementsByClassName(classNameFrame)[0];
	        slideContainer = frame.getElementsByClassName(classNameSlideContainer)[0];
	        prevCtrl = slider.getElementsByClassName(classNamePrevCtrl)[0];
	        nextCtrl = slider.getElementsByClassName(classNameNextCtrl)[0];
	
	        position = {
	            x: slideContainer.offsetLeft,
	            y: slideContainer.offsetTop
	        };
	
	        if (options.infinite) {
	            slides = setupInfinite(slice.call(slideContainer.children));
	        } else {
	            slides = slice.call(slideContainer.children);
	        }
	
	        reset();
	
	        if (classNameActiveSlide) {
	            setActiveElement(slides, index);
	        }
	
	        if (prevCtrl && nextCtrl) {
	            prevCtrl.addEventListener('click', prev);
	            nextCtrl.addEventListener('click', next);
	        }
	
	        frame.addEventListener('touchstart', onTouchstart);
	
	        if (enableMouseEvents) {
	            frame.addEventListener('mousedown', onTouchstart);
	            frame.addEventListener('click', onClick);
	        }
	
	        options.window.addEventListener('resize', onResize);
	
	        dispatchSliderEvent('after', 'init');
	    }
	
	    /**
	     * public
	     * reset function: called on resize
	     */
	    function reset() {
	        var _options5 = options;
	        var infinite = _options5.infinite;
	        var ease = _options5.ease;
	        var rewindSpeed = _options5.rewindSpeed;
	        var rewindOnResize = _options5.rewindOnResize;
	        var classNameActiveSlide = _options5.classNameActiveSlide;
	
	
	        slidesWidth = slideContainer.getBoundingClientRect().width || slideContainer.offsetWidth;
	        frameWidth = frame.getBoundingClientRect().width || frame.offsetWidth;
	
	        if (frameWidth === slidesWidth) {
	            slidesWidth = slides.reduce(function (previousValue, slide) {
	                return previousValue + slide.getBoundingClientRect().width || slide.offsetWidth;
	            }, 0);
	        }
	
	        if (rewindOnResize) {
	            index = 0;
	        } else {
	            ease = null;
	            rewindSpeed = 0;
	        }
	
	        if (infinite) {
	            translate(slides[index + infinite].offsetLeft * -1, 0, null);
	
	            index = index + infinite;
	            position.x = slides[index].offsetLeft * -1;
	        } else {
	            translate(slides[index].offsetLeft * -1, rewindSpeed, ease);
	            position.x = slides[index].offsetLeft * -1;
	        }
	
	        if (classNameActiveSlide) {
	            setActiveElement(slice.call(slides), index);
	        }
	    }
	
	    /**
	     * public
	     * slideTo: called on clickhandler
	     */
	    function slideTo(index) {
	        slide(index);
	    }
	
	    /**
	     * public
	     * returnIndex function: called on clickhandler
	     */
	    function returnIndex() {
	        return index - options.infinite || 0;
	    }
	
	    /**
	     * public
	     * prev function: called on clickhandler
	     */
	    function prev() {
	        slide(false, false);
	    }
	
	    /**
	     * public
	     * next function: called on clickhandler
	     */
	    function next() {
	        slide(false, true);
	    }
	
	    /**
	     * public
	     * destroy function: called to gracefully destroy the lory instance
	     */
	    function destroy() {
	        dispatchSliderEvent('before', 'destroy');
	
	        // remove event listeners
	        frame.removeEventListener(prefixes.transitionEnd, onTransitionEnd);
	        frame.removeEventListener('touchstart', onTouchstart);
	        frame.removeEventListener('touchmove', onTouchmove);
	        frame.removeEventListener('touchend', onTouchend);
	        frame.removeEventListener('mousemove', onTouchmove);
	        frame.removeEventListener('mousedown', onTouchstart);
	        frame.removeEventListener('mouseup', onTouchend);
	        frame.removeEventListener('mouseleave', onTouchend);
	        frame.removeEventListener('click', onClick);
	
	        options.window.removeEventListener('resize', onResize);
	
	        if (prevCtrl) {
	            prevCtrl.removeEventListener('click', prev);
	        }
	
	        if (nextCtrl) {
	            nextCtrl.removeEventListener('click', next);
	        }
	
	        // remove cloned slides if infinite is set
	        if (options.infinite) {
	            Array.apply(null, Array(options.infinite)).forEach(function () {
	                slideContainer.removeChild(slideContainer.firstChild);
	                slideContainer.removeChild(slideContainer.lastChild);
	            });
	        }
	
	        dispatchSliderEvent('after', 'destroy');
	    }
	
	    // event handling
	
	    var touchOffset = void 0;
	    var delta = void 0;
	    var isScrolling = void 0;
	
	    function onTransitionEnd() {
	        if (transitionEndCallback) {
	            transitionEndCallback();
	
	            transitionEndCallback = undefined;
	        }
	    }
	
	    function onTouchstart(event) {
	        var _options6 = options;
	        var enableMouseEvents = _options6.enableMouseEvents;
	
	        var touches = event.touches ? event.touches[0] : event;
	
	        if (enableMouseEvents) {
	            frame.addEventListener('mousemove', onTouchmove);
	            frame.addEventListener('mouseup', onTouchend);
	            frame.addEventListener('mouseleave', onTouchend);
	        }
	
	        frame.addEventListener('touchmove', onTouchmove);
	        frame.addEventListener('touchend', onTouchend);
	
	        var pageX = touches.pageX;
	        var pageY = touches.pageY;
	
	
	        touchOffset = {
	            x: pageX,
	            y: pageY,
	            time: Date.now()
	        };
	
	        isScrolling = undefined;
	
	        delta = {};
	
	        dispatchSliderEvent('on', 'touchstart', {
	            event: event
	        });
	    }
	
	    function onTouchmove(event) {
	        var touches = event.touches ? event.touches[0] : event;
	        var pageX = touches.pageX;
	        var pageY = touches.pageY;
	
	
	        delta = {
	            x: pageX - touchOffset.x,
	            y: pageY - touchOffset.y
	        };
	
	        if (typeof isScrolling === 'undefined') {
	            isScrolling = !!(isScrolling || Math.abs(delta.x) < Math.abs(delta.y));
	        }
	
	        if (!isScrolling && touchOffset) {
	            event.preventDefault();
	            translate(position.x + delta.x, 0, null);
	        }
	
	        // may be
	        dispatchSliderEvent('on', 'touchmove', {
	            event: event
	        });
	    }
	
	    function onTouchend(event) {
	        /**
	         * time between touchstart and touchend in milliseconds
	         * @duration {number}
	         */
	        var duration = touchOffset ? Date.now() - touchOffset.time : undefined;
	
	        /**
	         * is valid if:
	         *
	         * -> swipe attempt time is over 300 ms
	         * and
	         * -> swipe distance is greater than 25px
	         * or
	         * -> swipe distance is more then a third of the swipe area
	         *
	         * @isValidSlide {Boolean}
	         */
	        var isValid = Number(duration) < 300 && Math.abs(delta.x) > 25 || Math.abs(delta.x) > frameWidth / 3;
	
	        /**
	         * is out of bounds if:
	         *
	         * -> index is 0 and delta x is greater than 0
	         * or
	         * -> index is the last slide and delta is smaller than 0
	         *
	         * @isOutOfBounds {Boolean}
	         */
	        var isOutOfBounds = !index && delta.x > 0 || index === slides.length - 1 && delta.x < 0;
	
	        var direction = delta.x < 0;
	
	        if (!isScrolling) {
	            if (isValid && !isOutOfBounds) {
	                slide(false, direction);
	            } else {
	                translate(position.x, options.snapBackSpeed);
	            }
	        }
	
	        touchOffset = undefined;
	
	        /**
	         * remove eventlisteners after swipe attempt
	         */
	        frame.removeEventListener('touchmove', onTouchmove);
	        frame.removeEventListener('touchend', onTouchend);
	        frame.removeEventListener('mousemove', onTouchmove);
	        frame.removeEventListener('mouseup', onTouchend);
	        frame.removeEventListener('mouseleave', onTouchend);
	
	        dispatchSliderEvent('on', 'touchend', {
	            event: event
	        });
	    }
	
	    function onClick(event) {
	        if (delta.x) {
	            event.preventDefault();
	        }
	    }
	
	    function onResize(event) {
	        reset();
	
	        dispatchSliderEvent('on', 'resize', {
	            event: event
	        });
	    }
	
	    // trigger initial setup
	    setup();
	
	    // expose public api
	    return {
	        setup: setup,
	        reset: reset,
	        slideTo: slideTo,
	        returnIndex: returnIndex,
	        prev: prev,
	        next: next,
	        destroy: destroy
	    };
	}

/***/ },
/* 2 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = detectPrefixes;
	/**
	 * Detecting prefixes for saving time and bytes
	 */
	function detectPrefixes() {
	    var transform = void 0;
	    var transition = void 0;
	    var transitionEnd = void 0;
	    var hasTranslate3d = void 0;
	
	    (function () {
	        var el = document.createElement('_');
	        var style = el.style;
	
	        var prop = void 0;
	
	        if (style[prop = 'webkitTransition'] === '') {
	            transitionEnd = 'webkitTransitionEnd';
	            transition = prop;
	        }
	
	        if (style[prop = 'transition'] === '') {
	            transitionEnd = 'transitionend';
	            transition = prop;
	        }
	
	        if (style[prop = 'webkitTransform'] === '') {
	            transform = prop;
	        }
	
	        if (style[prop = 'msTransform'] === '') {
	            transform = prop;
	        }
	
	        if (style[prop = 'transform'] === '') {
	            transform = prop;
	        }
	
	        document.body.insertBefore(el, null);
	        style[transform] = 'translate3d(0, 0, 0)';
	        hasTranslate3d = !!global.getComputedStyle(el).getPropertyValue(transform);
	        document.body.removeChild(el);
	    })();
	
	    return {
	        transform: transform,
	        transition: transition,
	        transitionEnd: transitionEnd,
	        hasTranslate3d: hasTranslate3d
	    };
	}
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = dispatchEvent;
	
	var _customEvent = __webpack_require__(4);
	
	var _customEvent2 = _interopRequireDefault(_customEvent);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * dispatch custom events
	 *
	 * @param  {element} el         slideshow element
	 * @param  {string}  type       custom event name
	 * @param  {object}  detail     custom detail information
	 */
	function dispatchEvent(target, type, detail) {
	    var event = new _customEvent2.default(type, {
	        bubbles: true,
	        cancelable: true,
	        detail: detail
	    });
	
	    target.dispatchEvent(event);
	}

/***/ },
/* 4 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {
	var NativeCustomEvent = global.CustomEvent;
	
	function useNative () {
	  try {
	    var p = new NativeCustomEvent('cat', { detail: { foo: 'bar' } });
	    return  'cat' === p.type && 'bar' === p.detail.foo;
	  } catch (e) {
	  }
	  return false;
	}
	
	/**
	 * Cross-browser `CustomEvent` constructor.
	 *
	 * https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent.CustomEvent
	 *
	 * @public
	 */
	
	module.exports = useNative() ? NativeCustomEvent :
	
	// IE >= 9
	'function' === typeof document.createEvent ? function CustomEvent (type, params) {
	  var e = document.createEvent('CustomEvent');
	  if (params) {
	    e.initCustomEvent(type, params.bubbles, params.cancelable, params.detail);
	  } else {
	    e.initCustomEvent(type, false, false, void 0);
	  }
	  return e;
	} :
	
	// IE <= 8
	function CustomEvent (type, params) {
	  var e = document.createEventObject();
	  e.type = type;
	  if (params) {
	    e.bubbles = Boolean(params.bubbles);
	    e.cancelable = Boolean(params.cancelable);
	    e.detail = params.detail;
	  } else {
	    e.bubbles = false;
	    e.cancelable = false;
	    e.detail = void 0;
	  }
	  return e;
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 5 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = {
	  /**
	   * slides scrolled at once
	   * @slidesToScroll {Number}
	   */
	  slidesToScroll: 1,
	
	  /**
	   * time in milliseconds for the animation of a valid slide attempt
	   * @slideSpeed {Number}
	   */
	  slideSpeed: 300,
	
	  /**
	   * time in milliseconds for the animation of the rewind after the last slide
	   * @rewindSpeed {Number}
	   */
	  rewindSpeed: 600,
	
	  /**
	   * time for the snapBack of the slider if the slide attempt was not valid
	   * @snapBackSpeed {Number}
	   */
	  snapBackSpeed: 200,
	
	  /**
	   * Basic easing functions: https://developer.mozilla.org/de/docs/Web/CSS/transition-timing-function
	   * cubic bezier easing functions: http://easings.net/de
	   * @ease {String}
	   */
	  ease: 'ease',
	
	  /**
	   * if slider reached the last slide, with next click the slider goes back to the startindex.
	   * use infinite or rewind, not both
	   * @rewind {Boolean}
	   */
	  rewind: false,
	
	  /**
	   * number of visible slides or false
	   * use infinite or rewind, not both
	   * @infinite {number}
	   */
	  infinite: false,
	
	  /**
	   * class name for slider frame
	   * @classNameFrame {string}
	   */
	  classNameFrame: 'js_frame',
	
	  /**
	   * class name for slides container
	   * @classNameSlideContainer {string}
	   */
	  classNameSlideContainer: 'js_slides',
	
	  /**
	   * class name for slider prev control
	   * @classNamePrevCtrl {string}
	   */
	  classNamePrevCtrl: 'js_prev',
	
	  /**
	   * class name for slider next control
	   * @classNameNextCtrl {string}
	   */
	  classNameNextCtrl: 'js_next',
	
	  /**
	   * class name for current active slide
	   * if emptyString then no class is set
	   * @classNameActiveSlide {string}
	   */
	  classNameActiveSlide: 'active',
	
	  /**
	   * enables mouse events for swiping on desktop devices
	   * @enableMouseEvents {boolean}
	   */
	  enableMouseEvents: false,
	
	  /**
	   * window instance
	   * @window {object}
	   */
	  window: window,
	
	  /**
	   * If false, slides lory to the first slide on window resize.
	   * @rewindOnResize {boolean}
	   */
	  rewindOnResize: true
	};

/***/ }
/******/ ])
});
;
// https://github.com/lewiscollard/horsepower/blob/29d406877d74705c61f27cc656a95ecfde86b987/assets/js/50-carousel.js
    function makeCarousel(selector) {
        var simple = document.querySelector(selector);
        if (!simple) {
            return;
        }
        var loryCarousel = lory(simple, {
            infinite: 1,
            enableMouseEvents: true,
            classNamePrevCtrl:'slider__prev',
            classNameNextCtrl:'slider__next',
            classNameSlideContainer: 'slider__slides',
            classNameFrame: 'slider__frame',
        });

        // Autoplay
        var timer = window.setInterval(function () {
            loryCarousel.next();
        }, 5000);

        function cancelTimer() {
            window.clearInterval(timer);
        }

        simple.querySelector('.slider__next').addEventListener('click', cancelTimer);
        simple.querySelector('.slider__prev').addEventListener('click', cancelTimer);
        simple.addEventListener('on.lory.touchstart', cancelTimer);
    }

    window.addEventListener('load', function() {
        makeCarousel('.js_simple');
    });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiIiwic291cmNlcyI6WyJtYWluLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImpRdWVyeShmdW5jdGlvbigkKSB7XG5cbiAgICAgICBmdW5jdGlvbiBjYXJkRXhjZXJwdCgpIHtcbiAgICAgICAgJChcIi5jYXJkX19leGNlcnB0XCIpLnRleHQoZnVuY3Rpb24oaW5kZXgsIGN1cnJlbnRUZXh0KSB7XG4gICAgICAgICAgcmV0dXJuIGN1cnJlbnRUZXh0LnN1YnN0cigwLCAxMjUpICsgJ1xcdTIwMjYnO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGNhcmRFeGNlcnB0KCk7XG4gICAgICBmdW5jdGlvbiBmZWF0dXJlZFRpdGxlKCkge1xuICAgICAgICQoXCIuZmVhdHVyZWRfX3RpdGxlXCIpLnRleHQoZnVuY3Rpb24oaW5kZXgsIGN1cnJlbnRUZXh0KSB7XG4gICAgICAgICByZXR1cm4gY3VycmVudFRleHQuc3Vic3RyKDAsIDcyKSArICdcXHUyMDI2JztcbiAgICAgICB9KTtcbiAgICAgfVxuICAgICBmZWF0dXJlZFRpdGxlKCk7XG5cbiAgICAkKGRvY3VtZW50KS5yZWFkeShmdW5jdGlvbigpIHtcblxuICAgICAgICAoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAkKCcuc3BvcnRzcHJlc3Mgc3R5bGUnKS5yZW1vdmUoKTtcbiAgICAgICAgICAgICQoJy5nYWxsZXJ5LWl0ZW0gYScpLmFkZENsYXNzKCdsaW5rJyk7XG4gICAgICAgIFxuICAgICAgICAgICAgJCgnLnNwLXRlYW0tbmFtZScpLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgJCh0aGlzKS5pbnNlcnRBZnRlcigkKHRoaXMpLnBhcmVudCgpLmZpbmQoJ2ltZycpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KSgpO1xuXG4gICAgICAgICAgICAvLyAkKFwiI25hdi1tb2JpbGVcIikuaHRtbCgkKFwiI25hdi1tYWluXCIpLmh0bWwoKSk7XG4gICAgICAgICAgICAkKFwiI25hdi10cmlnZ2VyIC5uYXZpY29uLWJ1dHRvblwiKS5jbGljayhmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmluZm8oJ0J1cmdlciBjbGlja2VkJyk7XG4gICAgICAgICAgICAgICAgaWYgKCQoXCIudG9wYmFyXCIpLmhhc0NsYXNzKFwidG9wYmFyLS1leHBhbmRlZFwiKSkge1xuICAgICAgICAgICAgICAgICAgICAkKFwiLnRvcGJhclwiKS5yZW1vdmVDbGFzcyhcInRvcGJhci0tZXhwYW5kZWRcIik7XG4gICAgICAgICAgICAgICAgICAgICQodGhpcykucmVtb3ZlQ2xhc3MoXCJvcGVuXCIpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICQoXCIudG9wYmFyXCIpLmFkZENsYXNzKFwidG9wYmFyLS1leHBhbmRlZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgJCh0aGlzKS5hZGRDbGFzcyhcIm9wZW5cIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgXG4gICAgICAgIHZhciBiTGF6eSA9IG5ldyBCbGF6eSh7XG4gICAgICAgICAgb2Zmc2V0OiAyMCxcbiAgICAgICAgICBzZWxlY3RvcjogJy5ibGF6eScsXG4gICAgICAgICAgbG9hZEludmlzaWJsZTogZmFsc2UsXG4gICAgICAgICAgYnJlYWtwb2ludHM6IFt7XG4gICAgICAgICAgICB3aWR0aDogMzYwLCAvLyBNYXgtd2lkdGhcbiAgICAgICAgICAgIHNyYzogJ2RhdGEtc3JjLXNtYWxsJ1xuICAgICAgICAgIH1dLFxuICAgICAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgICAgICAgICQoZWxlbWVudCkucGFyZW50KCkucmVtb3ZlQ2xhc3MoJ2xvYWRpbmcnLCA1MDApO1xuICAgICAgICAgICAgdXBkYXRlQ291bnRlcigpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZXJyb3I6IGZ1bmN0aW9uKGVsZW1lbnQsIG1zZykge1xuICAgICAgICAgICAgaWYgKG1zZyA9PT0gJ21pc3NpbmcnKSB7XG4gICAgICAgICAgICAgICQoZWxlbWVudCkucGFyZW50KCkucmVtb3ZlQ2xhc3MoJ2xvYWRpbmcnLCA1MDApOyAvLyBEYXRhLXNyYyBpcyBtaXNzaW5nXG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJiTGF6eTogZGF0YS1zcmMgaXMgbWlzc2luZ1wiKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobXNnID09PSAnaW52YWxpZCcpIHtcbiAgICAgICAgICAgICAgJChlbGVtZW50KS5wYXJlbnQoKS5yZW1vdmVDbGFzcygnbG9hZGluZycsIDUwMCk7XG4gICAgICAgICAgICAgIC8vIERhdGEtc3JjIGlzIGludmFsaWRcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcImJMYXp5OiBkYXRhLXNyYyBpcyBpbnZhbGlkXCIpO1xuICAgICAgICBcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBub3QgbmVlZGVkLCBvbmx5IGhlcmUgdG8gaWxsdXN0cmF0ZSBhbW91bnQgb2YgbG9hZGVkIGltYWdlc1xuICAgICAgICB2YXIgaW1hZ2VMb2FkZWQgPSAwO1xuICAgICAgICBcbiAgICAgICAgZnVuY3Rpb24gdXBkYXRlQ291bnRlcigpIHtcbiAgICAgICAgICBpbWFnZUxvYWRlZCsrO1xuICAgICAgICAgIGNvbnNvbGUuaW5mbyhcImJMYXp5OiBJbWFnZXMgbG9hZGVkOiAlZFwiLCBpbWFnZUxvYWRlZCk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIHRhYnMoYkxhenkpO1xuXG4gICAgICAgIChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBhamF4X3VybCA9ICQoJ2JvZHknKS5hdHRyKCdkYXRhLWFqYXgtdXJsJyk7XG4gICAgICAgICAgICB2YXIgcG9zdF9vZmZzZXQgPSAwO1xuICAgICAgICAgICAgdmFyIGluY051bWJlciA9IDY7IC8vIGlsb8WbxIcgcG9zdMOzdyBkbyB6YcWCYWRvd2FuaWFcbiAgICAgICAgXG4gICAgICAgICAgICB2YXIgcHJvamVjdHMgPSAoZnVuY3Rpb24oc2V0UHJvamVjdHMpIHtcbiAgICAgICAgICAgICAgICB2YXIgbG9hZGVkO1xuICAgICAgICAgICAgICAgIHZhciB0b3RhbDtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBpbmNMb2FkZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9hZGVkID0gbG9hZGVkICsgaW5jTnVtYmVyO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBnZXRMb2FkZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxvYWRlZDtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgc2V0TG9hZGVkOiBmdW5jdGlvbihzZXRQcm9qZWN0cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9hZGVkID0gc2V0UHJvamVjdHM7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHNldFRvdGFsOiBmdW5jdGlvbihzZXRQcm9qZWN0cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG90YWwgPSBzZXRQcm9qZWN0cztcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgZ2V0VG90YWw6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRvdGFsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pKCk7XG4gICAgICAgICAgICB2YXIgbG9hZGluZ0J1dHRvbiA9IChmdW5jdGlvbihidXR0b24pe1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHNob3dTcGlubmVyOiBmdW5jdGlvbihidXR0b24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1dHRvbi5odG1sKCfFgWFkdWrEmSBzdGFyc3plLi4uJyk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHNob3dDYXB0aW9uOiBmdW5jdGlvbihidXR0b24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1dHRvbi5odG1sKCdab2JhY3ogc3RhcnN6ZScpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBoaWRlOiBmdW5jdGlvbihidXR0b24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1dHRvbi5oaWRlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgXG4gICAgICAgICAgICAkKCcjbG9hZF9tb3JlX3Bvc3RzJykub24oJ2NsaWNrJywgbG9hZE1vcmUpO1xuICAgICAgICBcbiAgICAgICAgICAgIGZ1bmN0aW9uIGxvYWRNb3JlKCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdDbGlja2VkIGxvYWRfbW9yZScpO1xuICAgICAgICAgICAgICAgICQodGhpcykuaHRtbCgnxYFhZHVqxJkuLi4nKTtcbiAgICAgICAgICAgICAgICBwb3N0X29mZnNldCA9IHBhcnNlSW50KHBvc3Rfb2Zmc2V0KSArIDY7XG4gICAgICAgICAgICAgICAgJC5hamF4KHtcbiAgICAgICAgICAgICAgICAgICAgdXJsOiBhamF4X3VybCxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ1BPU1QnLFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb246ICdsb2FkX3Bvc3RzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc3Rfb2Zmc2V0OiBwb3N0X29mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgc3VjY2VzczogZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgJCgnI2xvYWRfbW9yZV9wb3N0cycpLmh0bWwoJ1pvYmFjeiBzdGFyc3plJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAkKCcjZmVlZCcpLmFwcGVuZChkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuaW5mbygnQWpheDogT0snKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJMYXp5LnJldmFsaWRhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhcmRFeGNlcnB0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIH0pKCk7XG5cbiAgICB9KTtcbn0pO1xuXG4oZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShbXSwgZmFjdG9yeSk7XG5cdGVsc2Uge1xuXHRcdHZhciBhID0gZmFjdG9yeSgpO1xuXHRcdGZvcih2YXIgaSBpbiBhKSAodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnID8gZXhwb3J0cyA6IHJvb3QpW2ldID0gYVtpXTtcblx0fVxufSkodGhpcywgZnVuY3Rpb24oKSB7XG5yZXR1cm4gLyoqKioqKi8gKGZ1bmN0aW9uKG1vZHVsZXMpIHsgLy8gd2VicGFja0Jvb3RzdHJhcFxuLyoqKioqKi8gXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuLyoqKioqKi8gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuLyoqKioqKi8gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKVxuLyoqKioqKi8gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4vKioqKioqLyBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuLyoqKioqKi8gXHRcdFx0ZXhwb3J0czoge30sXG4vKioqKioqLyBcdFx0XHRpZDogbW9kdWxlSWQsXG4vKioqKioqLyBcdFx0XHRsb2FkZWQ6IGZhbHNlXG4vKioqKioqLyBcdFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4vKioqKioqLyBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbi8qKioqKiovIFx0XHRtb2R1bGUubG9hZGVkID0gdHJ1ZTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbi8qKioqKiovIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdH1cbi8qKioqKiovXG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbi8qKioqKiovIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oMCk7XG4vKioqKioqLyB9KVxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIChbXG4vKiAwICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHRtb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cblxuLyoqKi8gfSxcbi8qIDEgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdCd1c2Ugc3RyaWN0Jztcblx0XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuXHQgICAgdmFsdWU6IHRydWVcblx0fSk7XG5cdFxuXHR2YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9OyAvKiBnbG9iYWxzIGpRdWVyeSAqL1xuXHRcblx0ZXhwb3J0cy5sb3J5ID0gbG9yeTtcblx0XG5cdHZhciBfZGV0ZWN0UHJlZml4ZXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuXHRcblx0dmFyIF9kZXRlY3RQcmVmaXhlczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9kZXRlY3RQcmVmaXhlcyk7XG5cdFxuXHR2YXIgX2Rpc3BhdGNoRXZlbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuXHRcblx0dmFyIF9kaXNwYXRjaEV2ZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2Rpc3BhdGNoRXZlbnQpO1xuXHRcblx0dmFyIF9kZWZhdWx0cyA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG5cdFxuXHR2YXIgX2RlZmF1bHRzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2RlZmF1bHRzKTtcblx0XG5cdGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cdFxuXHR2YXIgc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG5cdFxuXHRmdW5jdGlvbiBsb3J5KHNsaWRlciwgb3B0cykge1xuXHQgICAgdmFyIHBvc2l0aW9uID0gdm9pZCAwO1xuXHQgICAgdmFyIHNsaWRlc1dpZHRoID0gdm9pZCAwO1xuXHQgICAgdmFyIGZyYW1lV2lkdGggPSB2b2lkIDA7XG5cdCAgICB2YXIgc2xpZGVzID0gdm9pZCAwO1xuXHRcblx0ICAgIC8qKlxuXHQgICAgICogc2xpZGVyIERPTSBlbGVtZW50c1xuXHQgICAgICovXG5cdCAgICB2YXIgZnJhbWUgPSB2b2lkIDA7XG5cdCAgICB2YXIgc2xpZGVDb250YWluZXIgPSB2b2lkIDA7XG5cdCAgICB2YXIgcHJldkN0cmwgPSB2b2lkIDA7XG5cdCAgICB2YXIgbmV4dEN0cmwgPSB2b2lkIDA7XG5cdCAgICB2YXIgcHJlZml4ZXMgPSB2b2lkIDA7XG5cdCAgICB2YXIgdHJhbnNpdGlvbkVuZENhbGxiYWNrID0gdm9pZCAwO1xuXHRcblx0ICAgIHZhciBpbmRleCA9IDA7XG5cdCAgICB2YXIgb3B0aW9ucyA9IHt9O1xuXHRcblx0ICAgIC8qKlxuXHQgICAgICogaWYgb2JqZWN0IGlzIGpRdWVyeSBjb252ZXJ0IHRvIG5hdGl2ZSBET00gZWxlbWVudFxuXHQgICAgICovXG5cdCAgICBpZiAodHlwZW9mIGpRdWVyeSAhPT0gJ3VuZGVmaW5lZCcgJiYgc2xpZGVyIGluc3RhbmNlb2YgalF1ZXJ5KSB7XG5cdCAgICAgICAgc2xpZGVyID0gc2xpZGVyWzBdO1xuXHQgICAgfVxuXHRcblx0ICAgIC8qKlxuXHQgICAgICogcHJpdmF0ZVxuXHQgICAgICogc2V0IGFjdGl2ZSBjbGFzcyB0byBlbGVtZW50IHdoaWNoIGlzIHRoZSBjdXJyZW50IHNsaWRlXG5cdCAgICAgKi9cblx0ICAgIGZ1bmN0aW9uIHNldEFjdGl2ZUVsZW1lbnQoc2xpZGVzLCBjdXJyZW50SW5kZXgpIHtcblx0ICAgICAgICB2YXIgX29wdGlvbnMgPSBvcHRpb25zO1xuXHQgICAgICAgIHZhciBjbGFzc05hbWVBY3RpdmVTbGlkZSA9IF9vcHRpb25zLmNsYXNzTmFtZUFjdGl2ZVNsaWRlO1xuXHRcblx0XG5cdCAgICAgICAgc2xpZGVzLmZvckVhY2goZnVuY3Rpb24gKGVsZW1lbnQsIGluZGV4KSB7XG5cdCAgICAgICAgICAgIGlmIChlbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyhjbGFzc05hbWVBY3RpdmVTbGlkZSkpIHtcblx0ICAgICAgICAgICAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShjbGFzc05hbWVBY3RpdmVTbGlkZSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9KTtcblx0XG5cdCAgICAgICAgc2xpZGVzW2N1cnJlbnRJbmRleF0uY2xhc3NMaXN0LmFkZChjbGFzc05hbWVBY3RpdmVTbGlkZSk7XG5cdCAgICB9XG5cdFxuXHQgICAgLyoqXG5cdCAgICAgKiBwcml2YXRlXG5cdCAgICAgKiBzZXR1cEluZmluaXRlOiBmdW5jdGlvbiB0byBzZXR1cCBpZiBpbmZpbml0ZSBpcyBzZXRcblx0ICAgICAqXG5cdCAgICAgKiBAcGFyYW0gIHthcnJheX0gc2xpZGVBcnJheVxuXHQgICAgICogQHJldHVybiB7YXJyYXl9IGFycmF5IG9mIHVwZGF0ZWQgc2xpZGVDb250YWluZXIgZWxlbWVudHNcblx0ICAgICAqL1xuXHQgICAgZnVuY3Rpb24gc2V0dXBJbmZpbml0ZShzbGlkZUFycmF5KSB7XG5cdCAgICAgICAgdmFyIF9vcHRpb25zMiA9IG9wdGlvbnM7XG5cdCAgICAgICAgdmFyIGluZmluaXRlID0gX29wdGlvbnMyLmluZmluaXRlO1xuXHRcblx0XG5cdCAgICAgICAgdmFyIGZyb250ID0gc2xpZGVBcnJheS5zbGljZSgwLCBpbmZpbml0ZSk7XG5cdCAgICAgICAgdmFyIGJhY2sgPSBzbGlkZUFycmF5LnNsaWNlKHNsaWRlQXJyYXkubGVuZ3RoIC0gaW5maW5pdGUsIHNsaWRlQXJyYXkubGVuZ3RoKTtcblx0XG5cdCAgICAgICAgZnJvbnQuZm9yRWFjaChmdW5jdGlvbiAoZWxlbWVudCkge1xuXHQgICAgICAgICAgICB2YXIgY2xvbmVkID0gZWxlbWVudC5jbG9uZU5vZGUodHJ1ZSk7XG5cdFxuXHQgICAgICAgICAgICBzbGlkZUNvbnRhaW5lci5hcHBlbmRDaGlsZChjbG9uZWQpO1xuXHQgICAgICAgIH0pO1xuXHRcblx0ICAgICAgICBiYWNrLnJldmVyc2UoKS5mb3JFYWNoKGZ1bmN0aW9uIChlbGVtZW50KSB7XG5cdCAgICAgICAgICAgIHZhciBjbG9uZWQgPSBlbGVtZW50LmNsb25lTm9kZSh0cnVlKTtcblx0XG5cdCAgICAgICAgICAgIHNsaWRlQ29udGFpbmVyLmluc2VydEJlZm9yZShjbG9uZWQsIHNsaWRlQ29udGFpbmVyLmZpcnN0Q2hpbGQpO1xuXHQgICAgICAgIH0pO1xuXHRcblx0ICAgICAgICBzbGlkZUNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKHByZWZpeGVzLnRyYW5zaXRpb25FbmQsIG9uVHJhbnNpdGlvbkVuZCk7XG5cdFxuXHQgICAgICAgIHJldHVybiBzbGljZS5jYWxsKHNsaWRlQ29udGFpbmVyLmNoaWxkcmVuKTtcblx0ICAgIH1cblx0XG5cdCAgICAvKipcblx0ICAgICAqIFtkaXNwYXRjaFNsaWRlckV2ZW50IGRlc2NyaXB0aW9uXVxuXHQgICAgICogQHJldHVybiB7W3R5cGVdfSBbZGVzY3JpcHRpb25dXG5cdCAgICAgKi9cblx0ICAgIGZ1bmN0aW9uIGRpc3BhdGNoU2xpZGVyRXZlbnQocGhhc2UsIHR5cGUsIGRldGFpbCkge1xuXHQgICAgICAgICgwLCBfZGlzcGF0Y2hFdmVudDIuZGVmYXVsdCkoc2xpZGVyLCBwaGFzZSArICcubG9yeS4nICsgdHlwZSwgZGV0YWlsKTtcblx0ICAgIH1cblx0XG5cdCAgICAvKipcblx0ICAgICAqIHRyYW5zbGF0ZXMgdG8gYSBnaXZlbiBwb3NpdGlvbiBpbiBhIGdpdmVuIHRpbWUgaW4gbWlsbGlzZWNvbmRzXG5cdCAgICAgKlxuXHQgICAgICogQHRvICAgICAgICB7bnVtYmVyfSBudW1iZXIgaW4gcGl4ZWxzIHdoZXJlIHRvIHRyYW5zbGF0ZSB0b1xuXHQgICAgICogQGR1cmF0aW9uICB7bnVtYmVyfSB0aW1lIGluIG1pbGxpc2Vjb25kcyBmb3IgdGhlIHRyYW5zaXN0aW9uXG5cdCAgICAgKiBAZWFzZSAgICAgIHtzdHJpbmd9IGVhc2luZyBjc3MgcHJvcGVydHlcblx0ICAgICAqL1xuXHQgICAgZnVuY3Rpb24gdHJhbnNsYXRlKHRvLCBkdXJhdGlvbiwgZWFzZSkge1xuXHQgICAgICAgIHZhciBzdHlsZSA9IHNsaWRlQ29udGFpbmVyICYmIHNsaWRlQ29udGFpbmVyLnN0eWxlO1xuXHRcblx0ICAgICAgICBpZiAoc3R5bGUpIHtcblx0ICAgICAgICAgICAgc3R5bGVbcHJlZml4ZXMudHJhbnNpdGlvbiArICdUaW1pbmdGdW5jdGlvbiddID0gZWFzZTtcblx0ICAgICAgICAgICAgc3R5bGVbcHJlZml4ZXMudHJhbnNpdGlvbiArICdEdXJhdGlvbiddID0gZHVyYXRpb24gKyAnbXMnO1xuXHRcblx0ICAgICAgICAgICAgaWYgKHByZWZpeGVzLmhhc1RyYW5zbGF0ZTNkKSB7XG5cdCAgICAgICAgICAgICAgICBzdHlsZVtwcmVmaXhlcy50cmFuc2Zvcm1dID0gJ3RyYW5zbGF0ZTNkKCcgKyB0byArICdweCwgMCwgMCknO1xuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgc3R5bGVbcHJlZml4ZXMudHJhbnNmb3JtXSA9ICd0cmFuc2xhdGUoJyArIHRvICsgJ3B4LCAwKSc7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICB9XG5cdFxuXHQgICAgLyoqXG5cdCAgICAgKiBzbGlkZWZ1bmN0aW9uIGNhbGxlZCBieSBwcmV2LCBuZXh0ICYgdG91Y2hlbmRcblx0ICAgICAqXG5cdCAgICAgKiBkZXRlcm1pbmUgbmV4dEluZGV4IGFuZCBzbGlkZSB0byBuZXh0IHBvc3Rpb25cblx0ICAgICAqIHVuZGVyIHJlc3RyaWN0aW9ucyBvZiB0aGUgZGVmaW5lZCBvcHRpb25zXG5cdCAgICAgKlxuXHQgICAgICogQGRpcmVjdGlvbiAge2Jvb2xlYW59XG5cdCAgICAgKi9cblx0ICAgIGZ1bmN0aW9uIHNsaWRlKG5leHRJbmRleCwgZGlyZWN0aW9uKSB7XG5cdCAgICAgICAgdmFyIF9vcHRpb25zMyA9IG9wdGlvbnM7XG5cdCAgICAgICAgdmFyIHNsaWRlU3BlZWQgPSBfb3B0aW9uczMuc2xpZGVTcGVlZDtcblx0ICAgICAgICB2YXIgc2xpZGVzVG9TY3JvbGwgPSBfb3B0aW9uczMuc2xpZGVzVG9TY3JvbGw7XG5cdCAgICAgICAgdmFyIGluZmluaXRlID0gX29wdGlvbnMzLmluZmluaXRlO1xuXHQgICAgICAgIHZhciByZXdpbmQgPSBfb3B0aW9uczMucmV3aW5kO1xuXHQgICAgICAgIHZhciByZXdpbmRTcGVlZCA9IF9vcHRpb25zMy5yZXdpbmRTcGVlZDtcblx0ICAgICAgICB2YXIgZWFzZSA9IF9vcHRpb25zMy5lYXNlO1xuXHQgICAgICAgIHZhciBjbGFzc05hbWVBY3RpdmVTbGlkZSA9IF9vcHRpb25zMy5jbGFzc05hbWVBY3RpdmVTbGlkZTtcblx0XG5cdFxuXHQgICAgICAgIHZhciBkdXJhdGlvbiA9IHNsaWRlU3BlZWQ7XG5cdFxuXHQgICAgICAgIHZhciBuZXh0U2xpZGUgPSBkaXJlY3Rpb24gPyBpbmRleCArIDEgOiBpbmRleCAtIDE7XG5cdCAgICAgICAgdmFyIG1heE9mZnNldCA9IE1hdGgucm91bmQoc2xpZGVzV2lkdGggLSBmcmFtZVdpZHRoKTtcblx0XG5cdCAgICAgICAgZGlzcGF0Y2hTbGlkZXJFdmVudCgnYmVmb3JlJywgJ3NsaWRlJywge1xuXHQgICAgICAgICAgICBpbmRleDogaW5kZXgsXG5cdCAgICAgICAgICAgIG5leHRTbGlkZTogbmV4dFNsaWRlXG5cdCAgICAgICAgfSk7XG5cdFxuXHQgICAgICAgIGlmICh0eXBlb2YgbmV4dEluZGV4ICE9PSAnbnVtYmVyJykge1xuXHQgICAgICAgICAgICBpZiAoZGlyZWN0aW9uKSB7XG5cdCAgICAgICAgICAgICAgICBuZXh0SW5kZXggPSBpbmRleCArIHNsaWRlc1RvU2Nyb2xsO1xuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgbmV4dEluZGV4ID0gaW5kZXggLSBzbGlkZXNUb1Njcm9sbDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0XG5cdCAgICAgICAgbmV4dEluZGV4ID0gTWF0aC5taW4oTWF0aC5tYXgobmV4dEluZGV4LCAwKSwgc2xpZGVzLmxlbmd0aCAtIDEpO1xuXHRcblx0ICAgICAgICBpZiAoaW5maW5pdGUgJiYgZGlyZWN0aW9uID09PSB1bmRlZmluZWQpIHtcblx0ICAgICAgICAgICAgbmV4dEluZGV4ICs9IGluZmluaXRlO1xuXHQgICAgICAgIH1cblx0XG5cdCAgICAgICAgdmFyIG5leHRPZmZzZXQgPSBNYXRoLm1pbihNYXRoLm1heChzbGlkZXNbbmV4dEluZGV4XS5vZmZzZXRMZWZ0ICogLTEsIG1heE9mZnNldCAqIC0xKSwgMCk7XG5cdFxuXHQgICAgICAgIGlmIChyZXdpbmQgJiYgTWF0aC5hYnMocG9zaXRpb24ueCkgPT09IG1heE9mZnNldCAmJiBkaXJlY3Rpb24pIHtcblx0ICAgICAgICAgICAgbmV4dE9mZnNldCA9IDA7XG5cdCAgICAgICAgICAgIG5leHRJbmRleCA9IDA7XG5cdCAgICAgICAgICAgIGR1cmF0aW9uID0gcmV3aW5kU3BlZWQ7XG5cdCAgICAgICAgfVxuXHRcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiB0cmFuc2xhdGUgdG8gdGhlIG5leHRPZmZzZXQgYnkgYSBkZWZpbmVkIGR1cmF0aW9uIGFuZCBlYXNlIGZ1bmN0aW9uXG5cdCAgICAgICAgICovXG5cdCAgICAgICAgdHJhbnNsYXRlKG5leHRPZmZzZXQsIGR1cmF0aW9uLCBlYXNlKTtcblx0XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogdXBkYXRlIHRoZSBwb3NpdGlvbiB3aXRoIHRoZSBuZXh0IHBvc2l0aW9uXG5cdCAgICAgICAgICovXG5cdCAgICAgICAgcG9zaXRpb24ueCA9IG5leHRPZmZzZXQ7XG5cdFxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIHVwZGF0ZSB0aGUgaW5kZXggd2l0aCB0aGUgbmV4dEluZGV4IG9ubHkgaWZcblx0ICAgICAgICAgKiB0aGUgb2Zmc2V0IG9mIHRoZSBuZXh0SW5kZXggaXMgaW4gdGhlIHJhbmdlIG9mIHRoZSBtYXhPZmZzZXRcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBpZiAoc2xpZGVzW25leHRJbmRleF0ub2Zmc2V0TGVmdCA8PSBtYXhPZmZzZXQpIHtcblx0ICAgICAgICAgICAgaW5kZXggPSBuZXh0SW5kZXg7XG5cdCAgICAgICAgfVxuXHRcblx0ICAgICAgICBpZiAoaW5maW5pdGUgJiYgKG5leHRJbmRleCA9PT0gc2xpZGVzLmxlbmd0aCAtIGluZmluaXRlIHx8IG5leHRJbmRleCA9PT0gMCkpIHtcblx0ICAgICAgICAgICAgaWYgKGRpcmVjdGlvbikge1xuXHQgICAgICAgICAgICAgICAgaW5kZXggPSBpbmZpbml0ZTtcblx0ICAgICAgICAgICAgfVxuXHRcblx0ICAgICAgICAgICAgaWYgKCFkaXJlY3Rpb24pIHtcblx0ICAgICAgICAgICAgICAgIGluZGV4ID0gc2xpZGVzLmxlbmd0aCAtIGluZmluaXRlICogMjtcblx0ICAgICAgICAgICAgfVxuXHRcblx0ICAgICAgICAgICAgcG9zaXRpb24ueCA9IHNsaWRlc1tpbmRleF0ub2Zmc2V0TGVmdCAqIC0xO1xuXHRcblx0ICAgICAgICAgICAgdHJhbnNpdGlvbkVuZENhbGxiYWNrID0gZnVuY3Rpb24gdHJhbnNpdGlvbkVuZENhbGxiYWNrKCkge1xuXHQgICAgICAgICAgICAgICAgdHJhbnNsYXRlKHNsaWRlc1tpbmRleF0ub2Zmc2V0TGVmdCAqIC0xLCAwLCB1bmRlZmluZWQpO1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgIH1cblx0XG5cdCAgICAgICAgaWYgKGNsYXNzTmFtZUFjdGl2ZVNsaWRlKSB7XG5cdCAgICAgICAgICAgIHNldEFjdGl2ZUVsZW1lbnQoc2xpY2UuY2FsbChzbGlkZXMpLCBpbmRleCk7XG5cdCAgICAgICAgfVxuXHRcblx0ICAgICAgICBkaXNwYXRjaFNsaWRlckV2ZW50KCdhZnRlcicsICdzbGlkZScsIHtcblx0ICAgICAgICAgICAgY3VycmVudFNsaWRlOiBpbmRleFxuXHQgICAgICAgIH0pO1xuXHQgICAgfVxuXHRcblx0ICAgIC8qKlxuXHQgICAgICogcHVibGljXG5cdCAgICAgKiBzZXR1cCBmdW5jdGlvblxuXHQgICAgICovXG5cdCAgICBmdW5jdGlvbiBzZXR1cCgpIHtcblx0ICAgICAgICBkaXNwYXRjaFNsaWRlckV2ZW50KCdiZWZvcmUnLCAnaW5pdCcpO1xuXHRcblx0ICAgICAgICBwcmVmaXhlcyA9ICgwLCBfZGV0ZWN0UHJlZml4ZXMyLmRlZmF1bHQpKCk7XG5cdCAgICAgICAgb3B0aW9ucyA9IF9leHRlbmRzKHt9LCBfZGVmYXVsdHMyLmRlZmF1bHQsIG9wdHMpO1xuXHRcblx0ICAgICAgICB2YXIgX29wdGlvbnM0ID0gb3B0aW9ucztcblx0ICAgICAgICB2YXIgY2xhc3NOYW1lRnJhbWUgPSBfb3B0aW9uczQuY2xhc3NOYW1lRnJhbWU7XG5cdCAgICAgICAgdmFyIGNsYXNzTmFtZVNsaWRlQ29udGFpbmVyID0gX29wdGlvbnM0LmNsYXNzTmFtZVNsaWRlQ29udGFpbmVyO1xuXHQgICAgICAgIHZhciBjbGFzc05hbWVQcmV2Q3RybCA9IF9vcHRpb25zNC5jbGFzc05hbWVQcmV2Q3RybDtcblx0ICAgICAgICB2YXIgY2xhc3NOYW1lTmV4dEN0cmwgPSBfb3B0aW9uczQuY2xhc3NOYW1lTmV4dEN0cmw7XG5cdCAgICAgICAgdmFyIGVuYWJsZU1vdXNlRXZlbnRzID0gX29wdGlvbnM0LmVuYWJsZU1vdXNlRXZlbnRzO1xuXHQgICAgICAgIHZhciBjbGFzc05hbWVBY3RpdmVTbGlkZSA9IF9vcHRpb25zNC5jbGFzc05hbWVBY3RpdmVTbGlkZTtcblx0XG5cdFxuXHQgICAgICAgIGZyYW1lID0gc2xpZGVyLmdldEVsZW1lbnRzQnlDbGFzc05hbWUoY2xhc3NOYW1lRnJhbWUpWzBdO1xuXHQgICAgICAgIHNsaWRlQ29udGFpbmVyID0gZnJhbWUuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShjbGFzc05hbWVTbGlkZUNvbnRhaW5lcilbMF07XG5cdCAgICAgICAgcHJldkN0cmwgPSBzbGlkZXIuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShjbGFzc05hbWVQcmV2Q3RybClbMF07XG5cdCAgICAgICAgbmV4dEN0cmwgPSBzbGlkZXIuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShjbGFzc05hbWVOZXh0Q3RybClbMF07XG5cdFxuXHQgICAgICAgIHBvc2l0aW9uID0ge1xuXHQgICAgICAgICAgICB4OiBzbGlkZUNvbnRhaW5lci5vZmZzZXRMZWZ0LFxuXHQgICAgICAgICAgICB5OiBzbGlkZUNvbnRhaW5lci5vZmZzZXRUb3Bcblx0ICAgICAgICB9O1xuXHRcblx0ICAgICAgICBpZiAob3B0aW9ucy5pbmZpbml0ZSkge1xuXHQgICAgICAgICAgICBzbGlkZXMgPSBzZXR1cEluZmluaXRlKHNsaWNlLmNhbGwoc2xpZGVDb250YWluZXIuY2hpbGRyZW4pKTtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICBzbGlkZXMgPSBzbGljZS5jYWxsKHNsaWRlQ29udGFpbmVyLmNoaWxkcmVuKTtcblx0ICAgICAgICB9XG5cdFxuXHQgICAgICAgIHJlc2V0KCk7XG5cdFxuXHQgICAgICAgIGlmIChjbGFzc05hbWVBY3RpdmVTbGlkZSkge1xuXHQgICAgICAgICAgICBzZXRBY3RpdmVFbGVtZW50KHNsaWRlcywgaW5kZXgpO1xuXHQgICAgICAgIH1cblx0XG5cdCAgICAgICAgaWYgKHByZXZDdHJsICYmIG5leHRDdHJsKSB7XG5cdCAgICAgICAgICAgIHByZXZDdHJsLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgcHJldik7XG5cdCAgICAgICAgICAgIG5leHRDdHJsLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgbmV4dCk7XG5cdCAgICAgICAgfVxuXHRcblx0ICAgICAgICBmcmFtZS5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0Jywgb25Ub3VjaHN0YXJ0KTtcblx0XG5cdCAgICAgICAgaWYgKGVuYWJsZU1vdXNlRXZlbnRzKSB7XG5cdCAgICAgICAgICAgIGZyYW1lLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIG9uVG91Y2hzdGFydCk7XG5cdCAgICAgICAgICAgIGZyYW1lLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgb25DbGljayk7XG5cdCAgICAgICAgfVxuXHRcblx0ICAgICAgICBvcHRpb25zLndpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBvblJlc2l6ZSk7XG5cdFxuXHQgICAgICAgIGRpc3BhdGNoU2xpZGVyRXZlbnQoJ2FmdGVyJywgJ2luaXQnKTtcblx0ICAgIH1cblx0XG5cdCAgICAvKipcblx0ICAgICAqIHB1YmxpY1xuXHQgICAgICogcmVzZXQgZnVuY3Rpb246IGNhbGxlZCBvbiByZXNpemVcblx0ICAgICAqL1xuXHQgICAgZnVuY3Rpb24gcmVzZXQoKSB7XG5cdCAgICAgICAgdmFyIF9vcHRpb25zNSA9IG9wdGlvbnM7XG5cdCAgICAgICAgdmFyIGluZmluaXRlID0gX29wdGlvbnM1LmluZmluaXRlO1xuXHQgICAgICAgIHZhciBlYXNlID0gX29wdGlvbnM1LmVhc2U7XG5cdCAgICAgICAgdmFyIHJld2luZFNwZWVkID0gX29wdGlvbnM1LnJld2luZFNwZWVkO1xuXHQgICAgICAgIHZhciByZXdpbmRPblJlc2l6ZSA9IF9vcHRpb25zNS5yZXdpbmRPblJlc2l6ZTtcblx0ICAgICAgICB2YXIgY2xhc3NOYW1lQWN0aXZlU2xpZGUgPSBfb3B0aW9uczUuY2xhc3NOYW1lQWN0aXZlU2xpZGU7XG5cdFxuXHRcblx0ICAgICAgICBzbGlkZXNXaWR0aCA9IHNsaWRlQ29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoIHx8IHNsaWRlQ29udGFpbmVyLm9mZnNldFdpZHRoO1xuXHQgICAgICAgIGZyYW1lV2lkdGggPSBmcmFtZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aCB8fCBmcmFtZS5vZmZzZXRXaWR0aDtcblx0XG5cdCAgICAgICAgaWYgKGZyYW1lV2lkdGggPT09IHNsaWRlc1dpZHRoKSB7XG5cdCAgICAgICAgICAgIHNsaWRlc1dpZHRoID0gc2xpZGVzLnJlZHVjZShmdW5jdGlvbiAocHJldmlvdXNWYWx1ZSwgc2xpZGUpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBwcmV2aW91c1ZhbHVlICsgc2xpZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGggfHwgc2xpZGUub2Zmc2V0V2lkdGg7XG5cdCAgICAgICAgICAgIH0sIDApO1xuXHQgICAgICAgIH1cblx0XG5cdCAgICAgICAgaWYgKHJld2luZE9uUmVzaXplKSB7XG5cdCAgICAgICAgICAgIGluZGV4ID0gMDtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICBlYXNlID0gbnVsbDtcblx0ICAgICAgICAgICAgcmV3aW5kU3BlZWQgPSAwO1xuXHQgICAgICAgIH1cblx0XG5cdCAgICAgICAgaWYgKGluZmluaXRlKSB7XG5cdCAgICAgICAgICAgIHRyYW5zbGF0ZShzbGlkZXNbaW5kZXggKyBpbmZpbml0ZV0ub2Zmc2V0TGVmdCAqIC0xLCAwLCBudWxsKTtcblx0XG5cdCAgICAgICAgICAgIGluZGV4ID0gaW5kZXggKyBpbmZpbml0ZTtcblx0ICAgICAgICAgICAgcG9zaXRpb24ueCA9IHNsaWRlc1tpbmRleF0ub2Zmc2V0TGVmdCAqIC0xO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIHRyYW5zbGF0ZShzbGlkZXNbaW5kZXhdLm9mZnNldExlZnQgKiAtMSwgcmV3aW5kU3BlZWQsIGVhc2UpO1xuXHQgICAgICAgICAgICBwb3NpdGlvbi54ID0gc2xpZGVzW2luZGV4XS5vZmZzZXRMZWZ0ICogLTE7XG5cdCAgICAgICAgfVxuXHRcblx0ICAgICAgICBpZiAoY2xhc3NOYW1lQWN0aXZlU2xpZGUpIHtcblx0ICAgICAgICAgICAgc2V0QWN0aXZlRWxlbWVudChzbGljZS5jYWxsKHNsaWRlcyksIGluZGV4KTtcblx0ICAgICAgICB9XG5cdCAgICB9XG5cdFxuXHQgICAgLyoqXG5cdCAgICAgKiBwdWJsaWNcblx0ICAgICAqIHNsaWRlVG86IGNhbGxlZCBvbiBjbGlja2hhbmRsZXJcblx0ICAgICAqL1xuXHQgICAgZnVuY3Rpb24gc2xpZGVUbyhpbmRleCkge1xuXHQgICAgICAgIHNsaWRlKGluZGV4KTtcblx0ICAgIH1cblx0XG5cdCAgICAvKipcblx0ICAgICAqIHB1YmxpY1xuXHQgICAgICogcmV0dXJuSW5kZXggZnVuY3Rpb246IGNhbGxlZCBvbiBjbGlja2hhbmRsZXJcblx0ICAgICAqL1xuXHQgICAgZnVuY3Rpb24gcmV0dXJuSW5kZXgoKSB7XG5cdCAgICAgICAgcmV0dXJuIGluZGV4IC0gb3B0aW9ucy5pbmZpbml0ZSB8fCAwO1xuXHQgICAgfVxuXHRcblx0ICAgIC8qKlxuXHQgICAgICogcHVibGljXG5cdCAgICAgKiBwcmV2IGZ1bmN0aW9uOiBjYWxsZWQgb24gY2xpY2toYW5kbGVyXG5cdCAgICAgKi9cblx0ICAgIGZ1bmN0aW9uIHByZXYoKSB7XG5cdCAgICAgICAgc2xpZGUoZmFsc2UsIGZhbHNlKTtcblx0ICAgIH1cblx0XG5cdCAgICAvKipcblx0ICAgICAqIHB1YmxpY1xuXHQgICAgICogbmV4dCBmdW5jdGlvbjogY2FsbGVkIG9uIGNsaWNraGFuZGxlclxuXHQgICAgICovXG5cdCAgICBmdW5jdGlvbiBuZXh0KCkge1xuXHQgICAgICAgIHNsaWRlKGZhbHNlLCB0cnVlKTtcblx0ICAgIH1cblx0XG5cdCAgICAvKipcblx0ICAgICAqIHB1YmxpY1xuXHQgICAgICogZGVzdHJveSBmdW5jdGlvbjogY2FsbGVkIHRvIGdyYWNlZnVsbHkgZGVzdHJveSB0aGUgbG9yeSBpbnN0YW5jZVxuXHQgICAgICovXG5cdCAgICBmdW5jdGlvbiBkZXN0cm95KCkge1xuXHQgICAgICAgIGRpc3BhdGNoU2xpZGVyRXZlbnQoJ2JlZm9yZScsICdkZXN0cm95Jyk7XG5cdFxuXHQgICAgICAgIC8vIHJlbW92ZSBldmVudCBsaXN0ZW5lcnNcblx0ICAgICAgICBmcmFtZS5yZW1vdmVFdmVudExpc3RlbmVyKHByZWZpeGVzLnRyYW5zaXRpb25FbmQsIG9uVHJhbnNpdGlvbkVuZCk7XG5cdCAgICAgICAgZnJhbWUucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIG9uVG91Y2hzdGFydCk7XG5cdCAgICAgICAgZnJhbWUucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgb25Ub3VjaG1vdmUpO1xuXHQgICAgICAgIGZyYW1lLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgb25Ub3VjaGVuZCk7XG5cdCAgICAgICAgZnJhbWUucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgb25Ub3VjaG1vdmUpO1xuXHQgICAgICAgIGZyYW1lLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIG9uVG91Y2hzdGFydCk7XG5cdCAgICAgICAgZnJhbWUucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIG9uVG91Y2hlbmQpO1xuXHQgICAgICAgIGZyYW1lLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbGVhdmUnLCBvblRvdWNoZW5kKTtcblx0ICAgICAgICBmcmFtZS5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIG9uQ2xpY2spO1xuXHRcblx0ICAgICAgICBvcHRpb25zLndpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCBvblJlc2l6ZSk7XG5cdFxuXHQgICAgICAgIGlmIChwcmV2Q3RybCkge1xuXHQgICAgICAgICAgICBwcmV2Q3RybC5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHByZXYpO1xuXHQgICAgICAgIH1cblx0XG5cdCAgICAgICAgaWYgKG5leHRDdHJsKSB7XG5cdCAgICAgICAgICAgIG5leHRDdHJsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgbmV4dCk7XG5cdCAgICAgICAgfVxuXHRcblx0ICAgICAgICAvLyByZW1vdmUgY2xvbmVkIHNsaWRlcyBpZiBpbmZpbml0ZSBpcyBzZXRcblx0ICAgICAgICBpZiAob3B0aW9ucy5pbmZpbml0ZSkge1xuXHQgICAgICAgICAgICBBcnJheS5hcHBseShudWxsLCBBcnJheShvcHRpb25zLmluZmluaXRlKSkuZm9yRWFjaChmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgICAgICBzbGlkZUNvbnRhaW5lci5yZW1vdmVDaGlsZChzbGlkZUNvbnRhaW5lci5maXJzdENoaWxkKTtcblx0ICAgICAgICAgICAgICAgIHNsaWRlQ29udGFpbmVyLnJlbW92ZUNoaWxkKHNsaWRlQ29udGFpbmVyLmxhc3RDaGlsZCk7XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH1cblx0XG5cdCAgICAgICAgZGlzcGF0Y2hTbGlkZXJFdmVudCgnYWZ0ZXInLCAnZGVzdHJveScpO1xuXHQgICAgfVxuXHRcblx0ICAgIC8vIGV2ZW50IGhhbmRsaW5nXG5cdFxuXHQgICAgdmFyIHRvdWNoT2Zmc2V0ID0gdm9pZCAwO1xuXHQgICAgdmFyIGRlbHRhID0gdm9pZCAwO1xuXHQgICAgdmFyIGlzU2Nyb2xsaW5nID0gdm9pZCAwO1xuXHRcblx0ICAgIGZ1bmN0aW9uIG9uVHJhbnNpdGlvbkVuZCgpIHtcblx0ICAgICAgICBpZiAodHJhbnNpdGlvbkVuZENhbGxiYWNrKSB7XG5cdCAgICAgICAgICAgIHRyYW5zaXRpb25FbmRDYWxsYmFjaygpO1xuXHRcblx0ICAgICAgICAgICAgdHJhbnNpdGlvbkVuZENhbGxiYWNrID0gdW5kZWZpbmVkO1xuXHQgICAgICAgIH1cblx0ICAgIH1cblx0XG5cdCAgICBmdW5jdGlvbiBvblRvdWNoc3RhcnQoZXZlbnQpIHtcblx0ICAgICAgICB2YXIgX29wdGlvbnM2ID0gb3B0aW9ucztcblx0ICAgICAgICB2YXIgZW5hYmxlTW91c2VFdmVudHMgPSBfb3B0aW9uczYuZW5hYmxlTW91c2VFdmVudHM7XG5cdFxuXHQgICAgICAgIHZhciB0b3VjaGVzID0gZXZlbnQudG91Y2hlcyA/IGV2ZW50LnRvdWNoZXNbMF0gOiBldmVudDtcblx0XG5cdCAgICAgICAgaWYgKGVuYWJsZU1vdXNlRXZlbnRzKSB7XG5cdCAgICAgICAgICAgIGZyYW1lLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIG9uVG91Y2htb3ZlKTtcblx0ICAgICAgICAgICAgZnJhbWUuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIG9uVG91Y2hlbmQpO1xuXHQgICAgICAgICAgICBmcmFtZS5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWxlYXZlJywgb25Ub3VjaGVuZCk7XG5cdCAgICAgICAgfVxuXHRcblx0ICAgICAgICBmcmFtZS5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCBvblRvdWNobW92ZSk7XG5cdCAgICAgICAgZnJhbWUuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCBvblRvdWNoZW5kKTtcblx0XG5cdCAgICAgICAgdmFyIHBhZ2VYID0gdG91Y2hlcy5wYWdlWDtcblx0ICAgICAgICB2YXIgcGFnZVkgPSB0b3VjaGVzLnBhZ2VZO1xuXHRcblx0XG5cdCAgICAgICAgdG91Y2hPZmZzZXQgPSB7XG5cdCAgICAgICAgICAgIHg6IHBhZ2VYLFxuXHQgICAgICAgICAgICB5OiBwYWdlWSxcblx0ICAgICAgICAgICAgdGltZTogRGF0ZS5ub3coKVxuXHQgICAgICAgIH07XG5cdFxuXHQgICAgICAgIGlzU2Nyb2xsaW5nID0gdW5kZWZpbmVkO1xuXHRcblx0ICAgICAgICBkZWx0YSA9IHt9O1xuXHRcblx0ICAgICAgICBkaXNwYXRjaFNsaWRlckV2ZW50KCdvbicsICd0b3VjaHN0YXJ0Jywge1xuXHQgICAgICAgICAgICBldmVudDogZXZlbnRcblx0ICAgICAgICB9KTtcblx0ICAgIH1cblx0XG5cdCAgICBmdW5jdGlvbiBvblRvdWNobW92ZShldmVudCkge1xuXHQgICAgICAgIHZhciB0b3VjaGVzID0gZXZlbnQudG91Y2hlcyA/IGV2ZW50LnRvdWNoZXNbMF0gOiBldmVudDtcblx0ICAgICAgICB2YXIgcGFnZVggPSB0b3VjaGVzLnBhZ2VYO1xuXHQgICAgICAgIHZhciBwYWdlWSA9IHRvdWNoZXMucGFnZVk7XG5cdFxuXHRcblx0ICAgICAgICBkZWx0YSA9IHtcblx0ICAgICAgICAgICAgeDogcGFnZVggLSB0b3VjaE9mZnNldC54LFxuXHQgICAgICAgICAgICB5OiBwYWdlWSAtIHRvdWNoT2Zmc2V0Lnlcblx0ICAgICAgICB9O1xuXHRcblx0ICAgICAgICBpZiAodHlwZW9mIGlzU2Nyb2xsaW5nID09PSAndW5kZWZpbmVkJykge1xuXHQgICAgICAgICAgICBpc1Njcm9sbGluZyA9ICEhKGlzU2Nyb2xsaW5nIHx8IE1hdGguYWJzKGRlbHRhLngpIDwgTWF0aC5hYnMoZGVsdGEueSkpO1xuXHQgICAgICAgIH1cblx0XG5cdCAgICAgICAgaWYgKCFpc1Njcm9sbGluZyAmJiB0b3VjaE9mZnNldCkge1xuXHQgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHQgICAgICAgICAgICB0cmFuc2xhdGUocG9zaXRpb24ueCArIGRlbHRhLngsIDAsIG51bGwpO1xuXHQgICAgICAgIH1cblx0XG5cdCAgICAgICAgLy8gbWF5IGJlXG5cdCAgICAgICAgZGlzcGF0Y2hTbGlkZXJFdmVudCgnb24nLCAndG91Y2htb3ZlJywge1xuXHQgICAgICAgICAgICBldmVudDogZXZlbnRcblx0ICAgICAgICB9KTtcblx0ICAgIH1cblx0XG5cdCAgICBmdW5jdGlvbiBvblRvdWNoZW5kKGV2ZW50KSB7XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogdGltZSBiZXR3ZWVuIHRvdWNoc3RhcnQgYW5kIHRvdWNoZW5kIGluIG1pbGxpc2Vjb25kc1xuXHQgICAgICAgICAqIEBkdXJhdGlvbiB7bnVtYmVyfVxuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHZhciBkdXJhdGlvbiA9IHRvdWNoT2Zmc2V0ID8gRGF0ZS5ub3coKSAtIHRvdWNoT2Zmc2V0LnRpbWUgOiB1bmRlZmluZWQ7XG5cdFxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIGlzIHZhbGlkIGlmOlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogLT4gc3dpcGUgYXR0ZW1wdCB0aW1lIGlzIG92ZXIgMzAwIG1zXG5cdCAgICAgICAgICogYW5kXG5cdCAgICAgICAgICogLT4gc3dpcGUgZGlzdGFuY2UgaXMgZ3JlYXRlciB0aGFuIDI1cHhcblx0ICAgICAgICAgKiBvclxuXHQgICAgICAgICAqIC0+IHN3aXBlIGRpc3RhbmNlIGlzIG1vcmUgdGhlbiBhIHRoaXJkIG9mIHRoZSBzd2lwZSBhcmVhXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAaXNWYWxpZFNsaWRlIHtCb29sZWFufVxuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHZhciBpc1ZhbGlkID0gTnVtYmVyKGR1cmF0aW9uKSA8IDMwMCAmJiBNYXRoLmFicyhkZWx0YS54KSA+IDI1IHx8IE1hdGguYWJzKGRlbHRhLngpID4gZnJhbWVXaWR0aCAvIDM7XG5cdFxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIGlzIG91dCBvZiBib3VuZHMgaWY6XG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAtPiBpbmRleCBpcyAwIGFuZCBkZWx0YSB4IGlzIGdyZWF0ZXIgdGhhbiAwXG5cdCAgICAgICAgICogb3Jcblx0ICAgICAgICAgKiAtPiBpbmRleCBpcyB0aGUgbGFzdCBzbGlkZSBhbmQgZGVsdGEgaXMgc21hbGxlciB0aGFuIDBcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBpc091dE9mQm91bmRzIHtCb29sZWFufVxuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHZhciBpc091dE9mQm91bmRzID0gIWluZGV4ICYmIGRlbHRhLnggPiAwIHx8IGluZGV4ID09PSBzbGlkZXMubGVuZ3RoIC0gMSAmJiBkZWx0YS54IDwgMDtcblx0XG5cdCAgICAgICAgdmFyIGRpcmVjdGlvbiA9IGRlbHRhLnggPCAwO1xuXHRcblx0ICAgICAgICBpZiAoIWlzU2Nyb2xsaW5nKSB7XG5cdCAgICAgICAgICAgIGlmIChpc1ZhbGlkICYmICFpc091dE9mQm91bmRzKSB7XG5cdCAgICAgICAgICAgICAgICBzbGlkZShmYWxzZSwgZGlyZWN0aW9uKTtcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIHRyYW5zbGF0ZShwb3NpdGlvbi54LCBvcHRpb25zLnNuYXBCYWNrU3BlZWQpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHRcblx0ICAgICAgICB0b3VjaE9mZnNldCA9IHVuZGVmaW5lZDtcblx0XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogcmVtb3ZlIGV2ZW50bGlzdGVuZXJzIGFmdGVyIHN3aXBlIGF0dGVtcHRcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBmcmFtZS5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCBvblRvdWNobW92ZSk7XG5cdCAgICAgICAgZnJhbWUucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCBvblRvdWNoZW5kKTtcblx0ICAgICAgICBmcmFtZS5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBvblRvdWNobW92ZSk7XG5cdCAgICAgICAgZnJhbWUucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIG9uVG91Y2hlbmQpO1xuXHQgICAgICAgIGZyYW1lLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbGVhdmUnLCBvblRvdWNoZW5kKTtcblx0XG5cdCAgICAgICAgZGlzcGF0Y2hTbGlkZXJFdmVudCgnb24nLCAndG91Y2hlbmQnLCB7XG5cdCAgICAgICAgICAgIGV2ZW50OiBldmVudFxuXHQgICAgICAgIH0pO1xuXHQgICAgfVxuXHRcblx0ICAgIGZ1bmN0aW9uIG9uQ2xpY2soZXZlbnQpIHtcblx0ICAgICAgICBpZiAoZGVsdGEueCkge1xuXHQgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHQgICAgICAgIH1cblx0ICAgIH1cblx0XG5cdCAgICBmdW5jdGlvbiBvblJlc2l6ZShldmVudCkge1xuXHQgICAgICAgIHJlc2V0KCk7XG5cdFxuXHQgICAgICAgIGRpc3BhdGNoU2xpZGVyRXZlbnQoJ29uJywgJ3Jlc2l6ZScsIHtcblx0ICAgICAgICAgICAgZXZlbnQ6IGV2ZW50XG5cdCAgICAgICAgfSk7XG5cdCAgICB9XG5cdFxuXHQgICAgLy8gdHJpZ2dlciBpbml0aWFsIHNldHVwXG5cdCAgICBzZXR1cCgpO1xuXHRcblx0ICAgIC8vIGV4cG9zZSBwdWJsaWMgYXBpXG5cdCAgICByZXR1cm4ge1xuXHQgICAgICAgIHNldHVwOiBzZXR1cCxcblx0ICAgICAgICByZXNldDogcmVzZXQsXG5cdCAgICAgICAgc2xpZGVUbzogc2xpZGVUbyxcblx0ICAgICAgICByZXR1cm5JbmRleDogcmV0dXJuSW5kZXgsXG5cdCAgICAgICAgcHJldjogcHJldixcblx0ICAgICAgICBuZXh0OiBuZXh0LFxuXHQgICAgICAgIGRlc3Ryb3k6IGRlc3Ryb3lcblx0ICAgIH07XG5cdH1cblxuLyoqKi8gfSxcbi8qIDIgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdC8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqLyhmdW5jdGlvbihnbG9iYWwpIHsndXNlIHN0cmljdCc7XG5cdFxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcblx0ICAgIHZhbHVlOiB0cnVlXG5cdH0pO1xuXHRleHBvcnRzLmRlZmF1bHQgPSBkZXRlY3RQcmVmaXhlcztcblx0LyoqXG5cdCAqIERldGVjdGluZyBwcmVmaXhlcyBmb3Igc2F2aW5nIHRpbWUgYW5kIGJ5dGVzXG5cdCAqL1xuXHRmdW5jdGlvbiBkZXRlY3RQcmVmaXhlcygpIHtcblx0ICAgIHZhciB0cmFuc2Zvcm0gPSB2b2lkIDA7XG5cdCAgICB2YXIgdHJhbnNpdGlvbiA9IHZvaWQgMDtcblx0ICAgIHZhciB0cmFuc2l0aW9uRW5kID0gdm9pZCAwO1xuXHQgICAgdmFyIGhhc1RyYW5zbGF0ZTNkID0gdm9pZCAwO1xuXHRcblx0ICAgIChmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnXycpO1xuXHQgICAgICAgIHZhciBzdHlsZSA9IGVsLnN0eWxlO1xuXHRcblx0ICAgICAgICB2YXIgcHJvcCA9IHZvaWQgMDtcblx0XG5cdCAgICAgICAgaWYgKHN0eWxlW3Byb3AgPSAnd2Via2l0VHJhbnNpdGlvbiddID09PSAnJykge1xuXHQgICAgICAgICAgICB0cmFuc2l0aW9uRW5kID0gJ3dlYmtpdFRyYW5zaXRpb25FbmQnO1xuXHQgICAgICAgICAgICB0cmFuc2l0aW9uID0gcHJvcDtcblx0ICAgICAgICB9XG5cdFxuXHQgICAgICAgIGlmIChzdHlsZVtwcm9wID0gJ3RyYW5zaXRpb24nXSA9PT0gJycpIHtcblx0ICAgICAgICAgICAgdHJhbnNpdGlvbkVuZCA9ICd0cmFuc2l0aW9uZW5kJztcblx0ICAgICAgICAgICAgdHJhbnNpdGlvbiA9IHByb3A7XG5cdCAgICAgICAgfVxuXHRcblx0ICAgICAgICBpZiAoc3R5bGVbcHJvcCA9ICd3ZWJraXRUcmFuc2Zvcm0nXSA9PT0gJycpIHtcblx0ICAgICAgICAgICAgdHJhbnNmb3JtID0gcHJvcDtcblx0ICAgICAgICB9XG5cdFxuXHQgICAgICAgIGlmIChzdHlsZVtwcm9wID0gJ21zVHJhbnNmb3JtJ10gPT09ICcnKSB7XG5cdCAgICAgICAgICAgIHRyYW5zZm9ybSA9IHByb3A7XG5cdCAgICAgICAgfVxuXHRcblx0ICAgICAgICBpZiAoc3R5bGVbcHJvcCA9ICd0cmFuc2Zvcm0nXSA9PT0gJycpIHtcblx0ICAgICAgICAgICAgdHJhbnNmb3JtID0gcHJvcDtcblx0ICAgICAgICB9XG5cdFxuXHQgICAgICAgIGRvY3VtZW50LmJvZHkuaW5zZXJ0QmVmb3JlKGVsLCBudWxsKTtcblx0ICAgICAgICBzdHlsZVt0cmFuc2Zvcm1dID0gJ3RyYW5zbGF0ZTNkKDAsIDAsIDApJztcblx0ICAgICAgICBoYXNUcmFuc2xhdGUzZCA9ICEhZ2xvYmFsLmdldENvbXB1dGVkU3R5bGUoZWwpLmdldFByb3BlcnR5VmFsdWUodHJhbnNmb3JtKTtcblx0ICAgICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGVsKTtcblx0ICAgIH0pKCk7XG5cdFxuXHQgICAgcmV0dXJuIHtcblx0ICAgICAgICB0cmFuc2Zvcm06IHRyYW5zZm9ybSxcblx0ICAgICAgICB0cmFuc2l0aW9uOiB0cmFuc2l0aW9uLFxuXHQgICAgICAgIHRyYW5zaXRpb25FbmQ6IHRyYW5zaXRpb25FbmQsXG5cdCAgICAgICAgaGFzVHJhbnNsYXRlM2Q6IGhhc1RyYW5zbGF0ZTNkXG5cdCAgICB9O1xuXHR9XG5cdC8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqL30uY2FsbChleHBvcnRzLCAoZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KCkpKSlcblxuLyoqKi8gfSxcbi8qIDMgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdCd1c2Ugc3RyaWN0Jztcblx0XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuXHQgICAgdmFsdWU6IHRydWVcblx0fSk7XG5cdGV4cG9ydHMuZGVmYXVsdCA9IGRpc3BhdGNoRXZlbnQ7XG5cdFxuXHR2YXIgX2N1c3RvbUV2ZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcblx0XG5cdHZhciBfY3VzdG9tRXZlbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3VzdG9tRXZlbnQpO1xuXHRcblx0ZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblx0XG5cdC8qKlxuXHQgKiBkaXNwYXRjaCBjdXN0b20gZXZlbnRzXG5cdCAqXG5cdCAqIEBwYXJhbSAge2VsZW1lbnR9IGVsICAgICAgICAgc2xpZGVzaG93IGVsZW1lbnRcblx0ICogQHBhcmFtICB7c3RyaW5nfSAgdHlwZSAgICAgICBjdXN0b20gZXZlbnQgbmFtZVxuXHQgKiBAcGFyYW0gIHtvYmplY3R9ICBkZXRhaWwgICAgIGN1c3RvbSBkZXRhaWwgaW5mb3JtYXRpb25cblx0ICovXG5cdGZ1bmN0aW9uIGRpc3BhdGNoRXZlbnQodGFyZ2V0LCB0eXBlLCBkZXRhaWwpIHtcblx0ICAgIHZhciBldmVudCA9IG5ldyBfY3VzdG9tRXZlbnQyLmRlZmF1bHQodHlwZSwge1xuXHQgICAgICAgIGJ1YmJsZXM6IHRydWUsXG5cdCAgICAgICAgY2FuY2VsYWJsZTogdHJ1ZSxcblx0ICAgICAgICBkZXRhaWw6IGRldGFpbFxuXHQgICAgfSk7XG5cdFxuXHQgICAgdGFyZ2V0LmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuXHR9XG5cbi8qKiovIH0sXG4vKiA0ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHQvKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi8oZnVuY3Rpb24oZ2xvYmFsKSB7XG5cdHZhciBOYXRpdmVDdXN0b21FdmVudCA9IGdsb2JhbC5DdXN0b21FdmVudDtcblx0XG5cdGZ1bmN0aW9uIHVzZU5hdGl2ZSAoKSB7XG5cdCAgdHJ5IHtcblx0ICAgIHZhciBwID0gbmV3IE5hdGl2ZUN1c3RvbUV2ZW50KCdjYXQnLCB7IGRldGFpbDogeyBmb286ICdiYXInIH0gfSk7XG5cdCAgICByZXR1cm4gICdjYXQnID09PSBwLnR5cGUgJiYgJ2JhcicgPT09IHAuZGV0YWlsLmZvbztcblx0ICB9IGNhdGNoIChlKSB7XG5cdCAgfVxuXHQgIHJldHVybiBmYWxzZTtcblx0fVxuXHRcblx0LyoqXG5cdCAqIENyb3NzLWJyb3dzZXIgYEN1c3RvbUV2ZW50YCBjb25zdHJ1Y3Rvci5cblx0ICpcblx0ICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0N1c3RvbUV2ZW50LkN1c3RvbUV2ZW50XG5cdCAqXG5cdCAqIEBwdWJsaWNcblx0ICovXG5cdFxuXHRtb2R1bGUuZXhwb3J0cyA9IHVzZU5hdGl2ZSgpID8gTmF0aXZlQ3VzdG9tRXZlbnQgOlxuXHRcblx0Ly8gSUUgPj0gOVxuXHQnZnVuY3Rpb24nID09PSB0eXBlb2YgZG9jdW1lbnQuY3JlYXRlRXZlbnQgPyBmdW5jdGlvbiBDdXN0b21FdmVudCAodHlwZSwgcGFyYW1zKSB7XG5cdCAgdmFyIGUgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnQ3VzdG9tRXZlbnQnKTtcblx0ICBpZiAocGFyYW1zKSB7XG5cdCAgICBlLmluaXRDdXN0b21FdmVudCh0eXBlLCBwYXJhbXMuYnViYmxlcywgcGFyYW1zLmNhbmNlbGFibGUsIHBhcmFtcy5kZXRhaWwpO1xuXHQgIH0gZWxzZSB7XG5cdCAgICBlLmluaXRDdXN0b21FdmVudCh0eXBlLCBmYWxzZSwgZmFsc2UsIHZvaWQgMCk7XG5cdCAgfVxuXHQgIHJldHVybiBlO1xuXHR9IDpcblx0XG5cdC8vIElFIDw9IDhcblx0ZnVuY3Rpb24gQ3VzdG9tRXZlbnQgKHR5cGUsIHBhcmFtcykge1xuXHQgIHZhciBlID0gZG9jdW1lbnQuY3JlYXRlRXZlbnRPYmplY3QoKTtcblx0ICBlLnR5cGUgPSB0eXBlO1xuXHQgIGlmIChwYXJhbXMpIHtcblx0ICAgIGUuYnViYmxlcyA9IEJvb2xlYW4ocGFyYW1zLmJ1YmJsZXMpO1xuXHQgICAgZS5jYW5jZWxhYmxlID0gQm9vbGVhbihwYXJhbXMuY2FuY2VsYWJsZSk7XG5cdCAgICBlLmRldGFpbCA9IHBhcmFtcy5kZXRhaWw7XG5cdCAgfSBlbHNlIHtcblx0ICAgIGUuYnViYmxlcyA9IGZhbHNlO1xuXHQgICAgZS5jYW5jZWxhYmxlID0gZmFsc2U7XG5cdCAgICBlLmRldGFpbCA9IHZvaWQgMDtcblx0ICB9XG5cdCAgcmV0dXJuIGU7XG5cdH1cblx0XG5cdC8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqL30uY2FsbChleHBvcnRzLCAoZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KCkpKSlcblxuLyoqKi8gfSxcbi8qIDUgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdCd1c2Ugc3RyaWN0Jztcblx0XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuXHQgIHZhbHVlOiB0cnVlXG5cdH0pO1xuXHRleHBvcnRzLmRlZmF1bHQgPSB7XG5cdCAgLyoqXG5cdCAgICogc2xpZGVzIHNjcm9sbGVkIGF0IG9uY2Vcblx0ICAgKiBAc2xpZGVzVG9TY3JvbGwge051bWJlcn1cblx0ICAgKi9cblx0ICBzbGlkZXNUb1Njcm9sbDogMSxcblx0XG5cdCAgLyoqXG5cdCAgICogdGltZSBpbiBtaWxsaXNlY29uZHMgZm9yIHRoZSBhbmltYXRpb24gb2YgYSB2YWxpZCBzbGlkZSBhdHRlbXB0XG5cdCAgICogQHNsaWRlU3BlZWQge051bWJlcn1cblx0ICAgKi9cblx0ICBzbGlkZVNwZWVkOiAzMDAsXG5cdFxuXHQgIC8qKlxuXHQgICAqIHRpbWUgaW4gbWlsbGlzZWNvbmRzIGZvciB0aGUgYW5pbWF0aW9uIG9mIHRoZSByZXdpbmQgYWZ0ZXIgdGhlIGxhc3Qgc2xpZGVcblx0ICAgKiBAcmV3aW5kU3BlZWQge051bWJlcn1cblx0ICAgKi9cblx0ICByZXdpbmRTcGVlZDogNjAwLFxuXHRcblx0ICAvKipcblx0ICAgKiB0aW1lIGZvciB0aGUgc25hcEJhY2sgb2YgdGhlIHNsaWRlciBpZiB0aGUgc2xpZGUgYXR0ZW1wdCB3YXMgbm90IHZhbGlkXG5cdCAgICogQHNuYXBCYWNrU3BlZWQge051bWJlcn1cblx0ICAgKi9cblx0ICBzbmFwQmFja1NwZWVkOiAyMDAsXG5cdFxuXHQgIC8qKlxuXHQgICAqIEJhc2ljIGVhc2luZyBmdW5jdGlvbnM6IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RlL2RvY3MvV2ViL0NTUy90cmFuc2l0aW9uLXRpbWluZy1mdW5jdGlvblxuXHQgICAqIGN1YmljIGJlemllciBlYXNpbmcgZnVuY3Rpb25zOiBodHRwOi8vZWFzaW5ncy5uZXQvZGVcblx0ICAgKiBAZWFzZSB7U3RyaW5nfVxuXHQgICAqL1xuXHQgIGVhc2U6ICdlYXNlJyxcblx0XG5cdCAgLyoqXG5cdCAgICogaWYgc2xpZGVyIHJlYWNoZWQgdGhlIGxhc3Qgc2xpZGUsIHdpdGggbmV4dCBjbGljayB0aGUgc2xpZGVyIGdvZXMgYmFjayB0byB0aGUgc3RhcnRpbmRleC5cblx0ICAgKiB1c2UgaW5maW5pdGUgb3IgcmV3aW5kLCBub3QgYm90aFxuXHQgICAqIEByZXdpbmQge0Jvb2xlYW59XG5cdCAgICovXG5cdCAgcmV3aW5kOiBmYWxzZSxcblx0XG5cdCAgLyoqXG5cdCAgICogbnVtYmVyIG9mIHZpc2libGUgc2xpZGVzIG9yIGZhbHNlXG5cdCAgICogdXNlIGluZmluaXRlIG9yIHJld2luZCwgbm90IGJvdGhcblx0ICAgKiBAaW5maW5pdGUge251bWJlcn1cblx0ICAgKi9cblx0ICBpbmZpbml0ZTogZmFsc2UsXG5cdFxuXHQgIC8qKlxuXHQgICAqIGNsYXNzIG5hbWUgZm9yIHNsaWRlciBmcmFtZVxuXHQgICAqIEBjbGFzc05hbWVGcmFtZSB7c3RyaW5nfVxuXHQgICAqL1xuXHQgIGNsYXNzTmFtZUZyYW1lOiAnanNfZnJhbWUnLFxuXHRcblx0ICAvKipcblx0ICAgKiBjbGFzcyBuYW1lIGZvciBzbGlkZXMgY29udGFpbmVyXG5cdCAgICogQGNsYXNzTmFtZVNsaWRlQ29udGFpbmVyIHtzdHJpbmd9XG5cdCAgICovXG5cdCAgY2xhc3NOYW1lU2xpZGVDb250YWluZXI6ICdqc19zbGlkZXMnLFxuXHRcblx0ICAvKipcblx0ICAgKiBjbGFzcyBuYW1lIGZvciBzbGlkZXIgcHJldiBjb250cm9sXG5cdCAgICogQGNsYXNzTmFtZVByZXZDdHJsIHtzdHJpbmd9XG5cdCAgICovXG5cdCAgY2xhc3NOYW1lUHJldkN0cmw6ICdqc19wcmV2Jyxcblx0XG5cdCAgLyoqXG5cdCAgICogY2xhc3MgbmFtZSBmb3Igc2xpZGVyIG5leHQgY29udHJvbFxuXHQgICAqIEBjbGFzc05hbWVOZXh0Q3RybCB7c3RyaW5nfVxuXHQgICAqL1xuXHQgIGNsYXNzTmFtZU5leHRDdHJsOiAnanNfbmV4dCcsXG5cdFxuXHQgIC8qKlxuXHQgICAqIGNsYXNzIG5hbWUgZm9yIGN1cnJlbnQgYWN0aXZlIHNsaWRlXG5cdCAgICogaWYgZW1wdHlTdHJpbmcgdGhlbiBubyBjbGFzcyBpcyBzZXRcblx0ICAgKiBAY2xhc3NOYW1lQWN0aXZlU2xpZGUge3N0cmluZ31cblx0ICAgKi9cblx0ICBjbGFzc05hbWVBY3RpdmVTbGlkZTogJ2FjdGl2ZScsXG5cdFxuXHQgIC8qKlxuXHQgICAqIGVuYWJsZXMgbW91c2UgZXZlbnRzIGZvciBzd2lwaW5nIG9uIGRlc2t0b3AgZGV2aWNlc1xuXHQgICAqIEBlbmFibGVNb3VzZUV2ZW50cyB7Ym9vbGVhbn1cblx0ICAgKi9cblx0ICBlbmFibGVNb3VzZUV2ZW50czogZmFsc2UsXG5cdFxuXHQgIC8qKlxuXHQgICAqIHdpbmRvdyBpbnN0YW5jZVxuXHQgICAqIEB3aW5kb3cge29iamVjdH1cblx0ICAgKi9cblx0ICB3aW5kb3c6IHdpbmRvdyxcblx0XG5cdCAgLyoqXG5cdCAgICogSWYgZmFsc2UsIHNsaWRlcyBsb3J5IHRvIHRoZSBmaXJzdCBzbGlkZSBvbiB3aW5kb3cgcmVzaXplLlxuXHQgICAqIEByZXdpbmRPblJlc2l6ZSB7Ym9vbGVhbn1cblx0ICAgKi9cblx0ICByZXdpbmRPblJlc2l6ZTogdHJ1ZVxuXHR9O1xuXG4vKioqLyB9XG4vKioqKioqLyBdKVxufSk7XG47XG4vLyBodHRwczovL2dpdGh1Yi5jb20vbGV3aXNjb2xsYXJkL2hvcnNlcG93ZXIvYmxvYi8yOWQ0MDY4NzdkNzQ3MDVjNjFmMjdjYzY1NmE5NWVjZmRlODZiOTg3L2Fzc2V0cy9qcy81MC1jYXJvdXNlbC5qc1xuICAgIGZ1bmN0aW9uIG1ha2VDYXJvdXNlbChzZWxlY3Rvcikge1xuICAgICAgICB2YXIgc2ltcGxlID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihzZWxlY3Rvcik7XG4gICAgICAgIGlmICghc2ltcGxlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxvcnlDYXJvdXNlbCA9IGxvcnkoc2ltcGxlLCB7XG4gICAgICAgICAgICBpbmZpbml0ZTogMSxcbiAgICAgICAgICAgIGVuYWJsZU1vdXNlRXZlbnRzOiB0cnVlLFxuICAgICAgICAgICAgY2xhc3NOYW1lUHJldkN0cmw6J3NsaWRlcl9fcHJldicsXG4gICAgICAgICAgICBjbGFzc05hbWVOZXh0Q3RybDonc2xpZGVyX19uZXh0JyxcbiAgICAgICAgICAgIGNsYXNzTmFtZVNsaWRlQ29udGFpbmVyOiAnc2xpZGVyX19zbGlkZXMnLFxuICAgICAgICAgICAgY2xhc3NOYW1lRnJhbWU6ICdzbGlkZXJfX2ZyYW1lJyxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gQXV0b3BsYXlcbiAgICAgICAgdmFyIHRpbWVyID0gd2luZG93LnNldEludGVydmFsKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGxvcnlDYXJvdXNlbC5uZXh0KCk7XG4gICAgICAgIH0sIDUwMDApO1xuXG4gICAgICAgIGZ1bmN0aW9uIGNhbmNlbFRpbWVyKCkge1xuICAgICAgICAgICAgd2luZG93LmNsZWFySW50ZXJ2YWwodGltZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgc2ltcGxlLnF1ZXJ5U2VsZWN0b3IoJy5zbGlkZXJfX25leHQnKS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGNhbmNlbFRpbWVyKTtcbiAgICAgICAgc2ltcGxlLnF1ZXJ5U2VsZWN0b3IoJy5zbGlkZXJfX3ByZXYnKS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGNhbmNlbFRpbWVyKTtcbiAgICAgICAgc2ltcGxlLmFkZEV2ZW50TGlzdGVuZXIoJ29uLmxvcnkudG91Y2hzdGFydCcsIGNhbmNlbFRpbWVyKTtcbiAgICB9XG5cbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICBtYWtlQ2Fyb3VzZWwoJy5qc19zaW1wbGUnKTtcbiAgICB9KTsiXSwiZmlsZSI6Im1haW4ubWluLmpzIiwic291cmNlUm9vdCI6Ii9zb3VyY2UvIn0=
