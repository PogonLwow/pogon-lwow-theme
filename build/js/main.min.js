jQuery(function($) {

       function cardExcerpt() {
        $(".card__excerpt").text(function(index, currentText) {
          return currentText.substr(0, 125) + '\u2026';
        });
      }
      cardExcerpt();
      function featuredTitle() {
       $(".featured__title").text(function(index, currentText) {
         return currentText.substr(0, 75) + '\u2026';
       });
     }
     featuredTitle();

    $(document).ready(function() {
        
        (function () {
            $('.sportspress style').remove();
            $('.gallery-item a').addClass('link');
        })();

            // $("#nav-mobile").html($("#nav-main").html());
            $("#nav-trigger .navicon-button").click(function() {
                console.info('Burger clicked');
                if ($(".topbar").hasClass("topbar--expanded")) {
                    $(".topbar").removeClass("topbar--expanded");
                    $(this).removeClass("open");
                } else {
                    $(".topbar").addClass("topbar--expanded");
                    $(this).addClass("open");
                }
            });

        
        var bLazy = new Blazy({
          offset: 20,
          selector: '.blazy',
          loadInvisible: false,
          breakpoints: [{
            width: 360, // Max-width
            src: 'data-src-small'
          }],
          success: function(element) {
            $(element).parent().removeClass('loading', 500);
            updateCounter();
          },
          error: function(element, msg) {
            if (msg === 'missing') {
              $(element).parent().removeClass('loading', 500); // Data-src is missing
              console.error("bLazy: data-src is missing");
            } else if (msg === 'invalid') {
              $(element).parent().removeClass('loading', 500);
              // Data-src is invalid
              console.error("bLazy: data-src is invalid");
        
            }
          }
        });
        // not needed, only here to illustrate amount of loaded images
        var imageLoaded = 0;
        
        function updateCounter() {
          imageLoaded++;
          console.info("bLazy: Images loaded: %d", imageLoaded);
        }
        
        // tabs(bLazy);

        (function() {
            var ajax_url = $('body').attr('data-ajax-url');
            var post_offset = 0;
            var incNumber = 6; // ilość postów do załadowania
        
            var projects = (function(setProjects) {
                var loaded;
                var total;
                return {
                    incLoaded: function() {
                        loaded = loaded + incNumber;
                    },
                    getLoaded: function() {
                        return loaded;
                    },
                    setLoaded: function(setProjects) {
                        loaded = setProjects;
                    },
                    setTotal: function(setProjects) {
                        total = setProjects;
                    },
                    getTotal: function() {
                        return total;
                    }
                };
            })();
            var loadingButton = (function(button){
                return {
                    showSpinner: function(button) {
                        button.html('Ładuję starsze...');
                    },
                    showCaption: function(button) {
                        button.html('Zobacz starsze');
                    },
                    hide: function(button) {
                        button.hide();
                    }
                };
            })();
        
            $('#load_more_posts').on('click', loadMore);
        
            function loadMore() {
                console.log('Clicked load_more');
                $(this).html('Ładuję...');
                post_offset = parseInt(post_offset) + 6;
                $.ajax({
                    url: ajax_url,
                    type: 'POST',
                    data: {
                        action: 'load_posts',
                        post_offset: post_offset,
                    },
                    success: function(data) {
                        $('#load_more_posts').html('Zobacz starsze');
                        $('#feed').append(data);
                        console.info('Ajax: OK');
                        bLazy.revalidate();
                        cardExcerpt();
                    }
                });
            }
        
        })();

    });
});

(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else {
		var a = factory();
		for(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];
	}
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(1);


/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; /* globals jQuery */
	
	exports.lory = lory;
	
	var _detectPrefixes = __webpack_require__(2);
	
	var _detectPrefixes2 = _interopRequireDefault(_detectPrefixes);
	
	var _dispatchEvent = __webpack_require__(3);
	
	var _dispatchEvent2 = _interopRequireDefault(_dispatchEvent);
	
	var _defaults = __webpack_require__(5);
	
	var _defaults2 = _interopRequireDefault(_defaults);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var slice = Array.prototype.slice;
	
	function lory(slider, opts) {
	    var position = void 0;
	    var slidesWidth = void 0;
	    var frameWidth = void 0;
	    var slides = void 0;
	
	    /**
	     * slider DOM elements
	     */
	    var frame = void 0;
	    var slideContainer = void 0;
	    var prevCtrl = void 0;
	    var nextCtrl = void 0;
	    var prefixes = void 0;
	    var transitionEndCallback = void 0;
	
	    var index = 0;
	    var options = {};
	
	    /**
	     * if object is jQuery convert to native DOM element
	     */
	    if (typeof jQuery !== 'undefined' && slider instanceof jQuery) {
	        slider = slider[0];
	    }
	
	    /**
	     * private
	     * set active class to element which is the current slide
	     */
	    function setActiveElement(slides, currentIndex) {
	        var _options = options;
	        var classNameActiveSlide = _options.classNameActiveSlide;
	
	
	        slides.forEach(function (element, index) {
	            if (element.classList.contains(classNameActiveSlide)) {
	                element.classList.remove(classNameActiveSlide);
	            }
	        });
	
	        slides[currentIndex].classList.add(classNameActiveSlide);
	    }
	
	    /**
	     * private
	     * setupInfinite: function to setup if infinite is set
	     *
	     * @param  {array} slideArray
	     * @return {array} array of updated slideContainer elements
	     */
	    function setupInfinite(slideArray) {
	        var _options2 = options;
	        var infinite = _options2.infinite;
	
	
	        var front = slideArray.slice(0, infinite);
	        var back = slideArray.slice(slideArray.length - infinite, slideArray.length);
	
	        front.forEach(function (element) {
	            var cloned = element.cloneNode(true);
	
	            slideContainer.appendChild(cloned);
	        });
	
	        back.reverse().forEach(function (element) {
	            var cloned = element.cloneNode(true);
	
	            slideContainer.insertBefore(cloned, slideContainer.firstChild);
	        });
	
	        slideContainer.addEventListener(prefixes.transitionEnd, onTransitionEnd);
	
	        return slice.call(slideContainer.children);
	    }
	
	    /**
	     * [dispatchSliderEvent description]
	     * @return {[type]} [description]
	     */
	    function dispatchSliderEvent(phase, type, detail) {
	        (0, _dispatchEvent2.default)(slider, phase + '.lory.' + type, detail);
	    }
	
	    /**
	     * translates to a given position in a given time in milliseconds
	     *
	     * @to        {number} number in pixels where to translate to
	     * @duration  {number} time in milliseconds for the transistion
	     * @ease      {string} easing css property
	     */
	    function translate(to, duration, ease) {
	        var style = slideContainer && slideContainer.style;
	
	        if (style) {
	            style[prefixes.transition + 'TimingFunction'] = ease;
	            style[prefixes.transition + 'Duration'] = duration + 'ms';
	
	            if (prefixes.hasTranslate3d) {
	                style[prefixes.transform] = 'translate3d(' + to + 'px, 0, 0)';
	            } else {
	                style[prefixes.transform] = 'translate(' + to + 'px, 0)';
	            }
	        }
	    }
	
	    /**
	     * slidefunction called by prev, next & touchend
	     *
	     * determine nextIndex and slide to next postion
	     * under restrictions of the defined options
	     *
	     * @direction  {boolean}
	     */
	    function slide(nextIndex, direction) {
	        var _options3 = options;
	        var slideSpeed = _options3.slideSpeed;
	        var slidesToScroll = _options3.slidesToScroll;
	        var infinite = _options3.infinite;
	        var rewind = _options3.rewind;
	        var rewindSpeed = _options3.rewindSpeed;
	        var ease = _options3.ease;
	        var classNameActiveSlide = _options3.classNameActiveSlide;
	
	
	        var duration = slideSpeed;
	
	        var nextSlide = direction ? index + 1 : index - 1;
	        var maxOffset = Math.round(slidesWidth - frameWidth);
	
	        dispatchSliderEvent('before', 'slide', {
	            index: index,
	            nextSlide: nextSlide
	        });
	
	        if (typeof nextIndex !== 'number') {
	            if (direction) {
	                nextIndex = index + slidesToScroll;
	            } else {
	                nextIndex = index - slidesToScroll;
	            }
	        }
	
	        nextIndex = Math.min(Math.max(nextIndex, 0), slides.length - 1);
	
	        if (infinite && direction === undefined) {
	            nextIndex += infinite;
	        }
	
	        var nextOffset = Math.min(Math.max(slides[nextIndex].offsetLeft * -1, maxOffset * -1), 0);
	
	        if (rewind && Math.abs(position.x) === maxOffset && direction) {
	            nextOffset = 0;
	            nextIndex = 0;
	            duration = rewindSpeed;
	        }
	
	        /**
	         * translate to the nextOffset by a defined duration and ease function
	         */
	        translate(nextOffset, duration, ease);
	
	        /**
	         * update the position with the next position
	         */
	        position.x = nextOffset;
	
	        /**
	         * update the index with the nextIndex only if
	         * the offset of the nextIndex is in the range of the maxOffset
	         */
	        if (slides[nextIndex].offsetLeft <= maxOffset) {
	            index = nextIndex;
	        }
	
	        if (infinite && (nextIndex === slides.length - infinite || nextIndex === 0)) {
	            if (direction) {
	                index = infinite;
	            }
	
	            if (!direction) {
	                index = slides.length - infinite * 2;
	            }
	
	            position.x = slides[index].offsetLeft * -1;
	
	            transitionEndCallback = function transitionEndCallback() {
	                translate(slides[index].offsetLeft * -1, 0, undefined);
	            };
	        }
	
	        if (classNameActiveSlide) {
	            setActiveElement(slice.call(slides), index);
	        }
	
	        dispatchSliderEvent('after', 'slide', {
	            currentSlide: index
	        });
	    }
	
	    /**
	     * public
	     * setup function
	     */
	    function setup() {
	        dispatchSliderEvent('before', 'init');
	
	        prefixes = (0, _detectPrefixes2.default)();
	        options = _extends({}, _defaults2.default, opts);
	
	        var _options4 = options;
	        var classNameFrame = _options4.classNameFrame;
	        var classNameSlideContainer = _options4.classNameSlideContainer;
	        var classNamePrevCtrl = _options4.classNamePrevCtrl;
	        var classNameNextCtrl = _options4.classNameNextCtrl;
	        var enableMouseEvents = _options4.enableMouseEvents;
	        var classNameActiveSlide = _options4.classNameActiveSlide;
	
	
	        frame = slider.getElementsByClassName(classNameFrame)[0];
	        slideContainer = frame.getElementsByClassName(classNameSlideContainer)[0];
	        prevCtrl = slider.getElementsByClassName(classNamePrevCtrl)[0];
	        nextCtrl = slider.getElementsByClassName(classNameNextCtrl)[0];
	
	        position = {
	            x: slideContainer.offsetLeft,
	            y: slideContainer.offsetTop
	        };
	
	        if (options.infinite) {
	            slides = setupInfinite(slice.call(slideContainer.children));
	        } else {
	            slides = slice.call(slideContainer.children);
	        }
	
	        reset();
	
	        if (classNameActiveSlide) {
	            setActiveElement(slides, index);
	        }
	
	        if (prevCtrl && nextCtrl) {
	            prevCtrl.addEventListener('click', prev);
	            nextCtrl.addEventListener('click', next);
	        }
	
	        frame.addEventListener('touchstart', onTouchstart);
	
	        if (enableMouseEvents) {
	            frame.addEventListener('mousedown', onTouchstart);
	            frame.addEventListener('click', onClick);
	        }
	
	        options.window.addEventListener('resize', onResize);
	
	        dispatchSliderEvent('after', 'init');
	    }
	
	    /**
	     * public
	     * reset function: called on resize
	     */
	    function reset() {
	        var _options5 = options;
	        var infinite = _options5.infinite;
	        var ease = _options5.ease;
	        var rewindSpeed = _options5.rewindSpeed;
	        var rewindOnResize = _options5.rewindOnResize;
	        var classNameActiveSlide = _options5.classNameActiveSlide;
	
	
	        slidesWidth = slideContainer.getBoundingClientRect().width || slideContainer.offsetWidth;
	        frameWidth = frame.getBoundingClientRect().width || frame.offsetWidth;
	
	        if (frameWidth === slidesWidth) {
	            slidesWidth = slides.reduce(function (previousValue, slide) {
	                return previousValue + slide.getBoundingClientRect().width || slide.offsetWidth;
	            }, 0);
	        }
	
	        if (rewindOnResize) {
	            index = 0;
	        } else {
	            ease = null;
	            rewindSpeed = 0;
	        }
	
	        if (infinite) {
	            translate(slides[index + infinite].offsetLeft * -1, 0, null);
	
	            index = index + infinite;
	            position.x = slides[index].offsetLeft * -1;
	        } else {
	            translate(slides[index].offsetLeft * -1, rewindSpeed, ease);
	            position.x = slides[index].offsetLeft * -1;
	        }
	
	        if (classNameActiveSlide) {
	            setActiveElement(slice.call(slides), index);
	        }
	    }
	
	    /**
	     * public
	     * slideTo: called on clickhandler
	     */
	    function slideTo(index) {
	        slide(index);
	    }
	
	    /**
	     * public
	     * returnIndex function: called on clickhandler
	     */
	    function returnIndex() {
	        return index - options.infinite || 0;
	    }
	
	    /**
	     * public
	     * prev function: called on clickhandler
	     */
	    function prev() {
	        slide(false, false);
	    }
	
	    /**
	     * public
	     * next function: called on clickhandler
	     */
	    function next() {
	        slide(false, true);
	    }
	
	    /**
	     * public
	     * destroy function: called to gracefully destroy the lory instance
	     */
	    function destroy() {
	        dispatchSliderEvent('before', 'destroy');
	
	        // remove event listeners
	        frame.removeEventListener(prefixes.transitionEnd, onTransitionEnd);
	        frame.removeEventListener('touchstart', onTouchstart);
	        frame.removeEventListener('touchmove', onTouchmove);
	        frame.removeEventListener('touchend', onTouchend);
	        frame.removeEventListener('mousemove', onTouchmove);
	        frame.removeEventListener('mousedown', onTouchstart);
	        frame.removeEventListener('mouseup', onTouchend);
	        frame.removeEventListener('mouseleave', onTouchend);
	        frame.removeEventListener('click', onClick);
	
	        options.window.removeEventListener('resize', onResize);
	
	        if (prevCtrl) {
	            prevCtrl.removeEventListener('click', prev);
	        }
	
	        if (nextCtrl) {
	            nextCtrl.removeEventListener('click', next);
	        }
	
	        // remove cloned slides if infinite is set
	        if (options.infinite) {
	            Array.apply(null, Array(options.infinite)).forEach(function () {
	                slideContainer.removeChild(slideContainer.firstChild);
	                slideContainer.removeChild(slideContainer.lastChild);
	            });
	        }
	
	        dispatchSliderEvent('after', 'destroy');
	    }
	
	    // event handling
	
	    var touchOffset = void 0;
	    var delta = void 0;
	    var isScrolling = void 0;
	
	    function onTransitionEnd() {
	        if (transitionEndCallback) {
	            transitionEndCallback();
	
	            transitionEndCallback = undefined;
	        }
	    }
	
	    function onTouchstart(event) {
	        var _options6 = options;
	        var enableMouseEvents = _options6.enableMouseEvents;
	
	        var touches = event.touches ? event.touches[0] : event;
	
	        if (enableMouseEvents) {
	            frame.addEventListener('mousemove', onTouchmove);
	            frame.addEventListener('mouseup', onTouchend);
	            frame.addEventListener('mouseleave', onTouchend);
	        }
	
	        frame.addEventListener('touchmove', onTouchmove);
	        frame.addEventListener('touchend', onTouchend);
	
	        var pageX = touches.pageX;
	        var pageY = touches.pageY;
	
	
	        touchOffset = {
	            x: pageX,
	            y: pageY,
	            time: Date.now()
	        };
	
	        isScrolling = undefined;
	
	        delta = {};
	
	        dispatchSliderEvent('on', 'touchstart', {
	            event: event
	        });
	    }
	
	    function onTouchmove(event) {
	        var touches = event.touches ? event.touches[0] : event;
	        var pageX = touches.pageX;
	        var pageY = touches.pageY;
	
	
	        delta = {
	            x: pageX - touchOffset.x,
	            y: pageY - touchOffset.y
	        };
	
	        if (typeof isScrolling === 'undefined') {
	            isScrolling = !!(isScrolling || Math.abs(delta.x) < Math.abs(delta.y));
	        }
	
	        if (!isScrolling && touchOffset) {
	            event.preventDefault();
	            translate(position.x + delta.x, 0, null);
	        }
	
	        // may be
	        dispatchSliderEvent('on', 'touchmove', {
	            event: event
	        });
	    }
	
	    function onTouchend(event) {
	        /**
	         * time between touchstart and touchend in milliseconds
	         * @duration {number}
	         */
	        var duration = touchOffset ? Date.now() - touchOffset.time : undefined;
	
	        /**
	         * is valid if:
	         *
	         * -> swipe attempt time is over 300 ms
	         * and
	         * -> swipe distance is greater than 25px
	         * or
	         * -> swipe distance is more then a third of the swipe area
	         *
	         * @isValidSlide {Boolean}
	         */
	        var isValid = Number(duration) < 300 && Math.abs(delta.x) > 25 || Math.abs(delta.x) > frameWidth / 3;
	
	        /**
	         * is out of bounds if:
	         *
	         * -> index is 0 and delta x is greater than 0
	         * or
	         * -> index is the last slide and delta is smaller than 0
	         *
	         * @isOutOfBounds {Boolean}
	         */
	        var isOutOfBounds = !index && delta.x > 0 || index === slides.length - 1 && delta.x < 0;
	
	        var direction = delta.x < 0;
	
	        if (!isScrolling) {
	            if (isValid && !isOutOfBounds) {
	                slide(false, direction);
	            } else {
	                translate(position.x, options.snapBackSpeed);
	            }
	        }
	
	        touchOffset = undefined;
	
	        /**
	         * remove eventlisteners after swipe attempt
	         */
	        frame.removeEventListener('touchmove', onTouchmove);
	        frame.removeEventListener('touchend', onTouchend);
	        frame.removeEventListener('mousemove', onTouchmove);
	        frame.removeEventListener('mouseup', onTouchend);
	        frame.removeEventListener('mouseleave', onTouchend);
	
	        dispatchSliderEvent('on', 'touchend', {
	            event: event
	        });
	    }
	
	    function onClick(event) {
	        if (delta.x) {
	            event.preventDefault();
	        }
	    }
	
	    function onResize(event) {
	        reset();
	
	        dispatchSliderEvent('on', 'resize', {
	            event: event
	        });
	    }
	
	    // trigger initial setup
	    setup();
	
	    // expose public api
	    return {
	        setup: setup,
	        reset: reset,
	        slideTo: slideTo,
	        returnIndex: returnIndex,
	        prev: prev,
	        next: next,
	        destroy: destroy
	    };
	}

/***/ },
/* 2 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = detectPrefixes;
	/**
	 * Detecting prefixes for saving time and bytes
	 */
	function detectPrefixes() {
	    var transform = void 0;
	    var transition = void 0;
	    var transitionEnd = void 0;
	    var hasTranslate3d = void 0;
	
	    (function () {
	        var el = document.createElement('_');
	        var style = el.style;
	
	        var prop = void 0;
	
	        if (style[prop = 'webkitTransition'] === '') {
	            transitionEnd = 'webkitTransitionEnd';
	            transition = prop;
	        }
	
	        if (style[prop = 'transition'] === '') {
	            transitionEnd = 'transitionend';
	            transition = prop;
	        }
	
	        if (style[prop = 'webkitTransform'] === '') {
	            transform = prop;
	        }
	
	        if (style[prop = 'msTransform'] === '') {
	            transform = prop;
	        }
	
	        if (style[prop = 'transform'] === '') {
	            transform = prop;
	        }
	
	        document.body.insertBefore(el, null);
	        style[transform] = 'translate3d(0, 0, 0)';
	        hasTranslate3d = !!global.getComputedStyle(el).getPropertyValue(transform);
	        document.body.removeChild(el);
	    })();
	
	    return {
	        transform: transform,
	        transition: transition,
	        transitionEnd: transitionEnd,
	        hasTranslate3d: hasTranslate3d
	    };
	}
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = dispatchEvent;
	
	var _customEvent = __webpack_require__(4);
	
	var _customEvent2 = _interopRequireDefault(_customEvent);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * dispatch custom events
	 *
	 * @param  {element} el         slideshow element
	 * @param  {string}  type       custom event name
	 * @param  {object}  detail     custom detail information
	 */
	function dispatchEvent(target, type, detail) {
	    var event = new _customEvent2.default(type, {
	        bubbles: true,
	        cancelable: true,
	        detail: detail
	    });
	
	    target.dispatchEvent(event);
	}

/***/ },
/* 4 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {
	var NativeCustomEvent = global.CustomEvent;
	
	function useNative () {
	  try {
	    var p = new NativeCustomEvent('cat', { detail: { foo: 'bar' } });
	    return  'cat' === p.type && 'bar' === p.detail.foo;
	  } catch (e) {
	  }
	  return false;
	}
	
	/**
	 * Cross-browser `CustomEvent` constructor.
	 *
	 * https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent.CustomEvent
	 *
	 * @public
	 */
	
	module.exports = useNative() ? NativeCustomEvent :
	
	// IE >= 9
	'function' === typeof document.createEvent ? function CustomEvent (type, params) {
	  var e = document.createEvent('CustomEvent');
	  if (params) {
	    e.initCustomEvent(type, params.bubbles, params.cancelable, params.detail);
	  } else {
	    e.initCustomEvent(type, false, false, void 0);
	  }
	  return e;
	} :
	
	// IE <= 8
	function CustomEvent (type, params) {
	  var e = document.createEventObject();
	  e.type = type;
	  if (params) {
	    e.bubbles = Boolean(params.bubbles);
	    e.cancelable = Boolean(params.cancelable);
	    e.detail = params.detail;
	  } else {
	    e.bubbles = false;
	    e.cancelable = false;
	    e.detail = void 0;
	  }
	  return e;
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 5 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = {
	  /**
	   * slides scrolled at once
	   * @slidesToScroll {Number}
	   */
	  slidesToScroll: 1,
	
	  /**
	   * time in milliseconds for the animation of a valid slide attempt
	   * @slideSpeed {Number}
	   */
	  slideSpeed: 300,
	
	  /**
	   * time in milliseconds for the animation of the rewind after the last slide
	   * @rewindSpeed {Number}
	   */
	  rewindSpeed: 600,
	
	  /**
	   * time for the snapBack of the slider if the slide attempt was not valid
	   * @snapBackSpeed {Number}
	   */
	  snapBackSpeed: 200,
	
	  /**
	   * Basic easing functions: https://developer.mozilla.org/de/docs/Web/CSS/transition-timing-function
	   * cubic bezier easing functions: http://easings.net/de
	   * @ease {String}
	   */
	  ease: 'ease',
	
	  /**
	   * if slider reached the last slide, with next click the slider goes back to the startindex.
	   * use infinite or rewind, not both
	   * @rewind {Boolean}
	   */
	  rewind: false,
	
	  /**
	   * number of visible slides or false
	   * use infinite or rewind, not both
	   * @infinite {number}
	   */
	  infinite: false,
	
	  /**
	   * class name for slider frame
	   * @classNameFrame {string}
	   */
	  classNameFrame: 'js_frame',
	
	  /**
	   * class name for slides container
	   * @classNameSlideContainer {string}
	   */
	  classNameSlideContainer: 'js_slides',
	
	  /**
	   * class name for slider prev control
	   * @classNamePrevCtrl {string}
	   */
	  classNamePrevCtrl: 'js_prev',
	
	  /**
	   * class name for slider next control
	   * @classNameNextCtrl {string}
	   */
	  classNameNextCtrl: 'js_next',
	
	  /**
	   * class name for current active slide
	   * if emptyString then no class is set
	   * @classNameActiveSlide {string}
	   */
	  classNameActiveSlide: 'active',
	
	  /**
	   * enables mouse events for swiping on desktop devices
	   * @enableMouseEvents {boolean}
	   */
	  enableMouseEvents: false,
	
	  /**
	   * window instance
	   * @window {object}
	   */
	  window: window,
	
	  /**
	   * If false, slides lory to the first slide on window resize.
	   * @rewindOnResize {boolean}
	   */
	  rewindOnResize: true
	};

/***/ }
/******/ ])
});
;
// https://github.com/lewiscollard/horsepower/blob/29d406877d74705c61f27cc656a95ecfde86b987/assets/js/50-carousel.js
    function makeCarousel(selector) {
        var simple = document.querySelector(selector);
        if (!simple) {
            return;
        }
        var loryCarousel = lory(simple, {
            infinite: 1,
            enableMouseEvents: true,
            classNamePrevCtrl:'slider__prev',
            classNameNextCtrl:'slider__next',
            classNameSlideContainer: 'slider__slides',
            classNameFrame: 'slider__frame',
        });

        // Autoplay
        var timer = window.setInterval(function () {
            loryCarousel.next();
        }, 5000);

        function cancelTimer() {
            window.clearInterval(timer);
        }

        simple.querySelector('.slider__next').addEventListener('click', cancelTimer);
        simple.querySelector('.slider__prev').addEventListener('click', cancelTimer);
        simple.addEventListener('on.lory.touchstart', cancelTimer);
    }

    window.addEventListener('load', function() {
        makeCarousel('.js_simple');
    });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiIiwic291cmNlcyI6WyJtYWluLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImpRdWVyeShmdW5jdGlvbigkKSB7XG5cbiAgICAgICBmdW5jdGlvbiBjYXJkRXhjZXJwdCgpIHtcbiAgICAgICAgJChcIi5jYXJkX19leGNlcnB0XCIpLnRleHQoZnVuY3Rpb24oaW5kZXgsIGN1cnJlbnRUZXh0KSB7XG4gICAgICAgICAgcmV0dXJuIGN1cnJlbnRUZXh0LnN1YnN0cigwLCAxMjUpICsgJ1xcdTIwMjYnO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGNhcmRFeGNlcnB0KCk7XG4gICAgICBmdW5jdGlvbiBmZWF0dXJlZFRpdGxlKCkge1xuICAgICAgICQoXCIuZmVhdHVyZWRfX3RpdGxlXCIpLnRleHQoZnVuY3Rpb24oaW5kZXgsIGN1cnJlbnRUZXh0KSB7XG4gICAgICAgICByZXR1cm4gY3VycmVudFRleHQuc3Vic3RyKDAsIDc1KSArICdcXHUyMDI2JztcbiAgICAgICB9KTtcbiAgICAgfVxuICAgICBmZWF0dXJlZFRpdGxlKCk7XG5cbiAgICAkKGRvY3VtZW50KS5yZWFkeShmdW5jdGlvbigpIHtcbiAgICAgICAgXG4gICAgICAgIChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAkKCcuc3BvcnRzcHJlc3Mgc3R5bGUnKS5yZW1vdmUoKTtcbiAgICAgICAgICAgICQoJy5nYWxsZXJ5LWl0ZW0gYScpLmFkZENsYXNzKCdsaW5rJyk7XG4gICAgICAgIH0pKCk7XG5cbiAgICAgICAgICAgIC8vICQoXCIjbmF2LW1vYmlsZVwiKS5odG1sKCQoXCIjbmF2LW1haW5cIikuaHRtbCgpKTtcbiAgICAgICAgICAgICQoXCIjbmF2LXRyaWdnZXIgLm5hdmljb24tYnV0dG9uXCIpLmNsaWNrKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuaW5mbygnQnVyZ2VyIGNsaWNrZWQnKTtcbiAgICAgICAgICAgICAgICBpZiAoJChcIi50b3BiYXJcIikuaGFzQ2xhc3MoXCJ0b3BiYXItLWV4cGFuZGVkXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICQoXCIudG9wYmFyXCIpLnJlbW92ZUNsYXNzKFwidG9wYmFyLS1leHBhbmRlZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgJCh0aGlzKS5yZW1vdmVDbGFzcyhcIm9wZW5cIik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgJChcIi50b3BiYXJcIikuYWRkQ2xhc3MoXCJ0b3BiYXItLWV4cGFuZGVkXCIpO1xuICAgICAgICAgICAgICAgICAgICAkKHRoaXMpLmFkZENsYXNzKFwib3BlblwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICBcbiAgICAgICAgdmFyIGJMYXp5ID0gbmV3IEJsYXp5KHtcbiAgICAgICAgICBvZmZzZXQ6IDIwLFxuICAgICAgICAgIHNlbGVjdG9yOiAnLmJsYXp5JyxcbiAgICAgICAgICBsb2FkSW52aXNpYmxlOiBmYWxzZSxcbiAgICAgICAgICBicmVha3BvaW50czogW3tcbiAgICAgICAgICAgIHdpZHRoOiAzNjAsIC8vIE1heC13aWR0aFxuICAgICAgICAgICAgc3JjOiAnZGF0YS1zcmMtc21hbGwnXG4gICAgICAgICAgfV0sXG4gICAgICAgICAgc3VjY2VzczogZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgICAgICAgJChlbGVtZW50KS5wYXJlbnQoKS5yZW1vdmVDbGFzcygnbG9hZGluZycsIDUwMCk7XG4gICAgICAgICAgICB1cGRhdGVDb3VudGVyKCk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBlcnJvcjogZnVuY3Rpb24oZWxlbWVudCwgbXNnKSB7XG4gICAgICAgICAgICBpZiAobXNnID09PSAnbWlzc2luZycpIHtcbiAgICAgICAgICAgICAgJChlbGVtZW50KS5wYXJlbnQoKS5yZW1vdmVDbGFzcygnbG9hZGluZycsIDUwMCk7IC8vIERhdGEtc3JjIGlzIG1pc3NpbmdcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcImJMYXp5OiBkYXRhLXNyYyBpcyBtaXNzaW5nXCIpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChtc2cgPT09ICdpbnZhbGlkJykge1xuICAgICAgICAgICAgICAkKGVsZW1lbnQpLnBhcmVudCgpLnJlbW92ZUNsYXNzKCdsb2FkaW5nJywgNTAwKTtcbiAgICAgICAgICAgICAgLy8gRGF0YS1zcmMgaXMgaW52YWxpZFxuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiYkxhenk6IGRhdGEtc3JjIGlzIGludmFsaWRcIik7XG4gICAgICAgIFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIC8vIG5vdCBuZWVkZWQsIG9ubHkgaGVyZSB0byBpbGx1c3RyYXRlIGFtb3VudCBvZiBsb2FkZWQgaW1hZ2VzXG4gICAgICAgIHZhciBpbWFnZUxvYWRlZCA9IDA7XG4gICAgICAgIFxuICAgICAgICBmdW5jdGlvbiB1cGRhdGVDb3VudGVyKCkge1xuICAgICAgICAgIGltYWdlTG9hZGVkKys7XG4gICAgICAgICAgY29uc29sZS5pbmZvKFwiYkxhenk6IEltYWdlcyBsb2FkZWQ6ICVkXCIsIGltYWdlTG9hZGVkKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gdGFicyhiTGF6eSk7XG5cbiAgICAgICAgKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGFqYXhfdXJsID0gJCgnYm9keScpLmF0dHIoJ2RhdGEtYWpheC11cmwnKTtcbiAgICAgICAgICAgIHZhciBwb3N0X29mZnNldCA9IDA7XG4gICAgICAgICAgICB2YXIgaW5jTnVtYmVyID0gNjsgLy8gaWxvxZvEhyBwb3N0w7N3IGRvIHphxYJhZG93YW5pYVxuICAgICAgICBcbiAgICAgICAgICAgIHZhciBwcm9qZWN0cyA9IChmdW5jdGlvbihzZXRQcm9qZWN0cykge1xuICAgICAgICAgICAgICAgIHZhciBsb2FkZWQ7XG4gICAgICAgICAgICAgICAgdmFyIHRvdGFsO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGluY0xvYWRlZDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2FkZWQgPSBsb2FkZWQgKyBpbmNOdW1iZXI7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGdldExvYWRlZDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbG9hZGVkO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBzZXRMb2FkZWQ6IGZ1bmN0aW9uKHNldFByb2plY3RzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2FkZWQgPSBzZXRQcm9qZWN0cztcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgc2V0VG90YWw6IGZ1bmN0aW9uKHNldFByb2plY3RzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b3RhbCA9IHNldFByb2plY3RzO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBnZXRUb3RhbDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdG90YWw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgICAgIHZhciBsb2FkaW5nQnV0dG9uID0gKGZ1bmN0aW9uKGJ1dHRvbil7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgc2hvd1NwaW5uZXI6IGZ1bmN0aW9uKGJ1dHRvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnV0dG9uLmh0bWwoJ8WBYWR1asSZIHN0YXJzemUuLi4nKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgc2hvd0NhcHRpb246IGZ1bmN0aW9uKGJ1dHRvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnV0dG9uLmh0bWwoJ1pvYmFjeiBzdGFyc3plJyk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGhpZGU6IGZ1bmN0aW9uKGJ1dHRvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnV0dG9uLmhpZGUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KSgpO1xuICAgICAgICBcbiAgICAgICAgICAgICQoJyNsb2FkX21vcmVfcG9zdHMnKS5vbignY2xpY2snLCBsb2FkTW9yZSk7XG4gICAgICAgIFxuICAgICAgICAgICAgZnVuY3Rpb24gbG9hZE1vcmUoKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ0NsaWNrZWQgbG9hZF9tb3JlJyk7XG4gICAgICAgICAgICAgICAgJCh0aGlzKS5odG1sKCfFgWFkdWrEmS4uLicpO1xuICAgICAgICAgICAgICAgIHBvc3Rfb2Zmc2V0ID0gcGFyc2VJbnQocG9zdF9vZmZzZXQpICsgNjtcbiAgICAgICAgICAgICAgICAkLmFqYXgoe1xuICAgICAgICAgICAgICAgICAgICB1cmw6IGFqYXhfdXJsLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbjogJ2xvYWRfcG9zdHMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zdF9vZmZzZXQ6IHBvc3Rfb2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBzdWNjZXNzOiBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAkKCcjbG9hZF9tb3JlX3Bvc3RzJykuaHRtbCgnWm9iYWN6IHN0YXJzemUnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICQoJyNmZWVkJykuYXBwZW5kKGRhdGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5pbmZvKCdBamF4OiBPSycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYkxhenkucmV2YWxpZGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FyZEV4Y2VycHQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgfSkoKTtcblxuICAgIH0pO1xufSk7XG5cbihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFtdLCBmYWN0b3J5KTtcblx0ZWxzZSB7XG5cdFx0dmFyIGEgPSBmYWN0b3J5KCk7XG5cdFx0Zm9yKHZhciBpIGluIGEpICh0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgPyBleHBvcnRzIDogcm9vdClbaV0gPSBhW2ldO1xuXHR9XG59KSh0aGlzLCBmdW5jdGlvbigpIHtcbnJldHVybiAvKioqKioqLyAoZnVuY3Rpb24obW9kdWxlcykgeyAvLyB3ZWJwYWNrQm9vdHN0cmFwXG4vKioqKioqLyBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4vKioqKioqLyBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4vKioqKioqLyBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pXG4vKioqKioqLyBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbi8qKioqKiovIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4vKioqKioqLyBcdFx0XHRleHBvcnRzOiB7fSxcbi8qKioqKiovIFx0XHRcdGlkOiBtb2R1bGVJZCxcbi8qKioqKiovIFx0XHRcdGxvYWRlZDogZmFsc2Vcbi8qKioqKiovIFx0XHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbi8qKioqKiovIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuLyoqKioqKi8gXHRcdG1vZHVsZS5sb2FkZWQgPSB0cnVlO1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuLyoqKioqKi8gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbi8qKioqKiovIFx0fVxuLyoqKioqKi9cbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuLyoqKioqKi8gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbi8qKioqKiovIH0pXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gKFtcbi8qIDAgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdG1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxuXG4vKioqLyB9LFxuLyogMSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0J3VzZSBzdHJpY3QnO1xuXHRcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG5cdCAgICB2YWx1ZTogdHJ1ZVxuXHR9KTtcblx0XG5cdHZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07IC8qIGdsb2JhbHMgalF1ZXJ5ICovXG5cdFxuXHRleHBvcnRzLmxvcnkgPSBsb3J5O1xuXHRcblx0dmFyIF9kZXRlY3RQcmVmaXhlcyA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG5cdFxuXHR2YXIgX2RldGVjdFByZWZpeGVzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2RldGVjdFByZWZpeGVzKTtcblx0XG5cdHZhciBfZGlzcGF0Y2hFdmVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG5cdFxuXHR2YXIgX2Rpc3BhdGNoRXZlbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZGlzcGF0Y2hFdmVudCk7XG5cdFxuXHR2YXIgX2RlZmF1bHRzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcblx0XG5cdHZhciBfZGVmYXVsdHMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZGVmYXVsdHMpO1xuXHRcblx0ZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblx0XG5cdHZhciBzbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcblx0XG5cdGZ1bmN0aW9uIGxvcnkoc2xpZGVyLCBvcHRzKSB7XG5cdCAgICB2YXIgcG9zaXRpb24gPSB2b2lkIDA7XG5cdCAgICB2YXIgc2xpZGVzV2lkdGggPSB2b2lkIDA7XG5cdCAgICB2YXIgZnJhbWVXaWR0aCA9IHZvaWQgMDtcblx0ICAgIHZhciBzbGlkZXMgPSB2b2lkIDA7XG5cdFxuXHQgICAgLyoqXG5cdCAgICAgKiBzbGlkZXIgRE9NIGVsZW1lbnRzXG5cdCAgICAgKi9cblx0ICAgIHZhciBmcmFtZSA9IHZvaWQgMDtcblx0ICAgIHZhciBzbGlkZUNvbnRhaW5lciA9IHZvaWQgMDtcblx0ICAgIHZhciBwcmV2Q3RybCA9IHZvaWQgMDtcblx0ICAgIHZhciBuZXh0Q3RybCA9IHZvaWQgMDtcblx0ICAgIHZhciBwcmVmaXhlcyA9IHZvaWQgMDtcblx0ICAgIHZhciB0cmFuc2l0aW9uRW5kQ2FsbGJhY2sgPSB2b2lkIDA7XG5cdFxuXHQgICAgdmFyIGluZGV4ID0gMDtcblx0ICAgIHZhciBvcHRpb25zID0ge307XG5cdFxuXHQgICAgLyoqXG5cdCAgICAgKiBpZiBvYmplY3QgaXMgalF1ZXJ5IGNvbnZlcnQgdG8gbmF0aXZlIERPTSBlbGVtZW50XG5cdCAgICAgKi9cblx0ICAgIGlmICh0eXBlb2YgalF1ZXJ5ICE9PSAndW5kZWZpbmVkJyAmJiBzbGlkZXIgaW5zdGFuY2VvZiBqUXVlcnkpIHtcblx0ICAgICAgICBzbGlkZXIgPSBzbGlkZXJbMF07XG5cdCAgICB9XG5cdFxuXHQgICAgLyoqXG5cdCAgICAgKiBwcml2YXRlXG5cdCAgICAgKiBzZXQgYWN0aXZlIGNsYXNzIHRvIGVsZW1lbnQgd2hpY2ggaXMgdGhlIGN1cnJlbnQgc2xpZGVcblx0ICAgICAqL1xuXHQgICAgZnVuY3Rpb24gc2V0QWN0aXZlRWxlbWVudChzbGlkZXMsIGN1cnJlbnRJbmRleCkge1xuXHQgICAgICAgIHZhciBfb3B0aW9ucyA9IG9wdGlvbnM7XG5cdCAgICAgICAgdmFyIGNsYXNzTmFtZUFjdGl2ZVNsaWRlID0gX29wdGlvbnMuY2xhc3NOYW1lQWN0aXZlU2xpZGU7XG5cdFxuXHRcblx0ICAgICAgICBzbGlkZXMuZm9yRWFjaChmdW5jdGlvbiAoZWxlbWVudCwgaW5kZXgpIHtcblx0ICAgICAgICAgICAgaWYgKGVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKGNsYXNzTmFtZUFjdGl2ZVNsaWRlKSkge1xuXHQgICAgICAgICAgICAgICAgZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKGNsYXNzTmFtZUFjdGl2ZVNsaWRlKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0pO1xuXHRcblx0ICAgICAgICBzbGlkZXNbY3VycmVudEluZGV4XS5jbGFzc0xpc3QuYWRkKGNsYXNzTmFtZUFjdGl2ZVNsaWRlKTtcblx0ICAgIH1cblx0XG5cdCAgICAvKipcblx0ICAgICAqIHByaXZhdGVcblx0ICAgICAqIHNldHVwSW5maW5pdGU6IGZ1bmN0aW9uIHRvIHNldHVwIGlmIGluZmluaXRlIGlzIHNldFxuXHQgICAgICpcblx0ICAgICAqIEBwYXJhbSAge2FycmF5fSBzbGlkZUFycmF5XG5cdCAgICAgKiBAcmV0dXJuIHthcnJheX0gYXJyYXkgb2YgdXBkYXRlZCBzbGlkZUNvbnRhaW5lciBlbGVtZW50c1xuXHQgICAgICovXG5cdCAgICBmdW5jdGlvbiBzZXR1cEluZmluaXRlKHNsaWRlQXJyYXkpIHtcblx0ICAgICAgICB2YXIgX29wdGlvbnMyID0gb3B0aW9ucztcblx0ICAgICAgICB2YXIgaW5maW5pdGUgPSBfb3B0aW9uczIuaW5maW5pdGU7XG5cdFxuXHRcblx0ICAgICAgICB2YXIgZnJvbnQgPSBzbGlkZUFycmF5LnNsaWNlKDAsIGluZmluaXRlKTtcblx0ICAgICAgICB2YXIgYmFjayA9IHNsaWRlQXJyYXkuc2xpY2Uoc2xpZGVBcnJheS5sZW5ndGggLSBpbmZpbml0ZSwgc2xpZGVBcnJheS5sZW5ndGgpO1xuXHRcblx0ICAgICAgICBmcm9udC5mb3JFYWNoKGZ1bmN0aW9uIChlbGVtZW50KSB7XG5cdCAgICAgICAgICAgIHZhciBjbG9uZWQgPSBlbGVtZW50LmNsb25lTm9kZSh0cnVlKTtcblx0XG5cdCAgICAgICAgICAgIHNsaWRlQ29udGFpbmVyLmFwcGVuZENoaWxkKGNsb25lZCk7XG5cdCAgICAgICAgfSk7XG5cdFxuXHQgICAgICAgIGJhY2sucmV2ZXJzZSgpLmZvckVhY2goZnVuY3Rpb24gKGVsZW1lbnQpIHtcblx0ICAgICAgICAgICAgdmFyIGNsb25lZCA9IGVsZW1lbnQuY2xvbmVOb2RlKHRydWUpO1xuXHRcblx0ICAgICAgICAgICAgc2xpZGVDb250YWluZXIuaW5zZXJ0QmVmb3JlKGNsb25lZCwgc2xpZGVDb250YWluZXIuZmlyc3RDaGlsZCk7XG5cdCAgICAgICAgfSk7XG5cdFxuXHQgICAgICAgIHNsaWRlQ29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIocHJlZml4ZXMudHJhbnNpdGlvbkVuZCwgb25UcmFuc2l0aW9uRW5kKTtcblx0XG5cdCAgICAgICAgcmV0dXJuIHNsaWNlLmNhbGwoc2xpZGVDb250YWluZXIuY2hpbGRyZW4pO1xuXHQgICAgfVxuXHRcblx0ICAgIC8qKlxuXHQgICAgICogW2Rpc3BhdGNoU2xpZGVyRXZlbnQgZGVzY3JpcHRpb25dXG5cdCAgICAgKiBAcmV0dXJuIHtbdHlwZV19IFtkZXNjcmlwdGlvbl1cblx0ICAgICAqL1xuXHQgICAgZnVuY3Rpb24gZGlzcGF0Y2hTbGlkZXJFdmVudChwaGFzZSwgdHlwZSwgZGV0YWlsKSB7XG5cdCAgICAgICAgKDAsIF9kaXNwYXRjaEV2ZW50Mi5kZWZhdWx0KShzbGlkZXIsIHBoYXNlICsgJy5sb3J5LicgKyB0eXBlLCBkZXRhaWwpO1xuXHQgICAgfVxuXHRcblx0ICAgIC8qKlxuXHQgICAgICogdHJhbnNsYXRlcyB0byBhIGdpdmVuIHBvc2l0aW9uIGluIGEgZ2l2ZW4gdGltZSBpbiBtaWxsaXNlY29uZHNcblx0ICAgICAqXG5cdCAgICAgKiBAdG8gICAgICAgIHtudW1iZXJ9IG51bWJlciBpbiBwaXhlbHMgd2hlcmUgdG8gdHJhbnNsYXRlIHRvXG5cdCAgICAgKiBAZHVyYXRpb24gIHtudW1iZXJ9IHRpbWUgaW4gbWlsbGlzZWNvbmRzIGZvciB0aGUgdHJhbnNpc3Rpb25cblx0ICAgICAqIEBlYXNlICAgICAge3N0cmluZ30gZWFzaW5nIGNzcyBwcm9wZXJ0eVxuXHQgICAgICovXG5cdCAgICBmdW5jdGlvbiB0cmFuc2xhdGUodG8sIGR1cmF0aW9uLCBlYXNlKSB7XG5cdCAgICAgICAgdmFyIHN0eWxlID0gc2xpZGVDb250YWluZXIgJiYgc2xpZGVDb250YWluZXIuc3R5bGU7XG5cdFxuXHQgICAgICAgIGlmIChzdHlsZSkge1xuXHQgICAgICAgICAgICBzdHlsZVtwcmVmaXhlcy50cmFuc2l0aW9uICsgJ1RpbWluZ0Z1bmN0aW9uJ10gPSBlYXNlO1xuXHQgICAgICAgICAgICBzdHlsZVtwcmVmaXhlcy50cmFuc2l0aW9uICsgJ0R1cmF0aW9uJ10gPSBkdXJhdGlvbiArICdtcyc7XG5cdFxuXHQgICAgICAgICAgICBpZiAocHJlZml4ZXMuaGFzVHJhbnNsYXRlM2QpIHtcblx0ICAgICAgICAgICAgICAgIHN0eWxlW3ByZWZpeGVzLnRyYW5zZm9ybV0gPSAndHJhbnNsYXRlM2QoJyArIHRvICsgJ3B4LCAwLCAwKSc7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICBzdHlsZVtwcmVmaXhlcy50cmFuc2Zvcm1dID0gJ3RyYW5zbGF0ZSgnICsgdG8gKyAncHgsIDApJztcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH1cblx0XG5cdCAgICAvKipcblx0ICAgICAqIHNsaWRlZnVuY3Rpb24gY2FsbGVkIGJ5IHByZXYsIG5leHQgJiB0b3VjaGVuZFxuXHQgICAgICpcblx0ICAgICAqIGRldGVybWluZSBuZXh0SW5kZXggYW5kIHNsaWRlIHRvIG5leHQgcG9zdGlvblxuXHQgICAgICogdW5kZXIgcmVzdHJpY3Rpb25zIG9mIHRoZSBkZWZpbmVkIG9wdGlvbnNcblx0ICAgICAqXG5cdCAgICAgKiBAZGlyZWN0aW9uICB7Ym9vbGVhbn1cblx0ICAgICAqL1xuXHQgICAgZnVuY3Rpb24gc2xpZGUobmV4dEluZGV4LCBkaXJlY3Rpb24pIHtcblx0ICAgICAgICB2YXIgX29wdGlvbnMzID0gb3B0aW9ucztcblx0ICAgICAgICB2YXIgc2xpZGVTcGVlZCA9IF9vcHRpb25zMy5zbGlkZVNwZWVkO1xuXHQgICAgICAgIHZhciBzbGlkZXNUb1Njcm9sbCA9IF9vcHRpb25zMy5zbGlkZXNUb1Njcm9sbDtcblx0ICAgICAgICB2YXIgaW5maW5pdGUgPSBfb3B0aW9uczMuaW5maW5pdGU7XG5cdCAgICAgICAgdmFyIHJld2luZCA9IF9vcHRpb25zMy5yZXdpbmQ7XG5cdCAgICAgICAgdmFyIHJld2luZFNwZWVkID0gX29wdGlvbnMzLnJld2luZFNwZWVkO1xuXHQgICAgICAgIHZhciBlYXNlID0gX29wdGlvbnMzLmVhc2U7XG5cdCAgICAgICAgdmFyIGNsYXNzTmFtZUFjdGl2ZVNsaWRlID0gX29wdGlvbnMzLmNsYXNzTmFtZUFjdGl2ZVNsaWRlO1xuXHRcblx0XG5cdCAgICAgICAgdmFyIGR1cmF0aW9uID0gc2xpZGVTcGVlZDtcblx0XG5cdCAgICAgICAgdmFyIG5leHRTbGlkZSA9IGRpcmVjdGlvbiA/IGluZGV4ICsgMSA6IGluZGV4IC0gMTtcblx0ICAgICAgICB2YXIgbWF4T2Zmc2V0ID0gTWF0aC5yb3VuZChzbGlkZXNXaWR0aCAtIGZyYW1lV2lkdGgpO1xuXHRcblx0ICAgICAgICBkaXNwYXRjaFNsaWRlckV2ZW50KCdiZWZvcmUnLCAnc2xpZGUnLCB7XG5cdCAgICAgICAgICAgIGluZGV4OiBpbmRleCxcblx0ICAgICAgICAgICAgbmV4dFNsaWRlOiBuZXh0U2xpZGVcblx0ICAgICAgICB9KTtcblx0XG5cdCAgICAgICAgaWYgKHR5cGVvZiBuZXh0SW5kZXggIT09ICdudW1iZXInKSB7XG5cdCAgICAgICAgICAgIGlmIChkaXJlY3Rpb24pIHtcblx0ICAgICAgICAgICAgICAgIG5leHRJbmRleCA9IGluZGV4ICsgc2xpZGVzVG9TY3JvbGw7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICBuZXh0SW5kZXggPSBpbmRleCAtIHNsaWRlc1RvU2Nyb2xsO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHRcblx0ICAgICAgICBuZXh0SW5kZXggPSBNYXRoLm1pbihNYXRoLm1heChuZXh0SW5kZXgsIDApLCBzbGlkZXMubGVuZ3RoIC0gMSk7XG5cdFxuXHQgICAgICAgIGlmIChpbmZpbml0ZSAmJiBkaXJlY3Rpb24gPT09IHVuZGVmaW5lZCkge1xuXHQgICAgICAgICAgICBuZXh0SW5kZXggKz0gaW5maW5pdGU7XG5cdCAgICAgICAgfVxuXHRcblx0ICAgICAgICB2YXIgbmV4dE9mZnNldCA9IE1hdGgubWluKE1hdGgubWF4KHNsaWRlc1tuZXh0SW5kZXhdLm9mZnNldExlZnQgKiAtMSwgbWF4T2Zmc2V0ICogLTEpLCAwKTtcblx0XG5cdCAgICAgICAgaWYgKHJld2luZCAmJiBNYXRoLmFicyhwb3NpdGlvbi54KSA9PT0gbWF4T2Zmc2V0ICYmIGRpcmVjdGlvbikge1xuXHQgICAgICAgICAgICBuZXh0T2Zmc2V0ID0gMDtcblx0ICAgICAgICAgICAgbmV4dEluZGV4ID0gMDtcblx0ICAgICAgICAgICAgZHVyYXRpb24gPSByZXdpbmRTcGVlZDtcblx0ICAgICAgICB9XG5cdFxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIHRyYW5zbGF0ZSB0byB0aGUgbmV4dE9mZnNldCBieSBhIGRlZmluZWQgZHVyYXRpb24gYW5kIGVhc2UgZnVuY3Rpb25cblx0ICAgICAgICAgKi9cblx0ICAgICAgICB0cmFuc2xhdGUobmV4dE9mZnNldCwgZHVyYXRpb24sIGVhc2UpO1xuXHRcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiB1cGRhdGUgdGhlIHBvc2l0aW9uIHdpdGggdGhlIG5leHQgcG9zaXRpb25cblx0ICAgICAgICAgKi9cblx0ICAgICAgICBwb3NpdGlvbi54ID0gbmV4dE9mZnNldDtcblx0XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogdXBkYXRlIHRoZSBpbmRleCB3aXRoIHRoZSBuZXh0SW5kZXggb25seSBpZlxuXHQgICAgICAgICAqIHRoZSBvZmZzZXQgb2YgdGhlIG5leHRJbmRleCBpcyBpbiB0aGUgcmFuZ2Ugb2YgdGhlIG1heE9mZnNldFxuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGlmIChzbGlkZXNbbmV4dEluZGV4XS5vZmZzZXRMZWZ0IDw9IG1heE9mZnNldCkge1xuXHQgICAgICAgICAgICBpbmRleCA9IG5leHRJbmRleDtcblx0ICAgICAgICB9XG5cdFxuXHQgICAgICAgIGlmIChpbmZpbml0ZSAmJiAobmV4dEluZGV4ID09PSBzbGlkZXMubGVuZ3RoIC0gaW5maW5pdGUgfHwgbmV4dEluZGV4ID09PSAwKSkge1xuXHQgICAgICAgICAgICBpZiAoZGlyZWN0aW9uKSB7XG5cdCAgICAgICAgICAgICAgICBpbmRleCA9IGluZmluaXRlO1xuXHQgICAgICAgICAgICB9XG5cdFxuXHQgICAgICAgICAgICBpZiAoIWRpcmVjdGlvbikge1xuXHQgICAgICAgICAgICAgICAgaW5kZXggPSBzbGlkZXMubGVuZ3RoIC0gaW5maW5pdGUgKiAyO1xuXHQgICAgICAgICAgICB9XG5cdFxuXHQgICAgICAgICAgICBwb3NpdGlvbi54ID0gc2xpZGVzW2luZGV4XS5vZmZzZXRMZWZ0ICogLTE7XG5cdFxuXHQgICAgICAgICAgICB0cmFuc2l0aW9uRW5kQ2FsbGJhY2sgPSBmdW5jdGlvbiB0cmFuc2l0aW9uRW5kQ2FsbGJhY2soKSB7XG5cdCAgICAgICAgICAgICAgICB0cmFuc2xhdGUoc2xpZGVzW2luZGV4XS5vZmZzZXRMZWZ0ICogLTEsIDAsIHVuZGVmaW5lZCk7XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgfVxuXHRcblx0ICAgICAgICBpZiAoY2xhc3NOYW1lQWN0aXZlU2xpZGUpIHtcblx0ICAgICAgICAgICAgc2V0QWN0aXZlRWxlbWVudChzbGljZS5jYWxsKHNsaWRlcyksIGluZGV4KTtcblx0ICAgICAgICB9XG5cdFxuXHQgICAgICAgIGRpc3BhdGNoU2xpZGVyRXZlbnQoJ2FmdGVyJywgJ3NsaWRlJywge1xuXHQgICAgICAgICAgICBjdXJyZW50U2xpZGU6IGluZGV4XG5cdCAgICAgICAgfSk7XG5cdCAgICB9XG5cdFxuXHQgICAgLyoqXG5cdCAgICAgKiBwdWJsaWNcblx0ICAgICAqIHNldHVwIGZ1bmN0aW9uXG5cdCAgICAgKi9cblx0ICAgIGZ1bmN0aW9uIHNldHVwKCkge1xuXHQgICAgICAgIGRpc3BhdGNoU2xpZGVyRXZlbnQoJ2JlZm9yZScsICdpbml0Jyk7XG5cdFxuXHQgICAgICAgIHByZWZpeGVzID0gKDAsIF9kZXRlY3RQcmVmaXhlczIuZGVmYXVsdCkoKTtcblx0ICAgICAgICBvcHRpb25zID0gX2V4dGVuZHMoe30sIF9kZWZhdWx0czIuZGVmYXVsdCwgb3B0cyk7XG5cdFxuXHQgICAgICAgIHZhciBfb3B0aW9uczQgPSBvcHRpb25zO1xuXHQgICAgICAgIHZhciBjbGFzc05hbWVGcmFtZSA9IF9vcHRpb25zNC5jbGFzc05hbWVGcmFtZTtcblx0ICAgICAgICB2YXIgY2xhc3NOYW1lU2xpZGVDb250YWluZXIgPSBfb3B0aW9uczQuY2xhc3NOYW1lU2xpZGVDb250YWluZXI7XG5cdCAgICAgICAgdmFyIGNsYXNzTmFtZVByZXZDdHJsID0gX29wdGlvbnM0LmNsYXNzTmFtZVByZXZDdHJsO1xuXHQgICAgICAgIHZhciBjbGFzc05hbWVOZXh0Q3RybCA9IF9vcHRpb25zNC5jbGFzc05hbWVOZXh0Q3RybDtcblx0ICAgICAgICB2YXIgZW5hYmxlTW91c2VFdmVudHMgPSBfb3B0aW9uczQuZW5hYmxlTW91c2VFdmVudHM7XG5cdCAgICAgICAgdmFyIGNsYXNzTmFtZUFjdGl2ZVNsaWRlID0gX29wdGlvbnM0LmNsYXNzTmFtZUFjdGl2ZVNsaWRlO1xuXHRcblx0XG5cdCAgICAgICAgZnJhbWUgPSBzbGlkZXIuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShjbGFzc05hbWVGcmFtZSlbMF07XG5cdCAgICAgICAgc2xpZGVDb250YWluZXIgPSBmcmFtZS5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKGNsYXNzTmFtZVNsaWRlQ29udGFpbmVyKVswXTtcblx0ICAgICAgICBwcmV2Q3RybCA9IHNsaWRlci5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKGNsYXNzTmFtZVByZXZDdHJsKVswXTtcblx0ICAgICAgICBuZXh0Q3RybCA9IHNsaWRlci5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKGNsYXNzTmFtZU5leHRDdHJsKVswXTtcblx0XG5cdCAgICAgICAgcG9zaXRpb24gPSB7XG5cdCAgICAgICAgICAgIHg6IHNsaWRlQ29udGFpbmVyLm9mZnNldExlZnQsXG5cdCAgICAgICAgICAgIHk6IHNsaWRlQ29udGFpbmVyLm9mZnNldFRvcFxuXHQgICAgICAgIH07XG5cdFxuXHQgICAgICAgIGlmIChvcHRpb25zLmluZmluaXRlKSB7XG5cdCAgICAgICAgICAgIHNsaWRlcyA9IHNldHVwSW5maW5pdGUoc2xpY2UuY2FsbChzbGlkZUNvbnRhaW5lci5jaGlsZHJlbikpO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIHNsaWRlcyA9IHNsaWNlLmNhbGwoc2xpZGVDb250YWluZXIuY2hpbGRyZW4pO1xuXHQgICAgICAgIH1cblx0XG5cdCAgICAgICAgcmVzZXQoKTtcblx0XG5cdCAgICAgICAgaWYgKGNsYXNzTmFtZUFjdGl2ZVNsaWRlKSB7XG5cdCAgICAgICAgICAgIHNldEFjdGl2ZUVsZW1lbnQoc2xpZGVzLCBpbmRleCk7XG5cdCAgICAgICAgfVxuXHRcblx0ICAgICAgICBpZiAocHJldkN0cmwgJiYgbmV4dEN0cmwpIHtcblx0ICAgICAgICAgICAgcHJldkN0cmwuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBwcmV2KTtcblx0ICAgICAgICAgICAgbmV4dEN0cmwuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBuZXh0KTtcblx0ICAgICAgICB9XG5cdFxuXHQgICAgICAgIGZyYW1lLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCBvblRvdWNoc3RhcnQpO1xuXHRcblx0ICAgICAgICBpZiAoZW5hYmxlTW91c2VFdmVudHMpIHtcblx0ICAgICAgICAgICAgZnJhbWUuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgb25Ub3VjaHN0YXJ0KTtcblx0ICAgICAgICAgICAgZnJhbWUuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBvbkNsaWNrKTtcblx0ICAgICAgICB9XG5cdFxuXHQgICAgICAgIG9wdGlvbnMud2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIG9uUmVzaXplKTtcblx0XG5cdCAgICAgICAgZGlzcGF0Y2hTbGlkZXJFdmVudCgnYWZ0ZXInLCAnaW5pdCcpO1xuXHQgICAgfVxuXHRcblx0ICAgIC8qKlxuXHQgICAgICogcHVibGljXG5cdCAgICAgKiByZXNldCBmdW5jdGlvbjogY2FsbGVkIG9uIHJlc2l6ZVxuXHQgICAgICovXG5cdCAgICBmdW5jdGlvbiByZXNldCgpIHtcblx0ICAgICAgICB2YXIgX29wdGlvbnM1ID0gb3B0aW9ucztcblx0ICAgICAgICB2YXIgaW5maW5pdGUgPSBfb3B0aW9uczUuaW5maW5pdGU7XG5cdCAgICAgICAgdmFyIGVhc2UgPSBfb3B0aW9uczUuZWFzZTtcblx0ICAgICAgICB2YXIgcmV3aW5kU3BlZWQgPSBfb3B0aW9uczUucmV3aW5kU3BlZWQ7XG5cdCAgICAgICAgdmFyIHJld2luZE9uUmVzaXplID0gX29wdGlvbnM1LnJld2luZE9uUmVzaXplO1xuXHQgICAgICAgIHZhciBjbGFzc05hbWVBY3RpdmVTbGlkZSA9IF9vcHRpb25zNS5jbGFzc05hbWVBY3RpdmVTbGlkZTtcblx0XG5cdFxuXHQgICAgICAgIHNsaWRlc1dpZHRoID0gc2xpZGVDb250YWluZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGggfHwgc2xpZGVDb250YWluZXIub2Zmc2V0V2lkdGg7XG5cdCAgICAgICAgZnJhbWVXaWR0aCA9IGZyYW1lLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoIHx8IGZyYW1lLm9mZnNldFdpZHRoO1xuXHRcblx0ICAgICAgICBpZiAoZnJhbWVXaWR0aCA9PT0gc2xpZGVzV2lkdGgpIHtcblx0ICAgICAgICAgICAgc2xpZGVzV2lkdGggPSBzbGlkZXMucmVkdWNlKGZ1bmN0aW9uIChwcmV2aW91c1ZhbHVlLCBzbGlkZSkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHByZXZpb3VzVmFsdWUgKyBzbGlkZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aCB8fCBzbGlkZS5vZmZzZXRXaWR0aDtcblx0ICAgICAgICAgICAgfSwgMCk7XG5cdCAgICAgICAgfVxuXHRcblx0ICAgICAgICBpZiAocmV3aW5kT25SZXNpemUpIHtcblx0ICAgICAgICAgICAgaW5kZXggPSAwO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIGVhc2UgPSBudWxsO1xuXHQgICAgICAgICAgICByZXdpbmRTcGVlZCA9IDA7XG5cdCAgICAgICAgfVxuXHRcblx0ICAgICAgICBpZiAoaW5maW5pdGUpIHtcblx0ICAgICAgICAgICAgdHJhbnNsYXRlKHNsaWRlc1tpbmRleCArIGluZmluaXRlXS5vZmZzZXRMZWZ0ICogLTEsIDAsIG51bGwpO1xuXHRcblx0ICAgICAgICAgICAgaW5kZXggPSBpbmRleCArIGluZmluaXRlO1xuXHQgICAgICAgICAgICBwb3NpdGlvbi54ID0gc2xpZGVzW2luZGV4XS5vZmZzZXRMZWZ0ICogLTE7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgdHJhbnNsYXRlKHNsaWRlc1tpbmRleF0ub2Zmc2V0TGVmdCAqIC0xLCByZXdpbmRTcGVlZCwgZWFzZSk7XG5cdCAgICAgICAgICAgIHBvc2l0aW9uLnggPSBzbGlkZXNbaW5kZXhdLm9mZnNldExlZnQgKiAtMTtcblx0ICAgICAgICB9XG5cdFxuXHQgICAgICAgIGlmIChjbGFzc05hbWVBY3RpdmVTbGlkZSkge1xuXHQgICAgICAgICAgICBzZXRBY3RpdmVFbGVtZW50KHNsaWNlLmNhbGwoc2xpZGVzKSwgaW5kZXgpO1xuXHQgICAgICAgIH1cblx0ICAgIH1cblx0XG5cdCAgICAvKipcblx0ICAgICAqIHB1YmxpY1xuXHQgICAgICogc2xpZGVUbzogY2FsbGVkIG9uIGNsaWNraGFuZGxlclxuXHQgICAgICovXG5cdCAgICBmdW5jdGlvbiBzbGlkZVRvKGluZGV4KSB7XG5cdCAgICAgICAgc2xpZGUoaW5kZXgpO1xuXHQgICAgfVxuXHRcblx0ICAgIC8qKlxuXHQgICAgICogcHVibGljXG5cdCAgICAgKiByZXR1cm5JbmRleCBmdW5jdGlvbjogY2FsbGVkIG9uIGNsaWNraGFuZGxlclxuXHQgICAgICovXG5cdCAgICBmdW5jdGlvbiByZXR1cm5JbmRleCgpIHtcblx0ICAgICAgICByZXR1cm4gaW5kZXggLSBvcHRpb25zLmluZmluaXRlIHx8IDA7XG5cdCAgICB9XG5cdFxuXHQgICAgLyoqXG5cdCAgICAgKiBwdWJsaWNcblx0ICAgICAqIHByZXYgZnVuY3Rpb246IGNhbGxlZCBvbiBjbGlja2hhbmRsZXJcblx0ICAgICAqL1xuXHQgICAgZnVuY3Rpb24gcHJldigpIHtcblx0ICAgICAgICBzbGlkZShmYWxzZSwgZmFsc2UpO1xuXHQgICAgfVxuXHRcblx0ICAgIC8qKlxuXHQgICAgICogcHVibGljXG5cdCAgICAgKiBuZXh0IGZ1bmN0aW9uOiBjYWxsZWQgb24gY2xpY2toYW5kbGVyXG5cdCAgICAgKi9cblx0ICAgIGZ1bmN0aW9uIG5leHQoKSB7XG5cdCAgICAgICAgc2xpZGUoZmFsc2UsIHRydWUpO1xuXHQgICAgfVxuXHRcblx0ICAgIC8qKlxuXHQgICAgICogcHVibGljXG5cdCAgICAgKiBkZXN0cm95IGZ1bmN0aW9uOiBjYWxsZWQgdG8gZ3JhY2VmdWxseSBkZXN0cm95IHRoZSBsb3J5IGluc3RhbmNlXG5cdCAgICAgKi9cblx0ICAgIGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG5cdCAgICAgICAgZGlzcGF0Y2hTbGlkZXJFdmVudCgnYmVmb3JlJywgJ2Rlc3Ryb3knKTtcblx0XG5cdCAgICAgICAgLy8gcmVtb3ZlIGV2ZW50IGxpc3RlbmVyc1xuXHQgICAgICAgIGZyYW1lLnJlbW92ZUV2ZW50TGlzdGVuZXIocHJlZml4ZXMudHJhbnNpdGlvbkVuZCwgb25UcmFuc2l0aW9uRW5kKTtcblx0ICAgICAgICBmcmFtZS5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0Jywgb25Ub3VjaHN0YXJ0KTtcblx0ICAgICAgICBmcmFtZS5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCBvblRvdWNobW92ZSk7XG5cdCAgICAgICAgZnJhbWUucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCBvblRvdWNoZW5kKTtcblx0ICAgICAgICBmcmFtZS5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBvblRvdWNobW92ZSk7XG5cdCAgICAgICAgZnJhbWUucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgb25Ub3VjaHN0YXJ0KTtcblx0ICAgICAgICBmcmFtZS5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgb25Ub3VjaGVuZCk7XG5cdCAgICAgICAgZnJhbWUucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2VsZWF2ZScsIG9uVG91Y2hlbmQpO1xuXHQgICAgICAgIGZyYW1lLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgb25DbGljayk7XG5cdFxuXHQgICAgICAgIG9wdGlvbnMud2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIG9uUmVzaXplKTtcblx0XG5cdCAgICAgICAgaWYgKHByZXZDdHJsKSB7XG5cdCAgICAgICAgICAgIHByZXZDdHJsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgcHJldik7XG5cdCAgICAgICAgfVxuXHRcblx0ICAgICAgICBpZiAobmV4dEN0cmwpIHtcblx0ICAgICAgICAgICAgbmV4dEN0cmwucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCBuZXh0KTtcblx0ICAgICAgICB9XG5cdFxuXHQgICAgICAgIC8vIHJlbW92ZSBjbG9uZWQgc2xpZGVzIGlmIGluZmluaXRlIGlzIHNldFxuXHQgICAgICAgIGlmIChvcHRpb25zLmluZmluaXRlKSB7XG5cdCAgICAgICAgICAgIEFycmF5LmFwcGx5KG51bGwsIEFycmF5KG9wdGlvbnMuaW5maW5pdGUpKS5mb3JFYWNoKGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICAgIHNsaWRlQ29udGFpbmVyLnJlbW92ZUNoaWxkKHNsaWRlQ29udGFpbmVyLmZpcnN0Q2hpbGQpO1xuXHQgICAgICAgICAgICAgICAgc2xpZGVDb250YWluZXIucmVtb3ZlQ2hpbGQoc2xpZGVDb250YWluZXIubGFzdENoaWxkKTtcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfVxuXHRcblx0ICAgICAgICBkaXNwYXRjaFNsaWRlckV2ZW50KCdhZnRlcicsICdkZXN0cm95Jyk7XG5cdCAgICB9XG5cdFxuXHQgICAgLy8gZXZlbnQgaGFuZGxpbmdcblx0XG5cdCAgICB2YXIgdG91Y2hPZmZzZXQgPSB2b2lkIDA7XG5cdCAgICB2YXIgZGVsdGEgPSB2b2lkIDA7XG5cdCAgICB2YXIgaXNTY3JvbGxpbmcgPSB2b2lkIDA7XG5cdFxuXHQgICAgZnVuY3Rpb24gb25UcmFuc2l0aW9uRW5kKCkge1xuXHQgICAgICAgIGlmICh0cmFuc2l0aW9uRW5kQ2FsbGJhY2spIHtcblx0ICAgICAgICAgICAgdHJhbnNpdGlvbkVuZENhbGxiYWNrKCk7XG5cdFxuXHQgICAgICAgICAgICB0cmFuc2l0aW9uRW5kQ2FsbGJhY2sgPSB1bmRlZmluZWQ7XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXHRcblx0ICAgIGZ1bmN0aW9uIG9uVG91Y2hzdGFydChldmVudCkge1xuXHQgICAgICAgIHZhciBfb3B0aW9uczYgPSBvcHRpb25zO1xuXHQgICAgICAgIHZhciBlbmFibGVNb3VzZUV2ZW50cyA9IF9vcHRpb25zNi5lbmFibGVNb3VzZUV2ZW50cztcblx0XG5cdCAgICAgICAgdmFyIHRvdWNoZXMgPSBldmVudC50b3VjaGVzID8gZXZlbnQudG91Y2hlc1swXSA6IGV2ZW50O1xuXHRcblx0ICAgICAgICBpZiAoZW5hYmxlTW91c2VFdmVudHMpIHtcblx0ICAgICAgICAgICAgZnJhbWUuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgb25Ub3VjaG1vdmUpO1xuXHQgICAgICAgICAgICBmcmFtZS5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgb25Ub3VjaGVuZCk7XG5cdCAgICAgICAgICAgIGZyYW1lLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbGVhdmUnLCBvblRvdWNoZW5kKTtcblx0ICAgICAgICB9XG5cdFxuXHQgICAgICAgIGZyYW1lLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIG9uVG91Y2htb3ZlKTtcblx0ICAgICAgICBmcmFtZS5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIG9uVG91Y2hlbmQpO1xuXHRcblx0ICAgICAgICB2YXIgcGFnZVggPSB0b3VjaGVzLnBhZ2VYO1xuXHQgICAgICAgIHZhciBwYWdlWSA9IHRvdWNoZXMucGFnZVk7XG5cdFxuXHRcblx0ICAgICAgICB0b3VjaE9mZnNldCA9IHtcblx0ICAgICAgICAgICAgeDogcGFnZVgsXG5cdCAgICAgICAgICAgIHk6IHBhZ2VZLFxuXHQgICAgICAgICAgICB0aW1lOiBEYXRlLm5vdygpXG5cdCAgICAgICAgfTtcblx0XG5cdCAgICAgICAgaXNTY3JvbGxpbmcgPSB1bmRlZmluZWQ7XG5cdFxuXHQgICAgICAgIGRlbHRhID0ge307XG5cdFxuXHQgICAgICAgIGRpc3BhdGNoU2xpZGVyRXZlbnQoJ29uJywgJ3RvdWNoc3RhcnQnLCB7XG5cdCAgICAgICAgICAgIGV2ZW50OiBldmVudFxuXHQgICAgICAgIH0pO1xuXHQgICAgfVxuXHRcblx0ICAgIGZ1bmN0aW9uIG9uVG91Y2htb3ZlKGV2ZW50KSB7XG5cdCAgICAgICAgdmFyIHRvdWNoZXMgPSBldmVudC50b3VjaGVzID8gZXZlbnQudG91Y2hlc1swXSA6IGV2ZW50O1xuXHQgICAgICAgIHZhciBwYWdlWCA9IHRvdWNoZXMucGFnZVg7XG5cdCAgICAgICAgdmFyIHBhZ2VZID0gdG91Y2hlcy5wYWdlWTtcblx0XG5cdFxuXHQgICAgICAgIGRlbHRhID0ge1xuXHQgICAgICAgICAgICB4OiBwYWdlWCAtIHRvdWNoT2Zmc2V0LngsXG5cdCAgICAgICAgICAgIHk6IHBhZ2VZIC0gdG91Y2hPZmZzZXQueVxuXHQgICAgICAgIH07XG5cdFxuXHQgICAgICAgIGlmICh0eXBlb2YgaXNTY3JvbGxpbmcgPT09ICd1bmRlZmluZWQnKSB7XG5cdCAgICAgICAgICAgIGlzU2Nyb2xsaW5nID0gISEoaXNTY3JvbGxpbmcgfHwgTWF0aC5hYnMoZGVsdGEueCkgPCBNYXRoLmFicyhkZWx0YS55KSk7XG5cdCAgICAgICAgfVxuXHRcblx0ICAgICAgICBpZiAoIWlzU2Nyb2xsaW5nICYmIHRvdWNoT2Zmc2V0KSB7XG5cdCAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdCAgICAgICAgICAgIHRyYW5zbGF0ZShwb3NpdGlvbi54ICsgZGVsdGEueCwgMCwgbnVsbCk7XG5cdCAgICAgICAgfVxuXHRcblx0ICAgICAgICAvLyBtYXkgYmVcblx0ICAgICAgICBkaXNwYXRjaFNsaWRlckV2ZW50KCdvbicsICd0b3VjaG1vdmUnLCB7XG5cdCAgICAgICAgICAgIGV2ZW50OiBldmVudFxuXHQgICAgICAgIH0pO1xuXHQgICAgfVxuXHRcblx0ICAgIGZ1bmN0aW9uIG9uVG91Y2hlbmQoZXZlbnQpIHtcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiB0aW1lIGJldHdlZW4gdG91Y2hzdGFydCBhbmQgdG91Y2hlbmQgaW4gbWlsbGlzZWNvbmRzXG5cdCAgICAgICAgICogQGR1cmF0aW9uIHtudW1iZXJ9XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgdmFyIGR1cmF0aW9uID0gdG91Y2hPZmZzZXQgPyBEYXRlLm5vdygpIC0gdG91Y2hPZmZzZXQudGltZSA6IHVuZGVmaW5lZDtcblx0XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogaXMgdmFsaWQgaWY6XG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAtPiBzd2lwZSBhdHRlbXB0IHRpbWUgaXMgb3ZlciAzMDAgbXNcblx0ICAgICAgICAgKiBhbmRcblx0ICAgICAgICAgKiAtPiBzd2lwZSBkaXN0YW5jZSBpcyBncmVhdGVyIHRoYW4gMjVweFxuXHQgICAgICAgICAqIG9yXG5cdCAgICAgICAgICogLT4gc3dpcGUgZGlzdGFuY2UgaXMgbW9yZSB0aGVuIGEgdGhpcmQgb2YgdGhlIHN3aXBlIGFyZWFcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBpc1ZhbGlkU2xpZGUge0Jvb2xlYW59XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgdmFyIGlzVmFsaWQgPSBOdW1iZXIoZHVyYXRpb24pIDwgMzAwICYmIE1hdGguYWJzKGRlbHRhLngpID4gMjUgfHwgTWF0aC5hYnMoZGVsdGEueCkgPiBmcmFtZVdpZHRoIC8gMztcblx0XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogaXMgb3V0IG9mIGJvdW5kcyBpZjpcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIC0+IGluZGV4IGlzIDAgYW5kIGRlbHRhIHggaXMgZ3JlYXRlciB0aGFuIDBcblx0ICAgICAgICAgKiBvclxuXHQgICAgICAgICAqIC0+IGluZGV4IGlzIHRoZSBsYXN0IHNsaWRlIGFuZCBkZWx0YSBpcyBzbWFsbGVyIHRoYW4gMFxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGlzT3V0T2ZCb3VuZHMge0Jvb2xlYW59XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgdmFyIGlzT3V0T2ZCb3VuZHMgPSAhaW5kZXggJiYgZGVsdGEueCA+IDAgfHwgaW5kZXggPT09IHNsaWRlcy5sZW5ndGggLSAxICYmIGRlbHRhLnggPCAwO1xuXHRcblx0ICAgICAgICB2YXIgZGlyZWN0aW9uID0gZGVsdGEueCA8IDA7XG5cdFxuXHQgICAgICAgIGlmICghaXNTY3JvbGxpbmcpIHtcblx0ICAgICAgICAgICAgaWYgKGlzVmFsaWQgJiYgIWlzT3V0T2ZCb3VuZHMpIHtcblx0ICAgICAgICAgICAgICAgIHNsaWRlKGZhbHNlLCBkaXJlY3Rpb24pO1xuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgdHJhbnNsYXRlKHBvc2l0aW9uLngsIG9wdGlvbnMuc25hcEJhY2tTcGVlZCk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdFxuXHQgICAgICAgIHRvdWNoT2Zmc2V0ID0gdW5kZWZpbmVkO1xuXHRcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiByZW1vdmUgZXZlbnRsaXN0ZW5lcnMgYWZ0ZXIgc3dpcGUgYXR0ZW1wdFxuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGZyYW1lLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIG9uVG91Y2htb3ZlKTtcblx0ICAgICAgICBmcmFtZS5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIG9uVG91Y2hlbmQpO1xuXHQgICAgICAgIGZyYW1lLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIG9uVG91Y2htb3ZlKTtcblx0ICAgICAgICBmcmFtZS5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgb25Ub3VjaGVuZCk7XG5cdCAgICAgICAgZnJhbWUucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2VsZWF2ZScsIG9uVG91Y2hlbmQpO1xuXHRcblx0ICAgICAgICBkaXNwYXRjaFNsaWRlckV2ZW50KCdvbicsICd0b3VjaGVuZCcsIHtcblx0ICAgICAgICAgICAgZXZlbnQ6IGV2ZW50XG5cdCAgICAgICAgfSk7XG5cdCAgICB9XG5cdFxuXHQgICAgZnVuY3Rpb24gb25DbGljayhldmVudCkge1xuXHQgICAgICAgIGlmIChkZWx0YS54KSB7XG5cdCAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXHRcblx0ICAgIGZ1bmN0aW9uIG9uUmVzaXplKGV2ZW50KSB7XG5cdCAgICAgICAgcmVzZXQoKTtcblx0XG5cdCAgICAgICAgZGlzcGF0Y2hTbGlkZXJFdmVudCgnb24nLCAncmVzaXplJywge1xuXHQgICAgICAgICAgICBldmVudDogZXZlbnRcblx0ICAgICAgICB9KTtcblx0ICAgIH1cblx0XG5cdCAgICAvLyB0cmlnZ2VyIGluaXRpYWwgc2V0dXBcblx0ICAgIHNldHVwKCk7XG5cdFxuXHQgICAgLy8gZXhwb3NlIHB1YmxpYyBhcGlcblx0ICAgIHJldHVybiB7XG5cdCAgICAgICAgc2V0dXA6IHNldHVwLFxuXHQgICAgICAgIHJlc2V0OiByZXNldCxcblx0ICAgICAgICBzbGlkZVRvOiBzbGlkZVRvLFxuXHQgICAgICAgIHJldHVybkluZGV4OiByZXR1cm5JbmRleCxcblx0ICAgICAgICBwcmV2OiBwcmV2LFxuXHQgICAgICAgIG5leHQ6IG5leHQsXG5cdCAgICAgICAgZGVzdHJveTogZGVzdHJveVxuXHQgICAgfTtcblx0fVxuXG4vKioqLyB9LFxuLyogMiAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0LyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovKGZ1bmN0aW9uKGdsb2JhbCkgeyd1c2Ugc3RyaWN0Jztcblx0XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuXHQgICAgdmFsdWU6IHRydWVcblx0fSk7XG5cdGV4cG9ydHMuZGVmYXVsdCA9IGRldGVjdFByZWZpeGVzO1xuXHQvKipcblx0ICogRGV0ZWN0aW5nIHByZWZpeGVzIGZvciBzYXZpbmcgdGltZSBhbmQgYnl0ZXNcblx0ICovXG5cdGZ1bmN0aW9uIGRldGVjdFByZWZpeGVzKCkge1xuXHQgICAgdmFyIHRyYW5zZm9ybSA9IHZvaWQgMDtcblx0ICAgIHZhciB0cmFuc2l0aW9uID0gdm9pZCAwO1xuXHQgICAgdmFyIHRyYW5zaXRpb25FbmQgPSB2b2lkIDA7XG5cdCAgICB2YXIgaGFzVHJhbnNsYXRlM2QgPSB2b2lkIDA7XG5cdFxuXHQgICAgKGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdfJyk7XG5cdCAgICAgICAgdmFyIHN0eWxlID0gZWwuc3R5bGU7XG5cdFxuXHQgICAgICAgIHZhciBwcm9wID0gdm9pZCAwO1xuXHRcblx0ICAgICAgICBpZiAoc3R5bGVbcHJvcCA9ICd3ZWJraXRUcmFuc2l0aW9uJ10gPT09ICcnKSB7XG5cdCAgICAgICAgICAgIHRyYW5zaXRpb25FbmQgPSAnd2Via2l0VHJhbnNpdGlvbkVuZCc7XG5cdCAgICAgICAgICAgIHRyYW5zaXRpb24gPSBwcm9wO1xuXHQgICAgICAgIH1cblx0XG5cdCAgICAgICAgaWYgKHN0eWxlW3Byb3AgPSAndHJhbnNpdGlvbiddID09PSAnJykge1xuXHQgICAgICAgICAgICB0cmFuc2l0aW9uRW5kID0gJ3RyYW5zaXRpb25lbmQnO1xuXHQgICAgICAgICAgICB0cmFuc2l0aW9uID0gcHJvcDtcblx0ICAgICAgICB9XG5cdFxuXHQgICAgICAgIGlmIChzdHlsZVtwcm9wID0gJ3dlYmtpdFRyYW5zZm9ybSddID09PSAnJykge1xuXHQgICAgICAgICAgICB0cmFuc2Zvcm0gPSBwcm9wO1xuXHQgICAgICAgIH1cblx0XG5cdCAgICAgICAgaWYgKHN0eWxlW3Byb3AgPSAnbXNUcmFuc2Zvcm0nXSA9PT0gJycpIHtcblx0ICAgICAgICAgICAgdHJhbnNmb3JtID0gcHJvcDtcblx0ICAgICAgICB9XG5cdFxuXHQgICAgICAgIGlmIChzdHlsZVtwcm9wID0gJ3RyYW5zZm9ybSddID09PSAnJykge1xuXHQgICAgICAgICAgICB0cmFuc2Zvcm0gPSBwcm9wO1xuXHQgICAgICAgIH1cblx0XG5cdCAgICAgICAgZG9jdW1lbnQuYm9keS5pbnNlcnRCZWZvcmUoZWwsIG51bGwpO1xuXHQgICAgICAgIHN0eWxlW3RyYW5zZm9ybV0gPSAndHJhbnNsYXRlM2QoMCwgMCwgMCknO1xuXHQgICAgICAgIGhhc1RyYW5zbGF0ZTNkID0gISFnbG9iYWwuZ2V0Q29tcHV0ZWRTdHlsZShlbCkuZ2V0UHJvcGVydHlWYWx1ZSh0cmFuc2Zvcm0pO1xuXHQgICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoZWwpO1xuXHQgICAgfSkoKTtcblx0XG5cdCAgICByZXR1cm4ge1xuXHQgICAgICAgIHRyYW5zZm9ybTogdHJhbnNmb3JtLFxuXHQgICAgICAgIHRyYW5zaXRpb246IHRyYW5zaXRpb24sXG5cdCAgICAgICAgdHJhbnNpdGlvbkVuZDogdHJhbnNpdGlvbkVuZCxcblx0ICAgICAgICBoYXNUcmFuc2xhdGUzZDogaGFzVHJhbnNsYXRlM2Rcblx0ICAgIH07XG5cdH1cblx0LyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovfS5jYWxsKGV4cG9ydHMsIChmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0oKSkpKVxuXG4vKioqLyB9LFxuLyogMyAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0J3VzZSBzdHJpY3QnO1xuXHRcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG5cdCAgICB2YWx1ZTogdHJ1ZVxuXHR9KTtcblx0ZXhwb3J0cy5kZWZhdWx0ID0gZGlzcGF0Y2hFdmVudDtcblx0XG5cdHZhciBfY3VzdG9tRXZlbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuXHRcblx0dmFyIF9jdXN0b21FdmVudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jdXN0b21FdmVudCk7XG5cdFxuXHRmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXHRcblx0LyoqXG5cdCAqIGRpc3BhdGNoIGN1c3RvbSBldmVudHNcblx0ICpcblx0ICogQHBhcmFtICB7ZWxlbWVudH0gZWwgICAgICAgICBzbGlkZXNob3cgZWxlbWVudFxuXHQgKiBAcGFyYW0gIHtzdHJpbmd9ICB0eXBlICAgICAgIGN1c3RvbSBldmVudCBuYW1lXG5cdCAqIEBwYXJhbSAge29iamVjdH0gIGRldGFpbCAgICAgY3VzdG9tIGRldGFpbCBpbmZvcm1hdGlvblxuXHQgKi9cblx0ZnVuY3Rpb24gZGlzcGF0Y2hFdmVudCh0YXJnZXQsIHR5cGUsIGRldGFpbCkge1xuXHQgICAgdmFyIGV2ZW50ID0gbmV3IF9jdXN0b21FdmVudDIuZGVmYXVsdCh0eXBlLCB7XG5cdCAgICAgICAgYnViYmxlczogdHJ1ZSxcblx0ICAgICAgICBjYW5jZWxhYmxlOiB0cnVlLFxuXHQgICAgICAgIGRldGFpbDogZGV0YWlsXG5cdCAgICB9KTtcblx0XG5cdCAgICB0YXJnZXQuZGlzcGF0Y2hFdmVudChldmVudCk7XG5cdH1cblxuLyoqKi8gfSxcbi8qIDQgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdC8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqLyhmdW5jdGlvbihnbG9iYWwpIHtcblx0dmFyIE5hdGl2ZUN1c3RvbUV2ZW50ID0gZ2xvYmFsLkN1c3RvbUV2ZW50O1xuXHRcblx0ZnVuY3Rpb24gdXNlTmF0aXZlICgpIHtcblx0ICB0cnkge1xuXHQgICAgdmFyIHAgPSBuZXcgTmF0aXZlQ3VzdG9tRXZlbnQoJ2NhdCcsIHsgZGV0YWlsOiB7IGZvbzogJ2JhcicgfSB9KTtcblx0ICAgIHJldHVybiAgJ2NhdCcgPT09IHAudHlwZSAmJiAnYmFyJyA9PT0gcC5kZXRhaWwuZm9vO1xuXHQgIH0gY2F0Y2ggKGUpIHtcblx0ICB9XG5cdCAgcmV0dXJuIGZhbHNlO1xuXHR9XG5cdFxuXHQvKipcblx0ICogQ3Jvc3MtYnJvd3NlciBgQ3VzdG9tRXZlbnRgIGNvbnN0cnVjdG9yLlxuXHQgKlxuXHQgKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQ3VzdG9tRXZlbnQuQ3VzdG9tRXZlbnRcblx0ICpcblx0ICogQHB1YmxpY1xuXHQgKi9cblx0XG5cdG1vZHVsZS5leHBvcnRzID0gdXNlTmF0aXZlKCkgPyBOYXRpdmVDdXN0b21FdmVudCA6XG5cdFxuXHQvLyBJRSA+PSA5XG5cdCdmdW5jdGlvbicgPT09IHR5cGVvZiBkb2N1bWVudC5jcmVhdGVFdmVudCA/IGZ1bmN0aW9uIEN1c3RvbUV2ZW50ICh0eXBlLCBwYXJhbXMpIHtcblx0ICB2YXIgZSA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdDdXN0b21FdmVudCcpO1xuXHQgIGlmIChwYXJhbXMpIHtcblx0ICAgIGUuaW5pdEN1c3RvbUV2ZW50KHR5cGUsIHBhcmFtcy5idWJibGVzLCBwYXJhbXMuY2FuY2VsYWJsZSwgcGFyYW1zLmRldGFpbCk7XG5cdCAgfSBlbHNlIHtcblx0ICAgIGUuaW5pdEN1c3RvbUV2ZW50KHR5cGUsIGZhbHNlLCBmYWxzZSwgdm9pZCAwKTtcblx0ICB9XG5cdCAgcmV0dXJuIGU7XG5cdH0gOlxuXHRcblx0Ly8gSUUgPD0gOFxuXHRmdW5jdGlvbiBDdXN0b21FdmVudCAodHlwZSwgcGFyYW1zKSB7XG5cdCAgdmFyIGUgPSBkb2N1bWVudC5jcmVhdGVFdmVudE9iamVjdCgpO1xuXHQgIGUudHlwZSA9IHR5cGU7XG5cdCAgaWYgKHBhcmFtcykge1xuXHQgICAgZS5idWJibGVzID0gQm9vbGVhbihwYXJhbXMuYnViYmxlcyk7XG5cdCAgICBlLmNhbmNlbGFibGUgPSBCb29sZWFuKHBhcmFtcy5jYW5jZWxhYmxlKTtcblx0ICAgIGUuZGV0YWlsID0gcGFyYW1zLmRldGFpbDtcblx0ICB9IGVsc2Uge1xuXHQgICAgZS5idWJibGVzID0gZmFsc2U7XG5cdCAgICBlLmNhbmNlbGFibGUgPSBmYWxzZTtcblx0ICAgIGUuZGV0YWlsID0gdm9pZCAwO1xuXHQgIH1cblx0ICByZXR1cm4gZTtcblx0fVxuXHRcblx0LyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovfS5jYWxsKGV4cG9ydHMsIChmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0oKSkpKVxuXG4vKioqLyB9LFxuLyogNSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0J3VzZSBzdHJpY3QnO1xuXHRcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG5cdCAgdmFsdWU6IHRydWVcblx0fSk7XG5cdGV4cG9ydHMuZGVmYXVsdCA9IHtcblx0ICAvKipcblx0ICAgKiBzbGlkZXMgc2Nyb2xsZWQgYXQgb25jZVxuXHQgICAqIEBzbGlkZXNUb1Njcm9sbCB7TnVtYmVyfVxuXHQgICAqL1xuXHQgIHNsaWRlc1RvU2Nyb2xsOiAxLFxuXHRcblx0ICAvKipcblx0ICAgKiB0aW1lIGluIG1pbGxpc2Vjb25kcyBmb3IgdGhlIGFuaW1hdGlvbiBvZiBhIHZhbGlkIHNsaWRlIGF0dGVtcHRcblx0ICAgKiBAc2xpZGVTcGVlZCB7TnVtYmVyfVxuXHQgICAqL1xuXHQgIHNsaWRlU3BlZWQ6IDMwMCxcblx0XG5cdCAgLyoqXG5cdCAgICogdGltZSBpbiBtaWxsaXNlY29uZHMgZm9yIHRoZSBhbmltYXRpb24gb2YgdGhlIHJld2luZCBhZnRlciB0aGUgbGFzdCBzbGlkZVxuXHQgICAqIEByZXdpbmRTcGVlZCB7TnVtYmVyfVxuXHQgICAqL1xuXHQgIHJld2luZFNwZWVkOiA2MDAsXG5cdFxuXHQgIC8qKlxuXHQgICAqIHRpbWUgZm9yIHRoZSBzbmFwQmFjayBvZiB0aGUgc2xpZGVyIGlmIHRoZSBzbGlkZSBhdHRlbXB0IHdhcyBub3QgdmFsaWRcblx0ICAgKiBAc25hcEJhY2tTcGVlZCB7TnVtYmVyfVxuXHQgICAqL1xuXHQgIHNuYXBCYWNrU3BlZWQ6IDIwMCxcblx0XG5cdCAgLyoqXG5cdCAgICogQmFzaWMgZWFzaW5nIGZ1bmN0aW9uczogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZGUvZG9jcy9XZWIvQ1NTL3RyYW5zaXRpb24tdGltaW5nLWZ1bmN0aW9uXG5cdCAgICogY3ViaWMgYmV6aWVyIGVhc2luZyBmdW5jdGlvbnM6IGh0dHA6Ly9lYXNpbmdzLm5ldC9kZVxuXHQgICAqIEBlYXNlIHtTdHJpbmd9XG5cdCAgICovXG5cdCAgZWFzZTogJ2Vhc2UnLFxuXHRcblx0ICAvKipcblx0ICAgKiBpZiBzbGlkZXIgcmVhY2hlZCB0aGUgbGFzdCBzbGlkZSwgd2l0aCBuZXh0IGNsaWNrIHRoZSBzbGlkZXIgZ29lcyBiYWNrIHRvIHRoZSBzdGFydGluZGV4LlxuXHQgICAqIHVzZSBpbmZpbml0ZSBvciByZXdpbmQsIG5vdCBib3RoXG5cdCAgICogQHJld2luZCB7Qm9vbGVhbn1cblx0ICAgKi9cblx0ICByZXdpbmQ6IGZhbHNlLFxuXHRcblx0ICAvKipcblx0ICAgKiBudW1iZXIgb2YgdmlzaWJsZSBzbGlkZXMgb3IgZmFsc2Vcblx0ICAgKiB1c2UgaW5maW5pdGUgb3IgcmV3aW5kLCBub3QgYm90aFxuXHQgICAqIEBpbmZpbml0ZSB7bnVtYmVyfVxuXHQgICAqL1xuXHQgIGluZmluaXRlOiBmYWxzZSxcblx0XG5cdCAgLyoqXG5cdCAgICogY2xhc3MgbmFtZSBmb3Igc2xpZGVyIGZyYW1lXG5cdCAgICogQGNsYXNzTmFtZUZyYW1lIHtzdHJpbmd9XG5cdCAgICovXG5cdCAgY2xhc3NOYW1lRnJhbWU6ICdqc19mcmFtZScsXG5cdFxuXHQgIC8qKlxuXHQgICAqIGNsYXNzIG5hbWUgZm9yIHNsaWRlcyBjb250YWluZXJcblx0ICAgKiBAY2xhc3NOYW1lU2xpZGVDb250YWluZXIge3N0cmluZ31cblx0ICAgKi9cblx0ICBjbGFzc05hbWVTbGlkZUNvbnRhaW5lcjogJ2pzX3NsaWRlcycsXG5cdFxuXHQgIC8qKlxuXHQgICAqIGNsYXNzIG5hbWUgZm9yIHNsaWRlciBwcmV2IGNvbnRyb2xcblx0ICAgKiBAY2xhc3NOYW1lUHJldkN0cmwge3N0cmluZ31cblx0ICAgKi9cblx0ICBjbGFzc05hbWVQcmV2Q3RybDogJ2pzX3ByZXYnLFxuXHRcblx0ICAvKipcblx0ICAgKiBjbGFzcyBuYW1lIGZvciBzbGlkZXIgbmV4dCBjb250cm9sXG5cdCAgICogQGNsYXNzTmFtZU5leHRDdHJsIHtzdHJpbmd9XG5cdCAgICovXG5cdCAgY2xhc3NOYW1lTmV4dEN0cmw6ICdqc19uZXh0Jyxcblx0XG5cdCAgLyoqXG5cdCAgICogY2xhc3MgbmFtZSBmb3IgY3VycmVudCBhY3RpdmUgc2xpZGVcblx0ICAgKiBpZiBlbXB0eVN0cmluZyB0aGVuIG5vIGNsYXNzIGlzIHNldFxuXHQgICAqIEBjbGFzc05hbWVBY3RpdmVTbGlkZSB7c3RyaW5nfVxuXHQgICAqL1xuXHQgIGNsYXNzTmFtZUFjdGl2ZVNsaWRlOiAnYWN0aXZlJyxcblx0XG5cdCAgLyoqXG5cdCAgICogZW5hYmxlcyBtb3VzZSBldmVudHMgZm9yIHN3aXBpbmcgb24gZGVza3RvcCBkZXZpY2VzXG5cdCAgICogQGVuYWJsZU1vdXNlRXZlbnRzIHtib29sZWFufVxuXHQgICAqL1xuXHQgIGVuYWJsZU1vdXNlRXZlbnRzOiBmYWxzZSxcblx0XG5cdCAgLyoqXG5cdCAgICogd2luZG93IGluc3RhbmNlXG5cdCAgICogQHdpbmRvdyB7b2JqZWN0fVxuXHQgICAqL1xuXHQgIHdpbmRvdzogd2luZG93LFxuXHRcblx0ICAvKipcblx0ICAgKiBJZiBmYWxzZSwgc2xpZGVzIGxvcnkgdG8gdGhlIGZpcnN0IHNsaWRlIG9uIHdpbmRvdyByZXNpemUuXG5cdCAgICogQHJld2luZE9uUmVzaXplIHtib29sZWFufVxuXHQgICAqL1xuXHQgIHJld2luZE9uUmVzaXplOiB0cnVlXG5cdH07XG5cbi8qKiovIH1cbi8qKioqKiovIF0pXG59KTtcbjtcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9sZXdpc2NvbGxhcmQvaG9yc2Vwb3dlci9ibG9iLzI5ZDQwNjg3N2Q3NDcwNWM2MWYyN2NjNjU2YTk1ZWNmZGU4NmI5ODcvYXNzZXRzL2pzLzUwLWNhcm91c2VsLmpzXG4gICAgZnVuY3Rpb24gbWFrZUNhcm91c2VsKHNlbGVjdG9yKSB7XG4gICAgICAgIHZhciBzaW1wbGUgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKTtcbiAgICAgICAgaWYgKCFzaW1wbGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbG9yeUNhcm91c2VsID0gbG9yeShzaW1wbGUsIHtcbiAgICAgICAgICAgIGluZmluaXRlOiAxLFxuICAgICAgICAgICAgZW5hYmxlTW91c2VFdmVudHM6IHRydWUsXG4gICAgICAgICAgICBjbGFzc05hbWVQcmV2Q3RybDonc2xpZGVyX19wcmV2JyxcbiAgICAgICAgICAgIGNsYXNzTmFtZU5leHRDdHJsOidzbGlkZXJfX25leHQnLFxuICAgICAgICAgICAgY2xhc3NOYW1lU2xpZGVDb250YWluZXI6ICdzbGlkZXJfX3NsaWRlcycsXG4gICAgICAgICAgICBjbGFzc05hbWVGcmFtZTogJ3NsaWRlcl9fZnJhbWUnLFxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBBdXRvcGxheVxuICAgICAgICB2YXIgdGltZXIgPSB3aW5kb3cuc2V0SW50ZXJ2YWwoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgbG9yeUNhcm91c2VsLm5leHQoKTtcbiAgICAgICAgfSwgNTAwMCk7XG5cbiAgICAgICAgZnVuY3Rpb24gY2FuY2VsVGltZXIoKSB7XG4gICAgICAgICAgICB3aW5kb3cuY2xlYXJJbnRlcnZhbCh0aW1lcik7XG4gICAgICAgIH1cblxuICAgICAgICBzaW1wbGUucXVlcnlTZWxlY3RvcignLnNsaWRlcl9fbmV4dCcpLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgY2FuY2VsVGltZXIpO1xuICAgICAgICBzaW1wbGUucXVlcnlTZWxlY3RvcignLnNsaWRlcl9fcHJldicpLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgY2FuY2VsVGltZXIpO1xuICAgICAgICBzaW1wbGUuYWRkRXZlbnRMaXN0ZW5lcignb24ubG9yeS50b3VjaHN0YXJ0JywgY2FuY2VsVGltZXIpO1xuICAgIH1cblxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIG1ha2VDYXJvdXNlbCgnLmpzX3NpbXBsZScpO1xuICAgIH0pOyJdLCJmaWxlIjoibWFpbi5taW4uanMiLCJzb3VyY2VSb290IjoiL3NvdXJjZS8ifQ==
