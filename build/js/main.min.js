jQuery(function($) {

       function cardExcerpt() {
        $(".card__excerpt").text(function(index, currentText) {
          return currentText.substr(0, 125) + '\u2026';
        });
      }
      cardExcerpt();
      function featuredTitle() {
       $(".featured__title").text(function(index, currentText) {
         return currentText.substr(0, 75) + '\u2026';
       });
     }
     featuredTitle();

    $(document).ready(function() {

            // $("#nav-mobile").html($("#nav-main").html());
            $("#nav-trigger .navicon-button").click(function() {
                console.info('Burger clicked');
                if ($(".topbar").hasClass("topbar--expanded")) {
                    $(".topbar").removeClass("topbar--expanded");
                    $(this).removeClass("open");
                } else {
                    $(".topbar").addClass("topbar--expanded");
                    $(this).addClass("open");
                }
            });

        
        var bLazy = new Blazy({
          offset: 20,
          selector: '.blazy',
          loadInvisible: false,
          breakpoints: [{
            width: 360, // Max-width
            src: 'data-src-small'
          }],
          success: function(element) {
            $(element).parent().removeClass('loading', 500);
            updateCounter();
          },
          error: function(element, msg) {
            if (msg === 'missing') {
              $(element).parent().removeClass('loading', 500); // Data-src is missing
              console.error("bLazy: data-src is missing");
            } else if (msg === 'invalid') {
              $(element).parent().removeClass('loading', 500);
              // Data-src is invalid
              console.error("bLazy: data-src is invalid");
        
            }
          }
        });
        // not needed, only here to illustrate amount of loaded images
        var imageLoaded = 0;
        
        function updateCounter() {
          imageLoaded++;
          console.info("bLazy: Images loaded: %d", imageLoaded);
        }
        
        // tabs(bLazy);

        (function() {
            var ajax_url = $('body').attr('data-ajax-url');
            var post_offset = 0;
            var incNumber = 6; // ilość postów do załadowania
        
            var projects = (function(setProjects) {
                var loaded;
                var total;
                return {
                    incLoaded: function() {
                        loaded = loaded + incNumber;
                    },
                    getLoaded: function() {
                        return loaded;
                    },
                    setLoaded: function(setProjects) {
                        loaded = setProjects;
                    },
                    setTotal: function(setProjects) {
                        total = setProjects;
                    },
                    getTotal: function() {
                        return total;
                    }
                };
            })();
            var loadingButton = (function(button){
                return {
                    showSpinner: function(button) {
                        button.html('Ładuję starsze...');
                    },
                    showCaption: function(button) {
                        button.html('Zobacz starsze');
                    },
                    hide: function(button) {
                        button.hide();
                    }
                };
            })();
        
            $('#load_more_posts').on('click', loadMore);
        
            function loadMore() {
                console.log('Clicked load_more');
                $(this).html('Ładuję...');
                post_offset = parseInt(post_offset) + 6;
                $.ajax({
                    url: ajax_url,
                    type: 'POST',
                    data: {
                        action: 'load_posts',
                        post_offset: post_offset,
                    },
                    success: function(data) {
                        $('#load_more_posts').html('Zobacz starsze');
                        $('#feed').append(data);
                        console.info('Ajax: OK');
                        bLazy.revalidate();
                        cardExcerpt();
                    }
                });
            }
        
        })();

    });
});

(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else {
		var a = factory();
		for(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];
	}
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(1);


/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; /* globals jQuery */
	
	exports.lory = lory;
	
	var _detectPrefixes = __webpack_require__(2);
	
	var _detectPrefixes2 = _interopRequireDefault(_detectPrefixes);
	
	var _dispatchEvent = __webpack_require__(3);
	
	var _dispatchEvent2 = _interopRequireDefault(_dispatchEvent);
	
	var _defaults = __webpack_require__(5);
	
	var _defaults2 = _interopRequireDefault(_defaults);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var slice = Array.prototype.slice;
	
	function lory(slider, opts) {
	    var position = void 0;
	    var slidesWidth = void 0;
	    var frameWidth = void 0;
	    var slides = void 0;
	
	    /**
	     * slider DOM elements
	     */
	    var frame = void 0;
	    var slideContainer = void 0;
	    var prevCtrl = void 0;
	    var nextCtrl = void 0;
	    var prefixes = void 0;
	    var transitionEndCallback = void 0;
	
	    var index = 0;
	    var options = {};
	
	    /**
	     * if object is jQuery convert to native DOM element
	     */
	    if (typeof jQuery !== 'undefined' && slider instanceof jQuery) {
	        slider = slider[0];
	    }
	
	    /**
	     * private
	     * set active class to element which is the current slide
	     */
	    function setActiveElement(slides, currentIndex) {
	        var _options = options;
	        var classNameActiveSlide = _options.classNameActiveSlide;
	
	
	        slides.forEach(function (element, index) {
	            if (element.classList.contains(classNameActiveSlide)) {
	                element.classList.remove(classNameActiveSlide);
	            }
	        });
	
	        slides[currentIndex].classList.add(classNameActiveSlide);
	    }
	
	    /**
	     * private
	     * setupInfinite: function to setup if infinite is set
	     *
	     * @param  {array} slideArray
	     * @return {array} array of updated slideContainer elements
	     */
	    function setupInfinite(slideArray) {
	        var _options2 = options;
	        var infinite = _options2.infinite;
	
	
	        var front = slideArray.slice(0, infinite);
	        var back = slideArray.slice(slideArray.length - infinite, slideArray.length);
	
	        front.forEach(function (element) {
	            var cloned = element.cloneNode(true);
	
	            slideContainer.appendChild(cloned);
	        });
	
	        back.reverse().forEach(function (element) {
	            var cloned = element.cloneNode(true);
	
	            slideContainer.insertBefore(cloned, slideContainer.firstChild);
	        });
	
	        slideContainer.addEventListener(prefixes.transitionEnd, onTransitionEnd);
	
	        return slice.call(slideContainer.children);
	    }
	
	    /**
	     * [dispatchSliderEvent description]
	     * @return {[type]} [description]
	     */
	    function dispatchSliderEvent(phase, type, detail) {
	        (0, _dispatchEvent2.default)(slider, phase + '.lory.' + type, detail);
	    }
	
	    /**
	     * translates to a given position in a given time in milliseconds
	     *
	     * @to        {number} number in pixels where to translate to
	     * @duration  {number} time in milliseconds for the transistion
	     * @ease      {string} easing css property
	     */
	    function translate(to, duration, ease) {
	        var style = slideContainer && slideContainer.style;
	
	        if (style) {
	            style[prefixes.transition + 'TimingFunction'] = ease;
	            style[prefixes.transition + 'Duration'] = duration + 'ms';
	
	            if (prefixes.hasTranslate3d) {
	                style[prefixes.transform] = 'translate3d(' + to + 'px, 0, 0)';
	            } else {
	                style[prefixes.transform] = 'translate(' + to + 'px, 0)';
	            }
	        }
	    }
	
	    /**
	     * slidefunction called by prev, next & touchend
	     *
	     * determine nextIndex and slide to next postion
	     * under restrictions of the defined options
	     *
	     * @direction  {boolean}
	     */
	    function slide(nextIndex, direction) {
	        var _options3 = options;
	        var slideSpeed = _options3.slideSpeed;
	        var slidesToScroll = _options3.slidesToScroll;
	        var infinite = _options3.infinite;
	        var rewind = _options3.rewind;
	        var rewindSpeed = _options3.rewindSpeed;
	        var ease = _options3.ease;
	        var classNameActiveSlide = _options3.classNameActiveSlide;
	
	
	        var duration = slideSpeed;
	
	        var nextSlide = direction ? index + 1 : index - 1;
	        var maxOffset = Math.round(slidesWidth - frameWidth);
	
	        dispatchSliderEvent('before', 'slide', {
	            index: index,
	            nextSlide: nextSlide
	        });
	
	        if (typeof nextIndex !== 'number') {
	            if (direction) {
	                nextIndex = index + slidesToScroll;
	            } else {
	                nextIndex = index - slidesToScroll;
	            }
	        }
	
	        nextIndex = Math.min(Math.max(nextIndex, 0), slides.length - 1);
	
	        if (infinite && direction === undefined) {
	            nextIndex += infinite;
	        }
	
	        var nextOffset = Math.min(Math.max(slides[nextIndex].offsetLeft * -1, maxOffset * -1), 0);
	
	        if (rewind && Math.abs(position.x) === maxOffset && direction) {
	            nextOffset = 0;
	            nextIndex = 0;
	            duration = rewindSpeed;
	        }
	
	        /**
	         * translate to the nextOffset by a defined duration and ease function
	         */
	        translate(nextOffset, duration, ease);
	
	        /**
	         * update the position with the next position
	         */
	        position.x = nextOffset;
	
	        /**
	         * update the index with the nextIndex only if
	         * the offset of the nextIndex is in the range of the maxOffset
	         */
	        if (slides[nextIndex].offsetLeft <= maxOffset) {
	            index = nextIndex;
	        }
	
	        if (infinite && (nextIndex === slides.length - infinite || nextIndex === 0)) {
	            if (direction) {
	                index = infinite;
	            }
	
	            if (!direction) {
	                index = slides.length - infinite * 2;
	            }
	
	            position.x = slides[index].offsetLeft * -1;
	
	            transitionEndCallback = function transitionEndCallback() {
	                translate(slides[index].offsetLeft * -1, 0, undefined);
	            };
	        }
	
	        if (classNameActiveSlide) {
	            setActiveElement(slice.call(slides), index);
	        }
	
	        dispatchSliderEvent('after', 'slide', {
	            currentSlide: index
	        });
	    }
	
	    /**
	     * public
	     * setup function
	     */
	    function setup() {
	        dispatchSliderEvent('before', 'init');
	
	        prefixes = (0, _detectPrefixes2.default)();
	        options = _extends({}, _defaults2.default, opts);
	
	        var _options4 = options;
	        var classNameFrame = _options4.classNameFrame;
	        var classNameSlideContainer = _options4.classNameSlideContainer;
	        var classNamePrevCtrl = _options4.classNamePrevCtrl;
	        var classNameNextCtrl = _options4.classNameNextCtrl;
	        var enableMouseEvents = _options4.enableMouseEvents;
	        var classNameActiveSlide = _options4.classNameActiveSlide;
	
	
	        frame = slider.getElementsByClassName(classNameFrame)[0];
	        slideContainer = frame.getElementsByClassName(classNameSlideContainer)[0];
	        prevCtrl = slider.getElementsByClassName(classNamePrevCtrl)[0];
	        nextCtrl = slider.getElementsByClassName(classNameNextCtrl)[0];
	
	        position = {
	            x: slideContainer.offsetLeft,
	            y: slideContainer.offsetTop
	        };
	
	        if (options.infinite) {
	            slides = setupInfinite(slice.call(slideContainer.children));
	        } else {
	            slides = slice.call(slideContainer.children);
	        }
	
	        reset();
	
	        if (classNameActiveSlide) {
	            setActiveElement(slides, index);
	        }
	
	        if (prevCtrl && nextCtrl) {
	            prevCtrl.addEventListener('click', prev);
	            nextCtrl.addEventListener('click', next);
	        }
	
	        frame.addEventListener('touchstart', onTouchstart);
	
	        if (enableMouseEvents) {
	            frame.addEventListener('mousedown', onTouchstart);
	            frame.addEventListener('click', onClick);
	        }
	
	        options.window.addEventListener('resize', onResize);
	
	        dispatchSliderEvent('after', 'init');
	    }
	
	    /**
	     * public
	     * reset function: called on resize
	     */
	    function reset() {
	        var _options5 = options;
	        var infinite = _options5.infinite;
	        var ease = _options5.ease;
	        var rewindSpeed = _options5.rewindSpeed;
	        var rewindOnResize = _options5.rewindOnResize;
	        var classNameActiveSlide = _options5.classNameActiveSlide;
	
	
	        slidesWidth = slideContainer.getBoundingClientRect().width || slideContainer.offsetWidth;
	        frameWidth = frame.getBoundingClientRect().width || frame.offsetWidth;
	
	        if (frameWidth === slidesWidth) {
	            slidesWidth = slides.reduce(function (previousValue, slide) {
	                return previousValue + slide.getBoundingClientRect().width || slide.offsetWidth;
	            }, 0);
	        }
	
	        if (rewindOnResize) {
	            index = 0;
	        } else {
	            ease = null;
	            rewindSpeed = 0;
	        }
	
	        if (infinite) {
	            translate(slides[index + infinite].offsetLeft * -1, 0, null);
	
	            index = index + infinite;
	            position.x = slides[index].offsetLeft * -1;
	        } else {
	            translate(slides[index].offsetLeft * -1, rewindSpeed, ease);
	            position.x = slides[index].offsetLeft * -1;
	        }
	
	        if (classNameActiveSlide) {
	            setActiveElement(slice.call(slides), index);
	        }
	    }
	
	    /**
	     * public
	     * slideTo: called on clickhandler
	     */
	    function slideTo(index) {
	        slide(index);
	    }
	
	    /**
	     * public
	     * returnIndex function: called on clickhandler
	     */
	    function returnIndex() {
	        return index - options.infinite || 0;
	    }
	
	    /**
	     * public
	     * prev function: called on clickhandler
	     */
	    function prev() {
	        slide(false, false);
	    }
	
	    /**
	     * public
	     * next function: called on clickhandler
	     */
	    function next() {
	        slide(false, true);
	    }
	
	    /**
	     * public
	     * destroy function: called to gracefully destroy the lory instance
	     */
	    function destroy() {
	        dispatchSliderEvent('before', 'destroy');
	
	        // remove event listeners
	        frame.removeEventListener(prefixes.transitionEnd, onTransitionEnd);
	        frame.removeEventListener('touchstart', onTouchstart);
	        frame.removeEventListener('touchmove', onTouchmove);
	        frame.removeEventListener('touchend', onTouchend);
	        frame.removeEventListener('mousemove', onTouchmove);
	        frame.removeEventListener('mousedown', onTouchstart);
	        frame.removeEventListener('mouseup', onTouchend);
	        frame.removeEventListener('mouseleave', onTouchend);
	        frame.removeEventListener('click', onClick);
	
	        options.window.removeEventListener('resize', onResize);
	
	        if (prevCtrl) {
	            prevCtrl.removeEventListener('click', prev);
	        }
	
	        if (nextCtrl) {
	            nextCtrl.removeEventListener('click', next);
	        }
	
	        // remove cloned slides if infinite is set
	        if (options.infinite) {
	            Array.apply(null, Array(options.infinite)).forEach(function () {
	                slideContainer.removeChild(slideContainer.firstChild);
	                slideContainer.removeChild(slideContainer.lastChild);
	            });
	        }
	
	        dispatchSliderEvent('after', 'destroy');
	    }
	
	    // event handling
	
	    var touchOffset = void 0;
	    var delta = void 0;
	    var isScrolling = void 0;
	
	    function onTransitionEnd() {
	        if (transitionEndCallback) {
	            transitionEndCallback();
	
	            transitionEndCallback = undefined;
	        }
	    }
	
	    function onTouchstart(event) {
	        var _options6 = options;
	        var enableMouseEvents = _options6.enableMouseEvents;
	
	        var touches = event.touches ? event.touches[0] : event;
	
	        if (enableMouseEvents) {
	            frame.addEventListener('mousemove', onTouchmove);
	            frame.addEventListener('mouseup', onTouchend);
	            frame.addEventListener('mouseleave', onTouchend);
	        }
	
	        frame.addEventListener('touchmove', onTouchmove);
	        frame.addEventListener('touchend', onTouchend);
	
	        var pageX = touches.pageX;
	        var pageY = touches.pageY;
	
	
	        touchOffset = {
	            x: pageX,
	            y: pageY,
	            time: Date.now()
	        };
	
	        isScrolling = undefined;
	
	        delta = {};
	
	        dispatchSliderEvent('on', 'touchstart', {
	            event: event
	        });
	    }
	
	    function onTouchmove(event) {
	        var touches = event.touches ? event.touches[0] : event;
	        var pageX = touches.pageX;
	        var pageY = touches.pageY;
	
	
	        delta = {
	            x: pageX - touchOffset.x,
	            y: pageY - touchOffset.y
	        };
	
	        if (typeof isScrolling === 'undefined') {
	            isScrolling = !!(isScrolling || Math.abs(delta.x) < Math.abs(delta.y));
	        }
	
	        if (!isScrolling && touchOffset) {
	            event.preventDefault();
	            translate(position.x + delta.x, 0, null);
	        }
	
	        // may be
	        dispatchSliderEvent('on', 'touchmove', {
	            event: event
	        });
	    }
	
	    function onTouchend(event) {
	        /**
	         * time between touchstart and touchend in milliseconds
	         * @duration {number}
	         */
	        var duration = touchOffset ? Date.now() - touchOffset.time : undefined;
	
	        /**
	         * is valid if:
	         *
	         * -> swipe attempt time is over 300 ms
	         * and
	         * -> swipe distance is greater than 25px
	         * or
	         * -> swipe distance is more then a third of the swipe area
	         *
	         * @isValidSlide {Boolean}
	         */
	        var isValid = Number(duration) < 300 && Math.abs(delta.x) > 25 || Math.abs(delta.x) > frameWidth / 3;
	
	        /**
	         * is out of bounds if:
	         *
	         * -> index is 0 and delta x is greater than 0
	         * or
	         * -> index is the last slide and delta is smaller than 0
	         *
	         * @isOutOfBounds {Boolean}
	         */
	        var isOutOfBounds = !index && delta.x > 0 || index === slides.length - 1 && delta.x < 0;
	
	        var direction = delta.x < 0;
	
	        if (!isScrolling) {
	            if (isValid && !isOutOfBounds) {
	                slide(false, direction);
	            } else {
	                translate(position.x, options.snapBackSpeed);
	            }
	        }
	
	        touchOffset = undefined;
	
	        /**
	         * remove eventlisteners after swipe attempt
	         */
	        frame.removeEventListener('touchmove', onTouchmove);
	        frame.removeEventListener('touchend', onTouchend);
	        frame.removeEventListener('mousemove', onTouchmove);
	        frame.removeEventListener('mouseup', onTouchend);
	        frame.removeEventListener('mouseleave', onTouchend);
	
	        dispatchSliderEvent('on', 'touchend', {
	            event: event
	        });
	    }
	
	    function onClick(event) {
	        if (delta.x) {
	            event.preventDefault();
	        }
	    }
	
	    function onResize(event) {
	        reset();
	
	        dispatchSliderEvent('on', 'resize', {
	            event: event
	        });
	    }
	
	    // trigger initial setup
	    setup();
	
	    // expose public api
	    return {
	        setup: setup,
	        reset: reset,
	        slideTo: slideTo,
	        returnIndex: returnIndex,
	        prev: prev,
	        next: next,
	        destroy: destroy
	    };
	}

/***/ },
/* 2 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = detectPrefixes;
	/**
	 * Detecting prefixes for saving time and bytes
	 */
	function detectPrefixes() {
	    var transform = void 0;
	    var transition = void 0;
	    var transitionEnd = void 0;
	    var hasTranslate3d = void 0;
	
	    (function () {
	        var el = document.createElement('_');
	        var style = el.style;
	
	        var prop = void 0;
	
	        if (style[prop = 'webkitTransition'] === '') {
	            transitionEnd = 'webkitTransitionEnd';
	            transition = prop;
	        }
	
	        if (style[prop = 'transition'] === '') {
	            transitionEnd = 'transitionend';
	            transition = prop;
	        }
	
	        if (style[prop = 'webkitTransform'] === '') {
	            transform = prop;
	        }
	
	        if (style[prop = 'msTransform'] === '') {
	            transform = prop;
	        }
	
	        if (style[prop = 'transform'] === '') {
	            transform = prop;
	        }
	
	        document.body.insertBefore(el, null);
	        style[transform] = 'translate3d(0, 0, 0)';
	        hasTranslate3d = !!global.getComputedStyle(el).getPropertyValue(transform);
	        document.body.removeChild(el);
	    })();
	
	    return {
	        transform: transform,
	        transition: transition,
	        transitionEnd: transitionEnd,
	        hasTranslate3d: hasTranslate3d
	    };
	}
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = dispatchEvent;
	
	var _customEvent = __webpack_require__(4);
	
	var _customEvent2 = _interopRequireDefault(_customEvent);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * dispatch custom events
	 *
	 * @param  {element} el         slideshow element
	 * @param  {string}  type       custom event name
	 * @param  {object}  detail     custom detail information
	 */
	function dispatchEvent(target, type, detail) {
	    var event = new _customEvent2.default(type, {
	        bubbles: true,
	        cancelable: true,
	        detail: detail
	    });
	
	    target.dispatchEvent(event);
	}

/***/ },
/* 4 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {
	var NativeCustomEvent = global.CustomEvent;
	
	function useNative () {
	  try {
	    var p = new NativeCustomEvent('cat', { detail: { foo: 'bar' } });
	    return  'cat' === p.type && 'bar' === p.detail.foo;
	  } catch (e) {
	  }
	  return false;
	}
	
	/**
	 * Cross-browser `CustomEvent` constructor.
	 *
	 * https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent.CustomEvent
	 *
	 * @public
	 */
	
	module.exports = useNative() ? NativeCustomEvent :
	
	// IE >= 9
	'function' === typeof document.createEvent ? function CustomEvent (type, params) {
	  var e = document.createEvent('CustomEvent');
	  if (params) {
	    e.initCustomEvent(type, params.bubbles, params.cancelable, params.detail);
	  } else {
	    e.initCustomEvent(type, false, false, void 0);
	  }
	  return e;
	} :
	
	// IE <= 8
	function CustomEvent (type, params) {
	  var e = document.createEventObject();
	  e.type = type;
	  if (params) {
	    e.bubbles = Boolean(params.bubbles);
	    e.cancelable = Boolean(params.cancelable);
	    e.detail = params.detail;
	  } else {
	    e.bubbles = false;
	    e.cancelable = false;
	    e.detail = void 0;
	  }
	  return e;
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 5 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = {
	  /**
	   * slides scrolled at once
	   * @slidesToScroll {Number}
	   */
	  slidesToScroll: 1,
	
	  /**
	   * time in milliseconds for the animation of a valid slide attempt
	   * @slideSpeed {Number}
	   */
	  slideSpeed: 300,
	
	  /**
	   * time in milliseconds for the animation of the rewind after the last slide
	   * @rewindSpeed {Number}
	   */
	  rewindSpeed: 600,
	
	  /**
	   * time for the snapBack of the slider if the slide attempt was not valid
	   * @snapBackSpeed {Number}
	   */
	  snapBackSpeed: 200,
	
	  /**
	   * Basic easing functions: https://developer.mozilla.org/de/docs/Web/CSS/transition-timing-function
	   * cubic bezier easing functions: http://easings.net/de
	   * @ease {String}
	   */
	  ease: 'ease',
	
	  /**
	   * if slider reached the last slide, with next click the slider goes back to the startindex.
	   * use infinite or rewind, not both
	   * @rewind {Boolean}
	   */
	  rewind: false,
	
	  /**
	   * number of visible slides or false
	   * use infinite or rewind, not both
	   * @infinite {number}
	   */
	  infinite: false,
	
	  /**
	   * class name for slider frame
	   * @classNameFrame {string}
	   */
	  classNameFrame: 'js_frame',
	
	  /**
	   * class name for slides container
	   * @classNameSlideContainer {string}
	   */
	  classNameSlideContainer: 'js_slides',
	
	  /**
	   * class name for slider prev control
	   * @classNamePrevCtrl {string}
	   */
	  classNamePrevCtrl: 'js_prev',
	
	  /**
	   * class name for slider next control
	   * @classNameNextCtrl {string}
	   */
	  classNameNextCtrl: 'js_next',
	
	  /**
	   * class name for current active slide
	   * if emptyString then no class is set
	   * @classNameActiveSlide {string}
	   */
	  classNameActiveSlide: 'active',
	
	  /**
	   * enables mouse events for swiping on desktop devices
	   * @enableMouseEvents {boolean}
	   */
	  enableMouseEvents: false,
	
	  /**
	   * window instance
	   * @window {object}
	   */
	  window: window,
	
	  /**
	   * If false, slides lory to the first slide on window resize.
	   * @rewindOnResize {boolean}
	   */
	  rewindOnResize: true
	};

/***/ }
/******/ ])
});
;

    document.addEventListener('DOMContentLoaded', function () {
        var simple = document.querySelector('.js_simple');
        console.log('ssss');
        lory(simple, {
            infinite: 1,
            enableMouseEvents: true,
            classNamePrevCtrl:'slider__prev',
            classNameNextCtrl:'slider__next',
            classNameSlideContainer: 'slider__slides',
            classNameFrame: 'slider__frame',
        });
    });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiIiwic291cmNlcyI6WyJtYWluLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImpRdWVyeShmdW5jdGlvbigkKSB7XG5cbiAgICAgICBmdW5jdGlvbiBjYXJkRXhjZXJwdCgpIHtcbiAgICAgICAgJChcIi5jYXJkX19leGNlcnB0XCIpLnRleHQoZnVuY3Rpb24oaW5kZXgsIGN1cnJlbnRUZXh0KSB7XG4gICAgICAgICAgcmV0dXJuIGN1cnJlbnRUZXh0LnN1YnN0cigwLCAxMjUpICsgJ1xcdTIwMjYnO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGNhcmRFeGNlcnB0KCk7XG4gICAgICBmdW5jdGlvbiBmZWF0dXJlZFRpdGxlKCkge1xuICAgICAgICQoXCIuZmVhdHVyZWRfX3RpdGxlXCIpLnRleHQoZnVuY3Rpb24oaW5kZXgsIGN1cnJlbnRUZXh0KSB7XG4gICAgICAgICByZXR1cm4gY3VycmVudFRleHQuc3Vic3RyKDAsIDc1KSArICdcXHUyMDI2JztcbiAgICAgICB9KTtcbiAgICAgfVxuICAgICBmZWF0dXJlZFRpdGxlKCk7XG5cbiAgICAkKGRvY3VtZW50KS5yZWFkeShmdW5jdGlvbigpIHtcblxuICAgICAgICAgICAgLy8gJChcIiNuYXYtbW9iaWxlXCIpLmh0bWwoJChcIiNuYXYtbWFpblwiKS5odG1sKCkpO1xuICAgICAgICAgICAgJChcIiNuYXYtdHJpZ2dlciAubmF2aWNvbi1idXR0b25cIikuY2xpY2soZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5pbmZvKCdCdXJnZXIgY2xpY2tlZCcpO1xuICAgICAgICAgICAgICAgIGlmICgkKFwiLnRvcGJhclwiKS5oYXNDbGFzcyhcInRvcGJhci0tZXhwYW5kZWRcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgJChcIi50b3BiYXJcIikucmVtb3ZlQ2xhc3MoXCJ0b3BiYXItLWV4cGFuZGVkXCIpO1xuICAgICAgICAgICAgICAgICAgICAkKHRoaXMpLnJlbW92ZUNsYXNzKFwib3BlblwiKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAkKFwiLnRvcGJhclwiKS5hZGRDbGFzcyhcInRvcGJhci0tZXhwYW5kZWRcIik7XG4gICAgICAgICAgICAgICAgICAgICQodGhpcykuYWRkQ2xhc3MoXCJvcGVuXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIFxuICAgICAgICB2YXIgYkxhenkgPSBuZXcgQmxhenkoe1xuICAgICAgICAgIG9mZnNldDogMjAsXG4gICAgICAgICAgc2VsZWN0b3I6ICcuYmxhenknLFxuICAgICAgICAgIGxvYWRJbnZpc2libGU6IGZhbHNlLFxuICAgICAgICAgIGJyZWFrcG9pbnRzOiBbe1xuICAgICAgICAgICAgd2lkdGg6IDM2MCwgLy8gTWF4LXdpZHRoXG4gICAgICAgICAgICBzcmM6ICdkYXRhLXNyYy1zbWFsbCdcbiAgICAgICAgICB9XSxcbiAgICAgICAgICBzdWNjZXNzOiBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICAgICAgICAkKGVsZW1lbnQpLnBhcmVudCgpLnJlbW92ZUNsYXNzKCdsb2FkaW5nJywgNTAwKTtcbiAgICAgICAgICAgIHVwZGF0ZUNvdW50ZXIoKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGVycm9yOiBmdW5jdGlvbihlbGVtZW50LCBtc2cpIHtcbiAgICAgICAgICAgIGlmIChtc2cgPT09ICdtaXNzaW5nJykge1xuICAgICAgICAgICAgICAkKGVsZW1lbnQpLnBhcmVudCgpLnJlbW92ZUNsYXNzKCdsb2FkaW5nJywgNTAwKTsgLy8gRGF0YS1zcmMgaXMgbWlzc2luZ1xuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiYkxhenk6IGRhdGEtc3JjIGlzIG1pc3NpbmdcIik7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG1zZyA9PT0gJ2ludmFsaWQnKSB7XG4gICAgICAgICAgICAgICQoZWxlbWVudCkucGFyZW50KCkucmVtb3ZlQ2xhc3MoJ2xvYWRpbmcnLCA1MDApO1xuICAgICAgICAgICAgICAvLyBEYXRhLXNyYyBpcyBpbnZhbGlkXG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJiTGF6eTogZGF0YS1zcmMgaXMgaW52YWxpZFwiKTtcbiAgICAgICAgXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gbm90IG5lZWRlZCwgb25seSBoZXJlIHRvIGlsbHVzdHJhdGUgYW1vdW50IG9mIGxvYWRlZCBpbWFnZXNcbiAgICAgICAgdmFyIGltYWdlTG9hZGVkID0gMDtcbiAgICAgICAgXG4gICAgICAgIGZ1bmN0aW9uIHVwZGF0ZUNvdW50ZXIoKSB7XG4gICAgICAgICAgaW1hZ2VMb2FkZWQrKztcbiAgICAgICAgICBjb25zb2xlLmluZm8oXCJiTGF6eTogSW1hZ2VzIGxvYWRlZDogJWRcIiwgaW1hZ2VMb2FkZWQpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyB0YWJzKGJMYXp5KTtcblxuICAgICAgICAoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgYWpheF91cmwgPSAkKCdib2R5JykuYXR0cignZGF0YS1hamF4LXVybCcpO1xuICAgICAgICAgICAgdmFyIHBvc3Rfb2Zmc2V0ID0gMDtcbiAgICAgICAgICAgIHZhciBpbmNOdW1iZXIgPSA2OyAvLyBpbG/Fm8SHIHBvc3TDs3cgZG8gemHFgmFkb3dhbmlhXG4gICAgICAgIFxuICAgICAgICAgICAgdmFyIHByb2plY3RzID0gKGZ1bmN0aW9uKHNldFByb2plY3RzKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxvYWRlZDtcbiAgICAgICAgICAgICAgICB2YXIgdG90YWw7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgaW5jTG9hZGVkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvYWRlZCA9IGxvYWRlZCArIGluY051bWJlcjtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgZ2V0TG9hZGVkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBsb2FkZWQ7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHNldExvYWRlZDogZnVuY3Rpb24oc2V0UHJvamVjdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvYWRlZCA9IHNldFByb2plY3RzO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBzZXRUb3RhbDogZnVuY3Rpb24oc2V0UHJvamVjdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvdGFsID0gc2V0UHJvamVjdHM7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGdldFRvdGFsOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0b3RhbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KSgpO1xuICAgICAgICAgICAgdmFyIGxvYWRpbmdCdXR0b24gPSAoZnVuY3Rpb24oYnV0dG9uKXtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBzaG93U3Bpbm5lcjogZnVuY3Rpb24oYnV0dG9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBidXR0b24uaHRtbCgnxYFhZHVqxJkgc3RhcnN6ZS4uLicpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBzaG93Q2FwdGlvbjogZnVuY3Rpb24oYnV0dG9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBidXR0b24uaHRtbCgnWm9iYWN6IHN0YXJzemUnKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgaGlkZTogZnVuY3Rpb24oYnV0dG9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBidXR0b24uaGlkZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pKCk7XG4gICAgICAgIFxuICAgICAgICAgICAgJCgnI2xvYWRfbW9yZV9wb3N0cycpLm9uKCdjbGljaycsIGxvYWRNb3JlKTtcbiAgICAgICAgXG4gICAgICAgICAgICBmdW5jdGlvbiBsb2FkTW9yZSgpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnQ2xpY2tlZCBsb2FkX21vcmUnKTtcbiAgICAgICAgICAgICAgICAkKHRoaXMpLmh0bWwoJ8WBYWR1asSZLi4uJyk7XG4gICAgICAgICAgICAgICAgcG9zdF9vZmZzZXQgPSBwYXJzZUludChwb3N0X29mZnNldCkgKyA2O1xuICAgICAgICAgICAgICAgICQuYWpheCh7XG4gICAgICAgICAgICAgICAgICAgIHVybDogYWpheF91cmwsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiAnbG9hZF9wb3N0cycsXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3N0X29mZnNldDogcG9zdF9vZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICQoJyNsb2FkX21vcmVfcG9zdHMnKS5odG1sKCdab2JhY3ogc3RhcnN6ZScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgJCgnI2ZlZWQnKS5hcHBlbmQoZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmluZm8oJ0FqYXg6IE9LJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBiTGF6eS5yZXZhbGlkYXRlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXJkRXhjZXJwdCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICB9KSgpO1xuXG4gICAgfSk7XG59KTtcblxuKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoW10sIGZhY3RvcnkpO1xuXHRlbHNlIHtcblx0XHR2YXIgYSA9IGZhY3RvcnkoKTtcblx0XHRmb3IodmFyIGkgaW4gYSkgKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyA/IGV4cG9ydHMgOiByb290KVtpXSA9IGFbaV07XG5cdH1cbn0pKHRoaXMsIGZ1bmN0aW9uKCkge1xucmV0dXJuIC8qKioqKiovIChmdW5jdGlvbihtb2R1bGVzKSB7IC8vIHdlYnBhY2tCb290c3RyYXBcbi8qKioqKiovIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbi8qKioqKiovIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbi8qKioqKiovIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSlcbi8qKioqKiovIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuLyoqKioqKi8gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbi8qKioqKiovIFx0XHRcdGV4cG9ydHM6IHt9LFxuLyoqKioqKi8gXHRcdFx0aWQ6IG1vZHVsZUlkLFxuLyoqKioqKi8gXHRcdFx0bG9hZGVkOiBmYWxzZVxuLyoqKioqKi8gXHRcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuLyoqKioqKi8gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4vKioqKioqLyBcdFx0bW9kdWxlLmxvYWRlZCA9IHRydWU7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4vKioqKioqLyBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gXHR9XG4vKioqKioqL1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4vKioqKioqLyBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuLyoqKioqKi8gfSlcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqLyAoW1xuLyogMCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0bW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG5cbi8qKiovIH0sXG4vKiAxICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQndXNlIHN0cmljdCc7XG5cdFxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcblx0ICAgIHZhbHVlOiB0cnVlXG5cdH0pO1xuXHRcblx0dmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTsgLyogZ2xvYmFscyBqUXVlcnkgKi9cblx0XG5cdGV4cG9ydHMubG9yeSA9IGxvcnk7XG5cdFxuXHR2YXIgX2RldGVjdFByZWZpeGVzID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcblx0XG5cdHZhciBfZGV0ZWN0UHJlZml4ZXMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZGV0ZWN0UHJlZml4ZXMpO1xuXHRcblx0dmFyIF9kaXNwYXRjaEV2ZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcblx0XG5cdHZhciBfZGlzcGF0Y2hFdmVudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9kaXNwYXRjaEV2ZW50KTtcblx0XG5cdHZhciBfZGVmYXVsdHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xuXHRcblx0dmFyIF9kZWZhdWx0czIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9kZWZhdWx0cyk7XG5cdFxuXHRmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXHRcblx0dmFyIHNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xuXHRcblx0ZnVuY3Rpb24gbG9yeShzbGlkZXIsIG9wdHMpIHtcblx0ICAgIHZhciBwb3NpdGlvbiA9IHZvaWQgMDtcblx0ICAgIHZhciBzbGlkZXNXaWR0aCA9IHZvaWQgMDtcblx0ICAgIHZhciBmcmFtZVdpZHRoID0gdm9pZCAwO1xuXHQgICAgdmFyIHNsaWRlcyA9IHZvaWQgMDtcblx0XG5cdCAgICAvKipcblx0ICAgICAqIHNsaWRlciBET00gZWxlbWVudHNcblx0ICAgICAqL1xuXHQgICAgdmFyIGZyYW1lID0gdm9pZCAwO1xuXHQgICAgdmFyIHNsaWRlQ29udGFpbmVyID0gdm9pZCAwO1xuXHQgICAgdmFyIHByZXZDdHJsID0gdm9pZCAwO1xuXHQgICAgdmFyIG5leHRDdHJsID0gdm9pZCAwO1xuXHQgICAgdmFyIHByZWZpeGVzID0gdm9pZCAwO1xuXHQgICAgdmFyIHRyYW5zaXRpb25FbmRDYWxsYmFjayA9IHZvaWQgMDtcblx0XG5cdCAgICB2YXIgaW5kZXggPSAwO1xuXHQgICAgdmFyIG9wdGlvbnMgPSB7fTtcblx0XG5cdCAgICAvKipcblx0ICAgICAqIGlmIG9iamVjdCBpcyBqUXVlcnkgY29udmVydCB0byBuYXRpdmUgRE9NIGVsZW1lbnRcblx0ICAgICAqL1xuXHQgICAgaWYgKHR5cGVvZiBqUXVlcnkgIT09ICd1bmRlZmluZWQnICYmIHNsaWRlciBpbnN0YW5jZW9mIGpRdWVyeSkge1xuXHQgICAgICAgIHNsaWRlciA9IHNsaWRlclswXTtcblx0ICAgIH1cblx0XG5cdCAgICAvKipcblx0ICAgICAqIHByaXZhdGVcblx0ICAgICAqIHNldCBhY3RpdmUgY2xhc3MgdG8gZWxlbWVudCB3aGljaCBpcyB0aGUgY3VycmVudCBzbGlkZVxuXHQgICAgICovXG5cdCAgICBmdW5jdGlvbiBzZXRBY3RpdmVFbGVtZW50KHNsaWRlcywgY3VycmVudEluZGV4KSB7XG5cdCAgICAgICAgdmFyIF9vcHRpb25zID0gb3B0aW9ucztcblx0ICAgICAgICB2YXIgY2xhc3NOYW1lQWN0aXZlU2xpZGUgPSBfb3B0aW9ucy5jbGFzc05hbWVBY3RpdmVTbGlkZTtcblx0XG5cdFxuXHQgICAgICAgIHNsaWRlcy5mb3JFYWNoKGZ1bmN0aW9uIChlbGVtZW50LCBpbmRleCkge1xuXHQgICAgICAgICAgICBpZiAoZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoY2xhc3NOYW1lQWN0aXZlU2xpZGUpKSB7XG5cdCAgICAgICAgICAgICAgICBlbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoY2xhc3NOYW1lQWN0aXZlU2xpZGUpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSk7XG5cdFxuXHQgICAgICAgIHNsaWRlc1tjdXJyZW50SW5kZXhdLmNsYXNzTGlzdC5hZGQoY2xhc3NOYW1lQWN0aXZlU2xpZGUpO1xuXHQgICAgfVxuXHRcblx0ICAgIC8qKlxuXHQgICAgICogcHJpdmF0ZVxuXHQgICAgICogc2V0dXBJbmZpbml0ZTogZnVuY3Rpb24gdG8gc2V0dXAgaWYgaW5maW5pdGUgaXMgc2V0XG5cdCAgICAgKlxuXHQgICAgICogQHBhcmFtICB7YXJyYXl9IHNsaWRlQXJyYXlcblx0ICAgICAqIEByZXR1cm4ge2FycmF5fSBhcnJheSBvZiB1cGRhdGVkIHNsaWRlQ29udGFpbmVyIGVsZW1lbnRzXG5cdCAgICAgKi9cblx0ICAgIGZ1bmN0aW9uIHNldHVwSW5maW5pdGUoc2xpZGVBcnJheSkge1xuXHQgICAgICAgIHZhciBfb3B0aW9uczIgPSBvcHRpb25zO1xuXHQgICAgICAgIHZhciBpbmZpbml0ZSA9IF9vcHRpb25zMi5pbmZpbml0ZTtcblx0XG5cdFxuXHQgICAgICAgIHZhciBmcm9udCA9IHNsaWRlQXJyYXkuc2xpY2UoMCwgaW5maW5pdGUpO1xuXHQgICAgICAgIHZhciBiYWNrID0gc2xpZGVBcnJheS5zbGljZShzbGlkZUFycmF5Lmxlbmd0aCAtIGluZmluaXRlLCBzbGlkZUFycmF5Lmxlbmd0aCk7XG5cdFxuXHQgICAgICAgIGZyb250LmZvckVhY2goZnVuY3Rpb24gKGVsZW1lbnQpIHtcblx0ICAgICAgICAgICAgdmFyIGNsb25lZCA9IGVsZW1lbnQuY2xvbmVOb2RlKHRydWUpO1xuXHRcblx0ICAgICAgICAgICAgc2xpZGVDb250YWluZXIuYXBwZW5kQ2hpbGQoY2xvbmVkKTtcblx0ICAgICAgICB9KTtcblx0XG5cdCAgICAgICAgYmFjay5yZXZlcnNlKCkuZm9yRWFjaChmdW5jdGlvbiAoZWxlbWVudCkge1xuXHQgICAgICAgICAgICB2YXIgY2xvbmVkID0gZWxlbWVudC5jbG9uZU5vZGUodHJ1ZSk7XG5cdFxuXHQgICAgICAgICAgICBzbGlkZUNvbnRhaW5lci5pbnNlcnRCZWZvcmUoY2xvbmVkLCBzbGlkZUNvbnRhaW5lci5maXJzdENoaWxkKTtcblx0ICAgICAgICB9KTtcblx0XG5cdCAgICAgICAgc2xpZGVDb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcihwcmVmaXhlcy50cmFuc2l0aW9uRW5kLCBvblRyYW5zaXRpb25FbmQpO1xuXHRcblx0ICAgICAgICByZXR1cm4gc2xpY2UuY2FsbChzbGlkZUNvbnRhaW5lci5jaGlsZHJlbik7XG5cdCAgICB9XG5cdFxuXHQgICAgLyoqXG5cdCAgICAgKiBbZGlzcGF0Y2hTbGlkZXJFdmVudCBkZXNjcmlwdGlvbl1cblx0ICAgICAqIEByZXR1cm4ge1t0eXBlXX0gW2Rlc2NyaXB0aW9uXVxuXHQgICAgICovXG5cdCAgICBmdW5jdGlvbiBkaXNwYXRjaFNsaWRlckV2ZW50KHBoYXNlLCB0eXBlLCBkZXRhaWwpIHtcblx0ICAgICAgICAoMCwgX2Rpc3BhdGNoRXZlbnQyLmRlZmF1bHQpKHNsaWRlciwgcGhhc2UgKyAnLmxvcnkuJyArIHR5cGUsIGRldGFpbCk7XG5cdCAgICB9XG5cdFxuXHQgICAgLyoqXG5cdCAgICAgKiB0cmFuc2xhdGVzIHRvIGEgZ2l2ZW4gcG9zaXRpb24gaW4gYSBnaXZlbiB0aW1lIGluIG1pbGxpc2Vjb25kc1xuXHQgICAgICpcblx0ICAgICAqIEB0byAgICAgICAge251bWJlcn0gbnVtYmVyIGluIHBpeGVscyB3aGVyZSB0byB0cmFuc2xhdGUgdG9cblx0ICAgICAqIEBkdXJhdGlvbiAge251bWJlcn0gdGltZSBpbiBtaWxsaXNlY29uZHMgZm9yIHRoZSB0cmFuc2lzdGlvblxuXHQgICAgICogQGVhc2UgICAgICB7c3RyaW5nfSBlYXNpbmcgY3NzIHByb3BlcnR5XG5cdCAgICAgKi9cblx0ICAgIGZ1bmN0aW9uIHRyYW5zbGF0ZSh0bywgZHVyYXRpb24sIGVhc2UpIHtcblx0ICAgICAgICB2YXIgc3R5bGUgPSBzbGlkZUNvbnRhaW5lciAmJiBzbGlkZUNvbnRhaW5lci5zdHlsZTtcblx0XG5cdCAgICAgICAgaWYgKHN0eWxlKSB7XG5cdCAgICAgICAgICAgIHN0eWxlW3ByZWZpeGVzLnRyYW5zaXRpb24gKyAnVGltaW5nRnVuY3Rpb24nXSA9IGVhc2U7XG5cdCAgICAgICAgICAgIHN0eWxlW3ByZWZpeGVzLnRyYW5zaXRpb24gKyAnRHVyYXRpb24nXSA9IGR1cmF0aW9uICsgJ21zJztcblx0XG5cdCAgICAgICAgICAgIGlmIChwcmVmaXhlcy5oYXNUcmFuc2xhdGUzZCkge1xuXHQgICAgICAgICAgICAgICAgc3R5bGVbcHJlZml4ZXMudHJhbnNmb3JtXSA9ICd0cmFuc2xhdGUzZCgnICsgdG8gKyAncHgsIDAsIDApJztcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIHN0eWxlW3ByZWZpeGVzLnRyYW5zZm9ybV0gPSAndHJhbnNsYXRlKCcgKyB0byArICdweCwgMCknO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXHRcblx0ICAgIC8qKlxuXHQgICAgICogc2xpZGVmdW5jdGlvbiBjYWxsZWQgYnkgcHJldiwgbmV4dCAmIHRvdWNoZW5kXG5cdCAgICAgKlxuXHQgICAgICogZGV0ZXJtaW5lIG5leHRJbmRleCBhbmQgc2xpZGUgdG8gbmV4dCBwb3N0aW9uXG5cdCAgICAgKiB1bmRlciByZXN0cmljdGlvbnMgb2YgdGhlIGRlZmluZWQgb3B0aW9uc1xuXHQgICAgICpcblx0ICAgICAqIEBkaXJlY3Rpb24gIHtib29sZWFufVxuXHQgICAgICovXG5cdCAgICBmdW5jdGlvbiBzbGlkZShuZXh0SW5kZXgsIGRpcmVjdGlvbikge1xuXHQgICAgICAgIHZhciBfb3B0aW9uczMgPSBvcHRpb25zO1xuXHQgICAgICAgIHZhciBzbGlkZVNwZWVkID0gX29wdGlvbnMzLnNsaWRlU3BlZWQ7XG5cdCAgICAgICAgdmFyIHNsaWRlc1RvU2Nyb2xsID0gX29wdGlvbnMzLnNsaWRlc1RvU2Nyb2xsO1xuXHQgICAgICAgIHZhciBpbmZpbml0ZSA9IF9vcHRpb25zMy5pbmZpbml0ZTtcblx0ICAgICAgICB2YXIgcmV3aW5kID0gX29wdGlvbnMzLnJld2luZDtcblx0ICAgICAgICB2YXIgcmV3aW5kU3BlZWQgPSBfb3B0aW9uczMucmV3aW5kU3BlZWQ7XG5cdCAgICAgICAgdmFyIGVhc2UgPSBfb3B0aW9uczMuZWFzZTtcblx0ICAgICAgICB2YXIgY2xhc3NOYW1lQWN0aXZlU2xpZGUgPSBfb3B0aW9uczMuY2xhc3NOYW1lQWN0aXZlU2xpZGU7XG5cdFxuXHRcblx0ICAgICAgICB2YXIgZHVyYXRpb24gPSBzbGlkZVNwZWVkO1xuXHRcblx0ICAgICAgICB2YXIgbmV4dFNsaWRlID0gZGlyZWN0aW9uID8gaW5kZXggKyAxIDogaW5kZXggLSAxO1xuXHQgICAgICAgIHZhciBtYXhPZmZzZXQgPSBNYXRoLnJvdW5kKHNsaWRlc1dpZHRoIC0gZnJhbWVXaWR0aCk7XG5cdFxuXHQgICAgICAgIGRpc3BhdGNoU2xpZGVyRXZlbnQoJ2JlZm9yZScsICdzbGlkZScsIHtcblx0ICAgICAgICAgICAgaW5kZXg6IGluZGV4LFxuXHQgICAgICAgICAgICBuZXh0U2xpZGU6IG5leHRTbGlkZVxuXHQgICAgICAgIH0pO1xuXHRcblx0ICAgICAgICBpZiAodHlwZW9mIG5leHRJbmRleCAhPT0gJ251bWJlcicpIHtcblx0ICAgICAgICAgICAgaWYgKGRpcmVjdGlvbikge1xuXHQgICAgICAgICAgICAgICAgbmV4dEluZGV4ID0gaW5kZXggKyBzbGlkZXNUb1Njcm9sbDtcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIG5leHRJbmRleCA9IGluZGV4IC0gc2xpZGVzVG9TY3JvbGw7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdFxuXHQgICAgICAgIG5leHRJbmRleCA9IE1hdGgubWluKE1hdGgubWF4KG5leHRJbmRleCwgMCksIHNsaWRlcy5sZW5ndGggLSAxKTtcblx0XG5cdCAgICAgICAgaWYgKGluZmluaXRlICYmIGRpcmVjdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgICAgICAgIG5leHRJbmRleCArPSBpbmZpbml0ZTtcblx0ICAgICAgICB9XG5cdFxuXHQgICAgICAgIHZhciBuZXh0T2Zmc2V0ID0gTWF0aC5taW4oTWF0aC5tYXgoc2xpZGVzW25leHRJbmRleF0ub2Zmc2V0TGVmdCAqIC0xLCBtYXhPZmZzZXQgKiAtMSksIDApO1xuXHRcblx0ICAgICAgICBpZiAocmV3aW5kICYmIE1hdGguYWJzKHBvc2l0aW9uLngpID09PSBtYXhPZmZzZXQgJiYgZGlyZWN0aW9uKSB7XG5cdCAgICAgICAgICAgIG5leHRPZmZzZXQgPSAwO1xuXHQgICAgICAgICAgICBuZXh0SW5kZXggPSAwO1xuXHQgICAgICAgICAgICBkdXJhdGlvbiA9IHJld2luZFNwZWVkO1xuXHQgICAgICAgIH1cblx0XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogdHJhbnNsYXRlIHRvIHRoZSBuZXh0T2Zmc2V0IGJ5IGEgZGVmaW5lZCBkdXJhdGlvbiBhbmQgZWFzZSBmdW5jdGlvblxuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHRyYW5zbGF0ZShuZXh0T2Zmc2V0LCBkdXJhdGlvbiwgZWFzZSk7XG5cdFxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIHVwZGF0ZSB0aGUgcG9zaXRpb24gd2l0aCB0aGUgbmV4dCBwb3NpdGlvblxuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHBvc2l0aW9uLnggPSBuZXh0T2Zmc2V0O1xuXHRcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiB1cGRhdGUgdGhlIGluZGV4IHdpdGggdGhlIG5leHRJbmRleCBvbmx5IGlmXG5cdCAgICAgICAgICogdGhlIG9mZnNldCBvZiB0aGUgbmV4dEluZGV4IGlzIGluIHRoZSByYW5nZSBvZiB0aGUgbWF4T2Zmc2V0XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgaWYgKHNsaWRlc1tuZXh0SW5kZXhdLm9mZnNldExlZnQgPD0gbWF4T2Zmc2V0KSB7XG5cdCAgICAgICAgICAgIGluZGV4ID0gbmV4dEluZGV4O1xuXHQgICAgICAgIH1cblx0XG5cdCAgICAgICAgaWYgKGluZmluaXRlICYmIChuZXh0SW5kZXggPT09IHNsaWRlcy5sZW5ndGggLSBpbmZpbml0ZSB8fCBuZXh0SW5kZXggPT09IDApKSB7XG5cdCAgICAgICAgICAgIGlmIChkaXJlY3Rpb24pIHtcblx0ICAgICAgICAgICAgICAgIGluZGV4ID0gaW5maW5pdGU7XG5cdCAgICAgICAgICAgIH1cblx0XG5cdCAgICAgICAgICAgIGlmICghZGlyZWN0aW9uKSB7XG5cdCAgICAgICAgICAgICAgICBpbmRleCA9IHNsaWRlcy5sZW5ndGggLSBpbmZpbml0ZSAqIDI7XG5cdCAgICAgICAgICAgIH1cblx0XG5cdCAgICAgICAgICAgIHBvc2l0aW9uLnggPSBzbGlkZXNbaW5kZXhdLm9mZnNldExlZnQgKiAtMTtcblx0XG5cdCAgICAgICAgICAgIHRyYW5zaXRpb25FbmRDYWxsYmFjayA9IGZ1bmN0aW9uIHRyYW5zaXRpb25FbmRDYWxsYmFjaygpIHtcblx0ICAgICAgICAgICAgICAgIHRyYW5zbGF0ZShzbGlkZXNbaW5kZXhdLm9mZnNldExlZnQgKiAtMSwgMCwgdW5kZWZpbmVkKTtcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICB9XG5cdFxuXHQgICAgICAgIGlmIChjbGFzc05hbWVBY3RpdmVTbGlkZSkge1xuXHQgICAgICAgICAgICBzZXRBY3RpdmVFbGVtZW50KHNsaWNlLmNhbGwoc2xpZGVzKSwgaW5kZXgpO1xuXHQgICAgICAgIH1cblx0XG5cdCAgICAgICAgZGlzcGF0Y2hTbGlkZXJFdmVudCgnYWZ0ZXInLCAnc2xpZGUnLCB7XG5cdCAgICAgICAgICAgIGN1cnJlbnRTbGlkZTogaW5kZXhcblx0ICAgICAgICB9KTtcblx0ICAgIH1cblx0XG5cdCAgICAvKipcblx0ICAgICAqIHB1YmxpY1xuXHQgICAgICogc2V0dXAgZnVuY3Rpb25cblx0ICAgICAqL1xuXHQgICAgZnVuY3Rpb24gc2V0dXAoKSB7XG5cdCAgICAgICAgZGlzcGF0Y2hTbGlkZXJFdmVudCgnYmVmb3JlJywgJ2luaXQnKTtcblx0XG5cdCAgICAgICAgcHJlZml4ZXMgPSAoMCwgX2RldGVjdFByZWZpeGVzMi5kZWZhdWx0KSgpO1xuXHQgICAgICAgIG9wdGlvbnMgPSBfZXh0ZW5kcyh7fSwgX2RlZmF1bHRzMi5kZWZhdWx0LCBvcHRzKTtcblx0XG5cdCAgICAgICAgdmFyIF9vcHRpb25zNCA9IG9wdGlvbnM7XG5cdCAgICAgICAgdmFyIGNsYXNzTmFtZUZyYW1lID0gX29wdGlvbnM0LmNsYXNzTmFtZUZyYW1lO1xuXHQgICAgICAgIHZhciBjbGFzc05hbWVTbGlkZUNvbnRhaW5lciA9IF9vcHRpb25zNC5jbGFzc05hbWVTbGlkZUNvbnRhaW5lcjtcblx0ICAgICAgICB2YXIgY2xhc3NOYW1lUHJldkN0cmwgPSBfb3B0aW9uczQuY2xhc3NOYW1lUHJldkN0cmw7XG5cdCAgICAgICAgdmFyIGNsYXNzTmFtZU5leHRDdHJsID0gX29wdGlvbnM0LmNsYXNzTmFtZU5leHRDdHJsO1xuXHQgICAgICAgIHZhciBlbmFibGVNb3VzZUV2ZW50cyA9IF9vcHRpb25zNC5lbmFibGVNb3VzZUV2ZW50cztcblx0ICAgICAgICB2YXIgY2xhc3NOYW1lQWN0aXZlU2xpZGUgPSBfb3B0aW9uczQuY2xhc3NOYW1lQWN0aXZlU2xpZGU7XG5cdFxuXHRcblx0ICAgICAgICBmcmFtZSA9IHNsaWRlci5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKGNsYXNzTmFtZUZyYW1lKVswXTtcblx0ICAgICAgICBzbGlkZUNvbnRhaW5lciA9IGZyYW1lLmdldEVsZW1lbnRzQnlDbGFzc05hbWUoY2xhc3NOYW1lU2xpZGVDb250YWluZXIpWzBdO1xuXHQgICAgICAgIHByZXZDdHJsID0gc2xpZGVyLmdldEVsZW1lbnRzQnlDbGFzc05hbWUoY2xhc3NOYW1lUHJldkN0cmwpWzBdO1xuXHQgICAgICAgIG5leHRDdHJsID0gc2xpZGVyLmdldEVsZW1lbnRzQnlDbGFzc05hbWUoY2xhc3NOYW1lTmV4dEN0cmwpWzBdO1xuXHRcblx0ICAgICAgICBwb3NpdGlvbiA9IHtcblx0ICAgICAgICAgICAgeDogc2xpZGVDb250YWluZXIub2Zmc2V0TGVmdCxcblx0ICAgICAgICAgICAgeTogc2xpZGVDb250YWluZXIub2Zmc2V0VG9wXG5cdCAgICAgICAgfTtcblx0XG5cdCAgICAgICAgaWYgKG9wdGlvbnMuaW5maW5pdGUpIHtcblx0ICAgICAgICAgICAgc2xpZGVzID0gc2V0dXBJbmZpbml0ZShzbGljZS5jYWxsKHNsaWRlQ29udGFpbmVyLmNoaWxkcmVuKSk7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgc2xpZGVzID0gc2xpY2UuY2FsbChzbGlkZUNvbnRhaW5lci5jaGlsZHJlbik7XG5cdCAgICAgICAgfVxuXHRcblx0ICAgICAgICByZXNldCgpO1xuXHRcblx0ICAgICAgICBpZiAoY2xhc3NOYW1lQWN0aXZlU2xpZGUpIHtcblx0ICAgICAgICAgICAgc2V0QWN0aXZlRWxlbWVudChzbGlkZXMsIGluZGV4KTtcblx0ICAgICAgICB9XG5cdFxuXHQgICAgICAgIGlmIChwcmV2Q3RybCAmJiBuZXh0Q3RybCkge1xuXHQgICAgICAgICAgICBwcmV2Q3RybC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHByZXYpO1xuXHQgICAgICAgICAgICBuZXh0Q3RybC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIG5leHQpO1xuXHQgICAgICAgIH1cblx0XG5cdCAgICAgICAgZnJhbWUuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIG9uVG91Y2hzdGFydCk7XG5cdFxuXHQgICAgICAgIGlmIChlbmFibGVNb3VzZUV2ZW50cykge1xuXHQgICAgICAgICAgICBmcmFtZS5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBvblRvdWNoc3RhcnQpO1xuXHQgICAgICAgICAgICBmcmFtZS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIG9uQ2xpY2spO1xuXHQgICAgICAgIH1cblx0XG5cdCAgICAgICAgb3B0aW9ucy53aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgb25SZXNpemUpO1xuXHRcblx0ICAgICAgICBkaXNwYXRjaFNsaWRlckV2ZW50KCdhZnRlcicsICdpbml0Jyk7XG5cdCAgICB9XG5cdFxuXHQgICAgLyoqXG5cdCAgICAgKiBwdWJsaWNcblx0ICAgICAqIHJlc2V0IGZ1bmN0aW9uOiBjYWxsZWQgb24gcmVzaXplXG5cdCAgICAgKi9cblx0ICAgIGZ1bmN0aW9uIHJlc2V0KCkge1xuXHQgICAgICAgIHZhciBfb3B0aW9uczUgPSBvcHRpb25zO1xuXHQgICAgICAgIHZhciBpbmZpbml0ZSA9IF9vcHRpb25zNS5pbmZpbml0ZTtcblx0ICAgICAgICB2YXIgZWFzZSA9IF9vcHRpb25zNS5lYXNlO1xuXHQgICAgICAgIHZhciByZXdpbmRTcGVlZCA9IF9vcHRpb25zNS5yZXdpbmRTcGVlZDtcblx0ICAgICAgICB2YXIgcmV3aW5kT25SZXNpemUgPSBfb3B0aW9uczUucmV3aW5kT25SZXNpemU7XG5cdCAgICAgICAgdmFyIGNsYXNzTmFtZUFjdGl2ZVNsaWRlID0gX29wdGlvbnM1LmNsYXNzTmFtZUFjdGl2ZVNsaWRlO1xuXHRcblx0XG5cdCAgICAgICAgc2xpZGVzV2lkdGggPSBzbGlkZUNvbnRhaW5lci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aCB8fCBzbGlkZUNvbnRhaW5lci5vZmZzZXRXaWR0aDtcblx0ICAgICAgICBmcmFtZVdpZHRoID0gZnJhbWUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGggfHwgZnJhbWUub2Zmc2V0V2lkdGg7XG5cdFxuXHQgICAgICAgIGlmIChmcmFtZVdpZHRoID09PSBzbGlkZXNXaWR0aCkge1xuXHQgICAgICAgICAgICBzbGlkZXNXaWR0aCA9IHNsaWRlcy5yZWR1Y2UoZnVuY3Rpb24gKHByZXZpb3VzVmFsdWUsIHNsaWRlKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gcHJldmlvdXNWYWx1ZSArIHNsaWRlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoIHx8IHNsaWRlLm9mZnNldFdpZHRoO1xuXHQgICAgICAgICAgICB9LCAwKTtcblx0ICAgICAgICB9XG5cdFxuXHQgICAgICAgIGlmIChyZXdpbmRPblJlc2l6ZSkge1xuXHQgICAgICAgICAgICBpbmRleCA9IDA7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgZWFzZSA9IG51bGw7XG5cdCAgICAgICAgICAgIHJld2luZFNwZWVkID0gMDtcblx0ICAgICAgICB9XG5cdFxuXHQgICAgICAgIGlmIChpbmZpbml0ZSkge1xuXHQgICAgICAgICAgICB0cmFuc2xhdGUoc2xpZGVzW2luZGV4ICsgaW5maW5pdGVdLm9mZnNldExlZnQgKiAtMSwgMCwgbnVsbCk7XG5cdFxuXHQgICAgICAgICAgICBpbmRleCA9IGluZGV4ICsgaW5maW5pdGU7XG5cdCAgICAgICAgICAgIHBvc2l0aW9uLnggPSBzbGlkZXNbaW5kZXhdLm9mZnNldExlZnQgKiAtMTtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICB0cmFuc2xhdGUoc2xpZGVzW2luZGV4XS5vZmZzZXRMZWZ0ICogLTEsIHJld2luZFNwZWVkLCBlYXNlKTtcblx0ICAgICAgICAgICAgcG9zaXRpb24ueCA9IHNsaWRlc1tpbmRleF0ub2Zmc2V0TGVmdCAqIC0xO1xuXHQgICAgICAgIH1cblx0XG5cdCAgICAgICAgaWYgKGNsYXNzTmFtZUFjdGl2ZVNsaWRlKSB7XG5cdCAgICAgICAgICAgIHNldEFjdGl2ZUVsZW1lbnQoc2xpY2UuY2FsbChzbGlkZXMpLCBpbmRleCk7XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXHRcblx0ICAgIC8qKlxuXHQgICAgICogcHVibGljXG5cdCAgICAgKiBzbGlkZVRvOiBjYWxsZWQgb24gY2xpY2toYW5kbGVyXG5cdCAgICAgKi9cblx0ICAgIGZ1bmN0aW9uIHNsaWRlVG8oaW5kZXgpIHtcblx0ICAgICAgICBzbGlkZShpbmRleCk7XG5cdCAgICB9XG5cdFxuXHQgICAgLyoqXG5cdCAgICAgKiBwdWJsaWNcblx0ICAgICAqIHJldHVybkluZGV4IGZ1bmN0aW9uOiBjYWxsZWQgb24gY2xpY2toYW5kbGVyXG5cdCAgICAgKi9cblx0ICAgIGZ1bmN0aW9uIHJldHVybkluZGV4KCkge1xuXHQgICAgICAgIHJldHVybiBpbmRleCAtIG9wdGlvbnMuaW5maW5pdGUgfHwgMDtcblx0ICAgIH1cblx0XG5cdCAgICAvKipcblx0ICAgICAqIHB1YmxpY1xuXHQgICAgICogcHJldiBmdW5jdGlvbjogY2FsbGVkIG9uIGNsaWNraGFuZGxlclxuXHQgICAgICovXG5cdCAgICBmdW5jdGlvbiBwcmV2KCkge1xuXHQgICAgICAgIHNsaWRlKGZhbHNlLCBmYWxzZSk7XG5cdCAgICB9XG5cdFxuXHQgICAgLyoqXG5cdCAgICAgKiBwdWJsaWNcblx0ICAgICAqIG5leHQgZnVuY3Rpb246IGNhbGxlZCBvbiBjbGlja2hhbmRsZXJcblx0ICAgICAqL1xuXHQgICAgZnVuY3Rpb24gbmV4dCgpIHtcblx0ICAgICAgICBzbGlkZShmYWxzZSwgdHJ1ZSk7XG5cdCAgICB9XG5cdFxuXHQgICAgLyoqXG5cdCAgICAgKiBwdWJsaWNcblx0ICAgICAqIGRlc3Ryb3kgZnVuY3Rpb246IGNhbGxlZCB0byBncmFjZWZ1bGx5IGRlc3Ryb3kgdGhlIGxvcnkgaW5zdGFuY2Vcblx0ICAgICAqL1xuXHQgICAgZnVuY3Rpb24gZGVzdHJveSgpIHtcblx0ICAgICAgICBkaXNwYXRjaFNsaWRlckV2ZW50KCdiZWZvcmUnLCAnZGVzdHJveScpO1xuXHRcblx0ICAgICAgICAvLyByZW1vdmUgZXZlbnQgbGlzdGVuZXJzXG5cdCAgICAgICAgZnJhbWUucmVtb3ZlRXZlbnRMaXN0ZW5lcihwcmVmaXhlcy50cmFuc2l0aW9uRW5kLCBvblRyYW5zaXRpb25FbmQpO1xuXHQgICAgICAgIGZyYW1lLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCBvblRvdWNoc3RhcnQpO1xuXHQgICAgICAgIGZyYW1lLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIG9uVG91Y2htb3ZlKTtcblx0ICAgICAgICBmcmFtZS5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIG9uVG91Y2hlbmQpO1xuXHQgICAgICAgIGZyYW1lLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIG9uVG91Y2htb3ZlKTtcblx0ICAgICAgICBmcmFtZS5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBvblRvdWNoc3RhcnQpO1xuXHQgICAgICAgIGZyYW1lLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBvblRvdWNoZW5kKTtcblx0ICAgICAgICBmcmFtZS5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWxlYXZlJywgb25Ub3VjaGVuZCk7XG5cdCAgICAgICAgZnJhbWUucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCBvbkNsaWNrKTtcblx0XG5cdCAgICAgICAgb3B0aW9ucy53aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgb25SZXNpemUpO1xuXHRcblx0ICAgICAgICBpZiAocHJldkN0cmwpIHtcblx0ICAgICAgICAgICAgcHJldkN0cmwucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCBwcmV2KTtcblx0ICAgICAgICB9XG5cdFxuXHQgICAgICAgIGlmIChuZXh0Q3RybCkge1xuXHQgICAgICAgICAgICBuZXh0Q3RybC5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIG5leHQpO1xuXHQgICAgICAgIH1cblx0XG5cdCAgICAgICAgLy8gcmVtb3ZlIGNsb25lZCBzbGlkZXMgaWYgaW5maW5pdGUgaXMgc2V0XG5cdCAgICAgICAgaWYgKG9wdGlvbnMuaW5maW5pdGUpIHtcblx0ICAgICAgICAgICAgQXJyYXkuYXBwbHkobnVsbCwgQXJyYXkob3B0aW9ucy5pbmZpbml0ZSkpLmZvckVhY2goZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAgICAgc2xpZGVDb250YWluZXIucmVtb3ZlQ2hpbGQoc2xpZGVDb250YWluZXIuZmlyc3RDaGlsZCk7XG5cdCAgICAgICAgICAgICAgICBzbGlkZUNvbnRhaW5lci5yZW1vdmVDaGlsZChzbGlkZUNvbnRhaW5lci5sYXN0Q2hpbGQpO1xuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9XG5cdFxuXHQgICAgICAgIGRpc3BhdGNoU2xpZGVyRXZlbnQoJ2FmdGVyJywgJ2Rlc3Ryb3knKTtcblx0ICAgIH1cblx0XG5cdCAgICAvLyBldmVudCBoYW5kbGluZ1xuXHRcblx0ICAgIHZhciB0b3VjaE9mZnNldCA9IHZvaWQgMDtcblx0ICAgIHZhciBkZWx0YSA9IHZvaWQgMDtcblx0ICAgIHZhciBpc1Njcm9sbGluZyA9IHZvaWQgMDtcblx0XG5cdCAgICBmdW5jdGlvbiBvblRyYW5zaXRpb25FbmQoKSB7XG5cdCAgICAgICAgaWYgKHRyYW5zaXRpb25FbmRDYWxsYmFjaykge1xuXHQgICAgICAgICAgICB0cmFuc2l0aW9uRW5kQ2FsbGJhY2soKTtcblx0XG5cdCAgICAgICAgICAgIHRyYW5zaXRpb25FbmRDYWxsYmFjayA9IHVuZGVmaW5lZDtcblx0ICAgICAgICB9XG5cdCAgICB9XG5cdFxuXHQgICAgZnVuY3Rpb24gb25Ub3VjaHN0YXJ0KGV2ZW50KSB7XG5cdCAgICAgICAgdmFyIF9vcHRpb25zNiA9IG9wdGlvbnM7XG5cdCAgICAgICAgdmFyIGVuYWJsZU1vdXNlRXZlbnRzID0gX29wdGlvbnM2LmVuYWJsZU1vdXNlRXZlbnRzO1xuXHRcblx0ICAgICAgICB2YXIgdG91Y2hlcyA9IGV2ZW50LnRvdWNoZXMgPyBldmVudC50b3VjaGVzWzBdIDogZXZlbnQ7XG5cdFxuXHQgICAgICAgIGlmIChlbmFibGVNb3VzZUV2ZW50cykge1xuXHQgICAgICAgICAgICBmcmFtZS5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBvblRvdWNobW92ZSk7XG5cdCAgICAgICAgICAgIGZyYW1lLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBvblRvdWNoZW5kKTtcblx0ICAgICAgICAgICAgZnJhbWUuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VsZWF2ZScsIG9uVG91Y2hlbmQpO1xuXHQgICAgICAgIH1cblx0XG5cdCAgICAgICAgZnJhbWUuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgb25Ub3VjaG1vdmUpO1xuXHQgICAgICAgIGZyYW1lLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgb25Ub3VjaGVuZCk7XG5cdFxuXHQgICAgICAgIHZhciBwYWdlWCA9IHRvdWNoZXMucGFnZVg7XG5cdCAgICAgICAgdmFyIHBhZ2VZID0gdG91Y2hlcy5wYWdlWTtcblx0XG5cdFxuXHQgICAgICAgIHRvdWNoT2Zmc2V0ID0ge1xuXHQgICAgICAgICAgICB4OiBwYWdlWCxcblx0ICAgICAgICAgICAgeTogcGFnZVksXG5cdCAgICAgICAgICAgIHRpbWU6IERhdGUubm93KClcblx0ICAgICAgICB9O1xuXHRcblx0ICAgICAgICBpc1Njcm9sbGluZyA9IHVuZGVmaW5lZDtcblx0XG5cdCAgICAgICAgZGVsdGEgPSB7fTtcblx0XG5cdCAgICAgICAgZGlzcGF0Y2hTbGlkZXJFdmVudCgnb24nLCAndG91Y2hzdGFydCcsIHtcblx0ICAgICAgICAgICAgZXZlbnQ6IGV2ZW50XG5cdCAgICAgICAgfSk7XG5cdCAgICB9XG5cdFxuXHQgICAgZnVuY3Rpb24gb25Ub3VjaG1vdmUoZXZlbnQpIHtcblx0ICAgICAgICB2YXIgdG91Y2hlcyA9IGV2ZW50LnRvdWNoZXMgPyBldmVudC50b3VjaGVzWzBdIDogZXZlbnQ7XG5cdCAgICAgICAgdmFyIHBhZ2VYID0gdG91Y2hlcy5wYWdlWDtcblx0ICAgICAgICB2YXIgcGFnZVkgPSB0b3VjaGVzLnBhZ2VZO1xuXHRcblx0XG5cdCAgICAgICAgZGVsdGEgPSB7XG5cdCAgICAgICAgICAgIHg6IHBhZ2VYIC0gdG91Y2hPZmZzZXQueCxcblx0ICAgICAgICAgICAgeTogcGFnZVkgLSB0b3VjaE9mZnNldC55XG5cdCAgICAgICAgfTtcblx0XG5cdCAgICAgICAgaWYgKHR5cGVvZiBpc1Njcm9sbGluZyA9PT0gJ3VuZGVmaW5lZCcpIHtcblx0ICAgICAgICAgICAgaXNTY3JvbGxpbmcgPSAhIShpc1Njcm9sbGluZyB8fCBNYXRoLmFicyhkZWx0YS54KSA8IE1hdGguYWJzKGRlbHRhLnkpKTtcblx0ICAgICAgICB9XG5cdFxuXHQgICAgICAgIGlmICghaXNTY3JvbGxpbmcgJiYgdG91Y2hPZmZzZXQpIHtcblx0ICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0ICAgICAgICAgICAgdHJhbnNsYXRlKHBvc2l0aW9uLnggKyBkZWx0YS54LCAwLCBudWxsKTtcblx0ICAgICAgICB9XG5cdFxuXHQgICAgICAgIC8vIG1heSBiZVxuXHQgICAgICAgIGRpc3BhdGNoU2xpZGVyRXZlbnQoJ29uJywgJ3RvdWNobW92ZScsIHtcblx0ICAgICAgICAgICAgZXZlbnQ6IGV2ZW50XG5cdCAgICAgICAgfSk7XG5cdCAgICB9XG5cdFxuXHQgICAgZnVuY3Rpb24gb25Ub3VjaGVuZChldmVudCkge1xuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIHRpbWUgYmV0d2VlbiB0b3VjaHN0YXJ0IGFuZCB0b3VjaGVuZCBpbiBtaWxsaXNlY29uZHNcblx0ICAgICAgICAgKiBAZHVyYXRpb24ge251bWJlcn1cblx0ICAgICAgICAgKi9cblx0ICAgICAgICB2YXIgZHVyYXRpb24gPSB0b3VjaE9mZnNldCA/IERhdGUubm93KCkgLSB0b3VjaE9mZnNldC50aW1lIDogdW5kZWZpbmVkO1xuXHRcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBpcyB2YWxpZCBpZjpcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIC0+IHN3aXBlIGF0dGVtcHQgdGltZSBpcyBvdmVyIDMwMCBtc1xuXHQgICAgICAgICAqIGFuZFxuXHQgICAgICAgICAqIC0+IHN3aXBlIGRpc3RhbmNlIGlzIGdyZWF0ZXIgdGhhbiAyNXB4XG5cdCAgICAgICAgICogb3Jcblx0ICAgICAgICAgKiAtPiBzd2lwZSBkaXN0YW5jZSBpcyBtb3JlIHRoZW4gYSB0aGlyZCBvZiB0aGUgc3dpcGUgYXJlYVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGlzVmFsaWRTbGlkZSB7Qm9vbGVhbn1cblx0ICAgICAgICAgKi9cblx0ICAgICAgICB2YXIgaXNWYWxpZCA9IE51bWJlcihkdXJhdGlvbikgPCAzMDAgJiYgTWF0aC5hYnMoZGVsdGEueCkgPiAyNSB8fCBNYXRoLmFicyhkZWx0YS54KSA+IGZyYW1lV2lkdGggLyAzO1xuXHRcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBpcyBvdXQgb2YgYm91bmRzIGlmOlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogLT4gaW5kZXggaXMgMCBhbmQgZGVsdGEgeCBpcyBncmVhdGVyIHRoYW4gMFxuXHQgICAgICAgICAqIG9yXG5cdCAgICAgICAgICogLT4gaW5kZXggaXMgdGhlIGxhc3Qgc2xpZGUgYW5kIGRlbHRhIGlzIHNtYWxsZXIgdGhhbiAwXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAaXNPdXRPZkJvdW5kcyB7Qm9vbGVhbn1cblx0ICAgICAgICAgKi9cblx0ICAgICAgICB2YXIgaXNPdXRPZkJvdW5kcyA9ICFpbmRleCAmJiBkZWx0YS54ID4gMCB8fCBpbmRleCA9PT0gc2xpZGVzLmxlbmd0aCAtIDEgJiYgZGVsdGEueCA8IDA7XG5cdFxuXHQgICAgICAgIHZhciBkaXJlY3Rpb24gPSBkZWx0YS54IDwgMDtcblx0XG5cdCAgICAgICAgaWYgKCFpc1Njcm9sbGluZykge1xuXHQgICAgICAgICAgICBpZiAoaXNWYWxpZCAmJiAhaXNPdXRPZkJvdW5kcykge1xuXHQgICAgICAgICAgICAgICAgc2xpZGUoZmFsc2UsIGRpcmVjdGlvbik7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICB0cmFuc2xhdGUocG9zaXRpb24ueCwgb3B0aW9ucy5zbmFwQmFja1NwZWVkKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0XG5cdCAgICAgICAgdG91Y2hPZmZzZXQgPSB1bmRlZmluZWQ7XG5cdFxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIHJlbW92ZSBldmVudGxpc3RlbmVycyBhZnRlciBzd2lwZSBhdHRlbXB0XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgZnJhbWUucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgb25Ub3VjaG1vdmUpO1xuXHQgICAgICAgIGZyYW1lLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgb25Ub3VjaGVuZCk7XG5cdCAgICAgICAgZnJhbWUucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgb25Ub3VjaG1vdmUpO1xuXHQgICAgICAgIGZyYW1lLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBvblRvdWNoZW5kKTtcblx0ICAgICAgICBmcmFtZS5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWxlYXZlJywgb25Ub3VjaGVuZCk7XG5cdFxuXHQgICAgICAgIGRpc3BhdGNoU2xpZGVyRXZlbnQoJ29uJywgJ3RvdWNoZW5kJywge1xuXHQgICAgICAgICAgICBldmVudDogZXZlbnRcblx0ICAgICAgICB9KTtcblx0ICAgIH1cblx0XG5cdCAgICBmdW5jdGlvbiBvbkNsaWNrKGV2ZW50KSB7XG5cdCAgICAgICAgaWYgKGRlbHRhLngpIHtcblx0ICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0ICAgICAgICB9XG5cdCAgICB9XG5cdFxuXHQgICAgZnVuY3Rpb24gb25SZXNpemUoZXZlbnQpIHtcblx0ICAgICAgICByZXNldCgpO1xuXHRcblx0ICAgICAgICBkaXNwYXRjaFNsaWRlckV2ZW50KCdvbicsICdyZXNpemUnLCB7XG5cdCAgICAgICAgICAgIGV2ZW50OiBldmVudFxuXHQgICAgICAgIH0pO1xuXHQgICAgfVxuXHRcblx0ICAgIC8vIHRyaWdnZXIgaW5pdGlhbCBzZXR1cFxuXHQgICAgc2V0dXAoKTtcblx0XG5cdCAgICAvLyBleHBvc2UgcHVibGljIGFwaVxuXHQgICAgcmV0dXJuIHtcblx0ICAgICAgICBzZXR1cDogc2V0dXAsXG5cdCAgICAgICAgcmVzZXQ6IHJlc2V0LFxuXHQgICAgICAgIHNsaWRlVG86IHNsaWRlVG8sXG5cdCAgICAgICAgcmV0dXJuSW5kZXg6IHJldHVybkluZGV4LFxuXHQgICAgICAgIHByZXY6IHByZXYsXG5cdCAgICAgICAgbmV4dDogbmV4dCxcblx0ICAgICAgICBkZXN0cm95OiBkZXN0cm95XG5cdCAgICB9O1xuXHR9XG5cbi8qKiovIH0sXG4vKiAyICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHQvKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi8oZnVuY3Rpb24oZ2xvYmFsKSB7J3VzZSBzdHJpY3QnO1xuXHRcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG5cdCAgICB2YWx1ZTogdHJ1ZVxuXHR9KTtcblx0ZXhwb3J0cy5kZWZhdWx0ID0gZGV0ZWN0UHJlZml4ZXM7XG5cdC8qKlxuXHQgKiBEZXRlY3RpbmcgcHJlZml4ZXMgZm9yIHNhdmluZyB0aW1lIGFuZCBieXRlc1xuXHQgKi9cblx0ZnVuY3Rpb24gZGV0ZWN0UHJlZml4ZXMoKSB7XG5cdCAgICB2YXIgdHJhbnNmb3JtID0gdm9pZCAwO1xuXHQgICAgdmFyIHRyYW5zaXRpb24gPSB2b2lkIDA7XG5cdCAgICB2YXIgdHJhbnNpdGlvbkVuZCA9IHZvaWQgMDtcblx0ICAgIHZhciBoYXNUcmFuc2xhdGUzZCA9IHZvaWQgMDtcblx0XG5cdCAgICAoZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ18nKTtcblx0ICAgICAgICB2YXIgc3R5bGUgPSBlbC5zdHlsZTtcblx0XG5cdCAgICAgICAgdmFyIHByb3AgPSB2b2lkIDA7XG5cdFxuXHQgICAgICAgIGlmIChzdHlsZVtwcm9wID0gJ3dlYmtpdFRyYW5zaXRpb24nXSA9PT0gJycpIHtcblx0ICAgICAgICAgICAgdHJhbnNpdGlvbkVuZCA9ICd3ZWJraXRUcmFuc2l0aW9uRW5kJztcblx0ICAgICAgICAgICAgdHJhbnNpdGlvbiA9IHByb3A7XG5cdCAgICAgICAgfVxuXHRcblx0ICAgICAgICBpZiAoc3R5bGVbcHJvcCA9ICd0cmFuc2l0aW9uJ10gPT09ICcnKSB7XG5cdCAgICAgICAgICAgIHRyYW5zaXRpb25FbmQgPSAndHJhbnNpdGlvbmVuZCc7XG5cdCAgICAgICAgICAgIHRyYW5zaXRpb24gPSBwcm9wO1xuXHQgICAgICAgIH1cblx0XG5cdCAgICAgICAgaWYgKHN0eWxlW3Byb3AgPSAnd2Via2l0VHJhbnNmb3JtJ10gPT09ICcnKSB7XG5cdCAgICAgICAgICAgIHRyYW5zZm9ybSA9IHByb3A7XG5cdCAgICAgICAgfVxuXHRcblx0ICAgICAgICBpZiAoc3R5bGVbcHJvcCA9ICdtc1RyYW5zZm9ybSddID09PSAnJykge1xuXHQgICAgICAgICAgICB0cmFuc2Zvcm0gPSBwcm9wO1xuXHQgICAgICAgIH1cblx0XG5cdCAgICAgICAgaWYgKHN0eWxlW3Byb3AgPSAndHJhbnNmb3JtJ10gPT09ICcnKSB7XG5cdCAgICAgICAgICAgIHRyYW5zZm9ybSA9IHByb3A7XG5cdCAgICAgICAgfVxuXHRcblx0ICAgICAgICBkb2N1bWVudC5ib2R5Lmluc2VydEJlZm9yZShlbCwgbnVsbCk7XG5cdCAgICAgICAgc3R5bGVbdHJhbnNmb3JtXSA9ICd0cmFuc2xhdGUzZCgwLCAwLCAwKSc7XG5cdCAgICAgICAgaGFzVHJhbnNsYXRlM2QgPSAhIWdsb2JhbC5nZXRDb21wdXRlZFN0eWxlKGVsKS5nZXRQcm9wZXJ0eVZhbHVlKHRyYW5zZm9ybSk7XG5cdCAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChlbCk7XG5cdCAgICB9KSgpO1xuXHRcblx0ICAgIHJldHVybiB7XG5cdCAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2Zvcm0sXG5cdCAgICAgICAgdHJhbnNpdGlvbjogdHJhbnNpdGlvbixcblx0ICAgICAgICB0cmFuc2l0aW9uRW5kOiB0cmFuc2l0aW9uRW5kLFxuXHQgICAgICAgIGhhc1RyYW5zbGF0ZTNkOiBoYXNUcmFuc2xhdGUzZFxuXHQgICAgfTtcblx0fVxuXHQvKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi99LmNhbGwoZXhwb3J0cywgKGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSgpKSkpXG5cbi8qKiovIH0sXG4vKiAzICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQndXNlIHN0cmljdCc7XG5cdFxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcblx0ICAgIHZhbHVlOiB0cnVlXG5cdH0pO1xuXHRleHBvcnRzLmRlZmF1bHQgPSBkaXNwYXRjaEV2ZW50O1xuXHRcblx0dmFyIF9jdXN0b21FdmVudCA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG5cdFxuXHR2YXIgX2N1c3RvbUV2ZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2N1c3RvbUV2ZW50KTtcblx0XG5cdGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cdFxuXHQvKipcblx0ICogZGlzcGF0Y2ggY3VzdG9tIGV2ZW50c1xuXHQgKlxuXHQgKiBAcGFyYW0gIHtlbGVtZW50fSBlbCAgICAgICAgIHNsaWRlc2hvdyBlbGVtZW50XG5cdCAqIEBwYXJhbSAge3N0cmluZ30gIHR5cGUgICAgICAgY3VzdG9tIGV2ZW50IG5hbWVcblx0ICogQHBhcmFtICB7b2JqZWN0fSAgZGV0YWlsICAgICBjdXN0b20gZGV0YWlsIGluZm9ybWF0aW9uXG5cdCAqL1xuXHRmdW5jdGlvbiBkaXNwYXRjaEV2ZW50KHRhcmdldCwgdHlwZSwgZGV0YWlsKSB7XG5cdCAgICB2YXIgZXZlbnQgPSBuZXcgX2N1c3RvbUV2ZW50Mi5kZWZhdWx0KHR5cGUsIHtcblx0ICAgICAgICBidWJibGVzOiB0cnVlLFxuXHQgICAgICAgIGNhbmNlbGFibGU6IHRydWUsXG5cdCAgICAgICAgZGV0YWlsOiBkZXRhaWxcblx0ICAgIH0pO1xuXHRcblx0ICAgIHRhcmdldC5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcblx0fVxuXG4vKioqLyB9LFxuLyogNCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0LyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovKGZ1bmN0aW9uKGdsb2JhbCkge1xuXHR2YXIgTmF0aXZlQ3VzdG9tRXZlbnQgPSBnbG9iYWwuQ3VzdG9tRXZlbnQ7XG5cdFxuXHRmdW5jdGlvbiB1c2VOYXRpdmUgKCkge1xuXHQgIHRyeSB7XG5cdCAgICB2YXIgcCA9IG5ldyBOYXRpdmVDdXN0b21FdmVudCgnY2F0JywgeyBkZXRhaWw6IHsgZm9vOiAnYmFyJyB9IH0pO1xuXHQgICAgcmV0dXJuICAnY2F0JyA9PT0gcC50eXBlICYmICdiYXInID09PSBwLmRldGFpbC5mb287XG5cdCAgfSBjYXRjaCAoZSkge1xuXHQgIH1cblx0ICByZXR1cm4gZmFsc2U7XG5cdH1cblx0XG5cdC8qKlxuXHQgKiBDcm9zcy1icm93c2VyIGBDdXN0b21FdmVudGAgY29uc3RydWN0b3IuXG5cdCAqXG5cdCAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9DdXN0b21FdmVudC5DdXN0b21FdmVudFxuXHQgKlxuXHQgKiBAcHVibGljXG5cdCAqL1xuXHRcblx0bW9kdWxlLmV4cG9ydHMgPSB1c2VOYXRpdmUoKSA/IE5hdGl2ZUN1c3RvbUV2ZW50IDpcblx0XG5cdC8vIElFID49IDlcblx0J2Z1bmN0aW9uJyA9PT0gdHlwZW9mIGRvY3VtZW50LmNyZWF0ZUV2ZW50ID8gZnVuY3Rpb24gQ3VzdG9tRXZlbnQgKHR5cGUsIHBhcmFtcykge1xuXHQgIHZhciBlID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0N1c3RvbUV2ZW50Jyk7XG5cdCAgaWYgKHBhcmFtcykge1xuXHQgICAgZS5pbml0Q3VzdG9tRXZlbnQodHlwZSwgcGFyYW1zLmJ1YmJsZXMsIHBhcmFtcy5jYW5jZWxhYmxlLCBwYXJhbXMuZGV0YWlsKTtcblx0ICB9IGVsc2Uge1xuXHQgICAgZS5pbml0Q3VzdG9tRXZlbnQodHlwZSwgZmFsc2UsIGZhbHNlLCB2b2lkIDApO1xuXHQgIH1cblx0ICByZXR1cm4gZTtcblx0fSA6XG5cdFxuXHQvLyBJRSA8PSA4XG5cdGZ1bmN0aW9uIEN1c3RvbUV2ZW50ICh0eXBlLCBwYXJhbXMpIHtcblx0ICB2YXIgZSA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50T2JqZWN0KCk7XG5cdCAgZS50eXBlID0gdHlwZTtcblx0ICBpZiAocGFyYW1zKSB7XG5cdCAgICBlLmJ1YmJsZXMgPSBCb29sZWFuKHBhcmFtcy5idWJibGVzKTtcblx0ICAgIGUuY2FuY2VsYWJsZSA9IEJvb2xlYW4ocGFyYW1zLmNhbmNlbGFibGUpO1xuXHQgICAgZS5kZXRhaWwgPSBwYXJhbXMuZGV0YWlsO1xuXHQgIH0gZWxzZSB7XG5cdCAgICBlLmJ1YmJsZXMgPSBmYWxzZTtcblx0ICAgIGUuY2FuY2VsYWJsZSA9IGZhbHNlO1xuXHQgICAgZS5kZXRhaWwgPSB2b2lkIDA7XG5cdCAgfVxuXHQgIHJldHVybiBlO1xuXHR9XG5cdFxuXHQvKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi99LmNhbGwoZXhwb3J0cywgKGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSgpKSkpXG5cbi8qKiovIH0sXG4vKiA1ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHQndXNlIHN0cmljdCc7XG5cdFxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcblx0ICB2YWx1ZTogdHJ1ZVxuXHR9KTtcblx0ZXhwb3J0cy5kZWZhdWx0ID0ge1xuXHQgIC8qKlxuXHQgICAqIHNsaWRlcyBzY3JvbGxlZCBhdCBvbmNlXG5cdCAgICogQHNsaWRlc1RvU2Nyb2xsIHtOdW1iZXJ9XG5cdCAgICovXG5cdCAgc2xpZGVzVG9TY3JvbGw6IDEsXG5cdFxuXHQgIC8qKlxuXHQgICAqIHRpbWUgaW4gbWlsbGlzZWNvbmRzIGZvciB0aGUgYW5pbWF0aW9uIG9mIGEgdmFsaWQgc2xpZGUgYXR0ZW1wdFxuXHQgICAqIEBzbGlkZVNwZWVkIHtOdW1iZXJ9XG5cdCAgICovXG5cdCAgc2xpZGVTcGVlZDogMzAwLFxuXHRcblx0ICAvKipcblx0ICAgKiB0aW1lIGluIG1pbGxpc2Vjb25kcyBmb3IgdGhlIGFuaW1hdGlvbiBvZiB0aGUgcmV3aW5kIGFmdGVyIHRoZSBsYXN0IHNsaWRlXG5cdCAgICogQHJld2luZFNwZWVkIHtOdW1iZXJ9XG5cdCAgICovXG5cdCAgcmV3aW5kU3BlZWQ6IDYwMCxcblx0XG5cdCAgLyoqXG5cdCAgICogdGltZSBmb3IgdGhlIHNuYXBCYWNrIG9mIHRoZSBzbGlkZXIgaWYgdGhlIHNsaWRlIGF0dGVtcHQgd2FzIG5vdCB2YWxpZFxuXHQgICAqIEBzbmFwQmFja1NwZWVkIHtOdW1iZXJ9XG5cdCAgICovXG5cdCAgc25hcEJhY2tTcGVlZDogMjAwLFxuXHRcblx0ICAvKipcblx0ICAgKiBCYXNpYyBlYXNpbmcgZnVuY3Rpb25zOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kZS9kb2NzL1dlYi9DU1MvdHJhbnNpdGlvbi10aW1pbmctZnVuY3Rpb25cblx0ICAgKiBjdWJpYyBiZXppZXIgZWFzaW5nIGZ1bmN0aW9uczogaHR0cDovL2Vhc2luZ3MubmV0L2RlXG5cdCAgICogQGVhc2Uge1N0cmluZ31cblx0ICAgKi9cblx0ICBlYXNlOiAnZWFzZScsXG5cdFxuXHQgIC8qKlxuXHQgICAqIGlmIHNsaWRlciByZWFjaGVkIHRoZSBsYXN0IHNsaWRlLCB3aXRoIG5leHQgY2xpY2sgdGhlIHNsaWRlciBnb2VzIGJhY2sgdG8gdGhlIHN0YXJ0aW5kZXguXG5cdCAgICogdXNlIGluZmluaXRlIG9yIHJld2luZCwgbm90IGJvdGhcblx0ICAgKiBAcmV3aW5kIHtCb29sZWFufVxuXHQgICAqL1xuXHQgIHJld2luZDogZmFsc2UsXG5cdFxuXHQgIC8qKlxuXHQgICAqIG51bWJlciBvZiB2aXNpYmxlIHNsaWRlcyBvciBmYWxzZVxuXHQgICAqIHVzZSBpbmZpbml0ZSBvciByZXdpbmQsIG5vdCBib3RoXG5cdCAgICogQGluZmluaXRlIHtudW1iZXJ9XG5cdCAgICovXG5cdCAgaW5maW5pdGU6IGZhbHNlLFxuXHRcblx0ICAvKipcblx0ICAgKiBjbGFzcyBuYW1lIGZvciBzbGlkZXIgZnJhbWVcblx0ICAgKiBAY2xhc3NOYW1lRnJhbWUge3N0cmluZ31cblx0ICAgKi9cblx0ICBjbGFzc05hbWVGcmFtZTogJ2pzX2ZyYW1lJyxcblx0XG5cdCAgLyoqXG5cdCAgICogY2xhc3MgbmFtZSBmb3Igc2xpZGVzIGNvbnRhaW5lclxuXHQgICAqIEBjbGFzc05hbWVTbGlkZUNvbnRhaW5lciB7c3RyaW5nfVxuXHQgICAqL1xuXHQgIGNsYXNzTmFtZVNsaWRlQ29udGFpbmVyOiAnanNfc2xpZGVzJyxcblx0XG5cdCAgLyoqXG5cdCAgICogY2xhc3MgbmFtZSBmb3Igc2xpZGVyIHByZXYgY29udHJvbFxuXHQgICAqIEBjbGFzc05hbWVQcmV2Q3RybCB7c3RyaW5nfVxuXHQgICAqL1xuXHQgIGNsYXNzTmFtZVByZXZDdHJsOiAnanNfcHJldicsXG5cdFxuXHQgIC8qKlxuXHQgICAqIGNsYXNzIG5hbWUgZm9yIHNsaWRlciBuZXh0IGNvbnRyb2xcblx0ICAgKiBAY2xhc3NOYW1lTmV4dEN0cmwge3N0cmluZ31cblx0ICAgKi9cblx0ICBjbGFzc05hbWVOZXh0Q3RybDogJ2pzX25leHQnLFxuXHRcblx0ICAvKipcblx0ICAgKiBjbGFzcyBuYW1lIGZvciBjdXJyZW50IGFjdGl2ZSBzbGlkZVxuXHQgICAqIGlmIGVtcHR5U3RyaW5nIHRoZW4gbm8gY2xhc3MgaXMgc2V0XG5cdCAgICogQGNsYXNzTmFtZUFjdGl2ZVNsaWRlIHtzdHJpbmd9XG5cdCAgICovXG5cdCAgY2xhc3NOYW1lQWN0aXZlU2xpZGU6ICdhY3RpdmUnLFxuXHRcblx0ICAvKipcblx0ICAgKiBlbmFibGVzIG1vdXNlIGV2ZW50cyBmb3Igc3dpcGluZyBvbiBkZXNrdG9wIGRldmljZXNcblx0ICAgKiBAZW5hYmxlTW91c2VFdmVudHMge2Jvb2xlYW59XG5cdCAgICovXG5cdCAgZW5hYmxlTW91c2VFdmVudHM6IGZhbHNlLFxuXHRcblx0ICAvKipcblx0ICAgKiB3aW5kb3cgaW5zdGFuY2Vcblx0ICAgKiBAd2luZG93IHtvYmplY3R9XG5cdCAgICovXG5cdCAgd2luZG93OiB3aW5kb3csXG5cdFxuXHQgIC8qKlxuXHQgICAqIElmIGZhbHNlLCBzbGlkZXMgbG9yeSB0byB0aGUgZmlyc3Qgc2xpZGUgb24gd2luZG93IHJlc2l6ZS5cblx0ICAgKiBAcmV3aW5kT25SZXNpemUge2Jvb2xlYW59XG5cdCAgICovXG5cdCAgcmV3aW5kT25SZXNpemU6IHRydWVcblx0fTtcblxuLyoqKi8gfVxuLyoqKioqKi8gXSlcbn0pO1xuO1xuXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHNpbXBsZSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5qc19zaW1wbGUnKTtcbiAgICAgICAgY29uc29sZS5sb2coJ3Nzc3MnKTtcbiAgICAgICAgbG9yeShzaW1wbGUsIHtcbiAgICAgICAgICAgIGluZmluaXRlOiAxLFxuICAgICAgICAgICAgZW5hYmxlTW91c2VFdmVudHM6IHRydWUsXG4gICAgICAgICAgICBjbGFzc05hbWVQcmV2Q3RybDonc2xpZGVyX19wcmV2JyxcbiAgICAgICAgICAgIGNsYXNzTmFtZU5leHRDdHJsOidzbGlkZXJfX25leHQnLFxuICAgICAgICAgICAgY2xhc3NOYW1lU2xpZGVDb250YWluZXI6ICdzbGlkZXJfX3NsaWRlcycsXG4gICAgICAgICAgICBjbGFzc05hbWVGcmFtZTogJ3NsaWRlcl9fZnJhbWUnLFxuICAgICAgICB9KTtcbiAgICB9KTsiXSwiZmlsZSI6Im1haW4ubWluLmpzIiwic291cmNlUm9vdCI6Ii9zb3VyY2UvIn0=
