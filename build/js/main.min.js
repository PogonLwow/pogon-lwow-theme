jQuery(function($) {

       function cardExcerpt() {
        $(".card__excerpt").text(function(index, currentText) {
          return currentText.substr(0, 125) + '\u2026';
        });
      }
      cardExcerpt();
      function featuredTitle() {
       $(".featured__title").text(function(index, currentText) {
         return currentText.substr(0, 72) + '\u2026';
       });
     }
     featuredTitle();

    $(document).ready(function() {

        (function() {
            $('.sportspress style').remove();
            $('.gallery-item a').addClass('link');
        
            $('.sp-team-name').each(function() {
                $(this).insertAfter($(this).parent().find('img'));
            });
        })();

            // $("#nav-mobile").html($("#nav-main").html());
            $("#nav-trigger .navicon-button").click(function() {
                console.info('Burger clicked');
                if ($(".topbar").hasClass("topbar--expanded")) {
                    $(".topbar").removeClass("topbar--expanded");
                    $(this).removeClass("open");
                } else {
                    $(".topbar").addClass("topbar--expanded");
                    $(this).addClass("open");
                }
            });

        
        var bLazy = new Blazy({
          offset: 20,
          selector: '.blazy',
          loadInvisible: false,
          breakpoints: [{
            width: 360, // Max-width
            src: 'data-src-small'
          }],
          success: function(element) {
            $(element).parent().removeClass('loading', 500);
            updateCounter();
          },
          error: function(element, msg) {
            if (msg === 'missing') {
              $(element).parent().removeClass('loading', 500); // Data-src is missing
              console.error("bLazy: data-src is missing");
            } else if (msg === 'invalid') {
              $(element).parent().removeClass('loading', 500);
              // Data-src is invalid
              console.error("bLazy: data-src is invalid");
        
            }
          }
        });
        // not needed, only here to illustrate amount of loaded images
        var imageLoaded = 0;
        
        function updateCounter() {
          imageLoaded++;
          console.info("bLazy: Images loaded: %d", imageLoaded);
        }
        
        // tabs(bLazy);

        (function() {
            var ajax_url = $('body').attr('data-ajax-url');
            var post_offset = 0;
            var incNumber = 6; // ilość postów do załadowania
        
            $('#load_more_posts').on('click', loadMore);
            $('#load_more_searched_posts').on('click', loadMoreSearched);
        
            function loadMore() {
                console.log('Clicked load_more');
                $(this).html('Ładuję...');
                post_offset = parseInt(post_offset) + 6;
                $.ajax({
                    url: ajax_url,
                    type: 'POST',
                    data: {
                        action: 'load_posts',
                        post_offset: post_offset,
                    },
                    success: function(data) {
                        $('#load_more_posts').html('Zobacz starsze');
                        $('#feed').append(data);
                        console.info('Ajax: OK');
                        bLazy.revalidate();
                        cardExcerpt();
                    }
                });
            }
        
        
        
            function loadMoreSearched() {
                console.log('Clicked load_more_searched');
                $(this).html('Ładuję...');
                post_offset = parseInt(post_offset) + 6;
                $.ajax({
                    url: ajax_url,
                    type: 'POST',
                    data: {
                        action: 'load_searched_posts',
                        post_offset: post_offset,
                        s: document.getElementById("searchQuery").getAttribute("data-search-query")
                    },
                    success: function(data) {
                        $('#load_more_searched_posts').html('Więcej wyników');
                        $('#feed').append(data);
                        console.info('Ajax: OK');
                        bLazy.revalidate();
                        cardExcerpt();
                    }
                });
            }
        
        })();

    });
});

(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else {
		var a = factory();
		for(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];
	}
})(typeof self !== 'undefined' ? self : this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 7);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1,eval)("this");
} catch(e) {
	// This works if the window reference is available
	if(typeof window === "object")
		g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; /* globals jQuery */

exports.lory = lory;

var _detectPrefixes = __webpack_require__(2);

var _detectPrefixes2 = _interopRequireDefault(_detectPrefixes);

var _detectSupportsPassive = __webpack_require__(3);

var _detectSupportsPassive2 = _interopRequireDefault(_detectSupportsPassive);

var _dispatchEvent = __webpack_require__(4);

var _dispatchEvent2 = _interopRequireDefault(_dispatchEvent);

var _defaults = __webpack_require__(6);

var _defaults2 = _interopRequireDefault(_defaults);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var slice = Array.prototype.slice;

function lory(slider, opts) {
    var position = void 0;
    var slidesWidth = void 0;
    var frameWidth = void 0;
    var slides = void 0;

    /**
     * slider DOM elements
     */
    var frame = void 0;
    var slideContainer = void 0;
    var prevCtrl = void 0;
    var nextCtrl = void 0;
    var prefixes = void 0;
    var transitionEndCallback = void 0;

    var index = 0;
    var options = {};
    var touchEventParams = (0, _detectSupportsPassive2.default)() ? { passive: true } : false;

    /**
     * if object is jQuery convert to native DOM element
     */
    if (typeof jQuery !== 'undefined' && slider instanceof jQuery) {
        slider = slider[0];
    }

    /**
     * private
     * set active class to element which is the current slide
     */
    function setActiveElement(slides, currentIndex) {
        var _options = options,
            classNameActiveSlide = _options.classNameActiveSlide;


        slides.forEach(function (element, index) {
            if (element.classList.contains(classNameActiveSlide)) {
                element.classList.remove(classNameActiveSlide);
            }
        });

        slides[currentIndex].classList.add(classNameActiveSlide);
    }

    /**
     * private
     * setupInfinite: function to setup if infinite is set
     *
     * @param  {array} slideArray
     * @return {array} array of updated slideContainer elements
     */
    function setupInfinite(slideArray) {
        var _options2 = options,
            infinite = _options2.infinite;


        var front = slideArray.slice(0, infinite);
        var back = slideArray.slice(slideArray.length - infinite, slideArray.length);

        front.forEach(function (element) {
            var cloned = element.cloneNode(true);

            slideContainer.appendChild(cloned);
        });

        back.reverse().forEach(function (element) {
            var cloned = element.cloneNode(true);

            slideContainer.insertBefore(cloned, slideContainer.firstChild);
        });

        slideContainer.addEventListener(prefixes.transitionEnd, onTransitionEnd);

        return slice.call(slideContainer.children);
    }

    /**
     * [dispatchSliderEvent description]
     * @return {[type]} [description]
     */
    function dispatchSliderEvent(phase, type, detail) {
        (0, _dispatchEvent2.default)(slider, phase + '.lory.' + type, detail);
    }

    /**
     * translates to a given position in a given time in milliseconds
     *
     * @to        {number} number in pixels where to translate to
     * @duration  {number} time in milliseconds for the transistion
     * @ease      {string} easing css property
     */
    function translate(to, duration, ease) {
        var style = slideContainer && slideContainer.style;

        if (style) {
            style[prefixes.transition + 'TimingFunction'] = ease;
            style[prefixes.transition + 'Duration'] = duration + 'ms';

            if (prefixes.hasTranslate3d) {
                style[prefixes.transform] = 'translate3d(' + to + 'px, 0, 0)';
            } else {
                style[prefixes.transform] = 'translate(' + to + 'px, 0)';
            }
        }
    }

    /**
     * returns an element's width
     */
    function elementWidth(element) {
        return element.getBoundingClientRect().width || element.offsetWidth;
    }

    /**
     * slidefunction called by prev, next & touchend
     *
     * determine nextIndex and slide to next postion
     * under restrictions of the defined options
     *
     * @direction  {boolean}
     */
    function slide(nextIndex, direction) {
        var _options3 = options,
            slideSpeed = _options3.slideSpeed,
            slidesToScroll = _options3.slidesToScroll,
            infinite = _options3.infinite,
            rewind = _options3.rewind,
            rewindSpeed = _options3.rewindSpeed,
            ease = _options3.ease,
            classNameActiveSlide = _options3.classNameActiveSlide;


        var duration = slideSpeed;

        var nextSlide = direction ? index + 1 : index - 1;
        var maxOffset = Math.round(slidesWidth - frameWidth);

        dispatchSliderEvent('before', 'slide', {
            index: index,
            nextSlide: nextSlide
        });

        /**
         * Reset control classes
         */
        if (prevCtrl) {
            prevCtrl.classList.remove('disabled');
        }
        if (nextCtrl) {
            nextCtrl.classList.remove('disabled');
        }

        if (typeof nextIndex !== 'number') {
            if (direction) {
                if (infinite && index + infinite * 2 !== slides.length) {
                    nextIndex = index + (infinite - index % infinite);
                } else {
                    nextIndex = index + slidesToScroll;
                }
            } else {
                if (infinite && index % infinite !== 0) {
                    nextIndex = index - index % infinite;
                } else {
                    nextIndex = index - slidesToScroll;
                }
            }
        }

        nextIndex = Math.min(Math.max(nextIndex, 0), slides.length - 1);

        if (infinite && direction === undefined) {
            nextIndex += infinite;
        }

        var nextOffset = Math.min(Math.max(slides[nextIndex].offsetLeft * -1, maxOffset * -1), 0);

        if (rewind && Math.abs(position.x) === maxOffset && direction) {
            nextOffset = 0;
            nextIndex = 0;
            duration = rewindSpeed;
        }

        /**
         * translate to the nextOffset by a defined duration and ease function
         */
        translate(nextOffset, duration, ease);

        /**
         * update the position with the next position
         */
        position.x = nextOffset;

        /**
         * update the index with the nextIndex only if
         * the offset of the nextIndex is in the range of the maxOffset
         */
        if (slides[nextIndex].offsetLeft <= maxOffset) {
            index = nextIndex;
        }

        if (infinite && (nextIndex === slides.length - infinite || nextIndex === slides.length - slides.length % infinite || nextIndex === 0)) {
            if (direction) {
                index = infinite;
            }

            if (!direction) {
                index = slides.length - infinite * 2;
            }

            position.x = slides[index].offsetLeft * -1;

            transitionEndCallback = function transitionEndCallback() {
                translate(slides[index].offsetLeft * -1, 0, undefined);
            };
        }

        if (classNameActiveSlide) {
            setActiveElement(slice.call(slides), index);
        }

        /**
         * update classes for next and prev arrows
         * based on user settings
         */
        if (prevCtrl && !infinite && nextIndex === 0) {
            prevCtrl.classList.add('disabled');
        }

        if (nextCtrl && !infinite && !rewind && nextIndex + 1 === slides.length) {
            nextCtrl.classList.add('disabled');
        }

        dispatchSliderEvent('after', 'slide', {
            currentSlide: index
        });
    }

    /**
     * public
     * setup function
     */
    function setup() {
        dispatchSliderEvent('before', 'init');

        prefixes = (0, _detectPrefixes2.default)();
        options = _extends({}, _defaults2.default, opts);

        var _options4 = options,
            classNameFrame = _options4.classNameFrame,
            classNameSlideContainer = _options4.classNameSlideContainer,
            classNamePrevCtrl = _options4.classNamePrevCtrl,
            classNameNextCtrl = _options4.classNameNextCtrl,
            enableMouseEvents = _options4.enableMouseEvents,
            classNameActiveSlide = _options4.classNameActiveSlide,
            initialIndex = _options4.initialIndex;


        index = initialIndex;
        frame = slider.getElementsByClassName(classNameFrame)[0];
        slideContainer = frame.getElementsByClassName(classNameSlideContainer)[0];
        prevCtrl = slider.getElementsByClassName(classNamePrevCtrl)[0];
        nextCtrl = slider.getElementsByClassName(classNameNextCtrl)[0];

        position = {
            x: slideContainer.offsetLeft,
            y: slideContainer.offsetTop
        };

        if (options.infinite) {
            slides = setupInfinite(slice.call(slideContainer.children));
        } else {
            slides = slice.call(slideContainer.children);

            if (prevCtrl) {
                prevCtrl.classList.add('disabled');
            }

            if (nextCtrl && slides.length === 1 && !options.rewind) {
                nextCtrl.classList.add('disabled');
            }
        }

        reset();

        if (classNameActiveSlide) {
            setActiveElement(slides, index);
        }

        if (prevCtrl && nextCtrl) {
            prevCtrl.addEventListener('click', prev);
            nextCtrl.addEventListener('click', next);
        }

        frame.addEventListener('touchstart', onTouchstart, touchEventParams);

        if (enableMouseEvents) {
            frame.addEventListener('mousedown', onTouchstart);
            frame.addEventListener('click', onClick);
        }

        options.window.addEventListener('resize', onResize);

        dispatchSliderEvent('after', 'init');
    }

    /**
     * public
     * reset function: called on resize
     */
    function reset() {
        var _options5 = options,
            infinite = _options5.infinite,
            ease = _options5.ease,
            rewindSpeed = _options5.rewindSpeed,
            rewindOnResize = _options5.rewindOnResize,
            classNameActiveSlide = _options5.classNameActiveSlide,
            initialIndex = _options5.initialIndex;


        slidesWidth = elementWidth(slideContainer);
        frameWidth = elementWidth(frame);

        if (frameWidth === slidesWidth) {
            slidesWidth = slides.reduce(function (previousValue, slide) {
                return previousValue + elementWidth(slide);
            }, 0);
        }

        if (rewindOnResize) {
            index = initialIndex;
        } else {
            ease = null;
            rewindSpeed = 0;
        }

        if (infinite) {
            translate(slides[index + infinite].offsetLeft * -1, 0, null);

            index = index + infinite;
            position.x = slides[index].offsetLeft * -1;
        } else {
            translate(slides[index].offsetLeft * -1, rewindSpeed, ease);
            position.x = slides[index].offsetLeft * -1;
        }

        if (classNameActiveSlide) {
            setActiveElement(slice.call(slides), index);
        }
    }

    /**
     * public
     * slideTo: called on clickhandler
     */
    function slideTo(index) {
        slide(index);
    }

    /**
     * public
     * returnIndex function: called on clickhandler
     */
    function returnIndex() {
        return index - options.infinite || 0;
    }

    /**
     * public
     * prev function: called on clickhandler
     */
    function prev() {
        slide(false, false);
    }

    /**
     * public
     * next function: called on clickhandler
     */
    function next() {
        slide(false, true);
    }

    /**
     * public
     * destroy function: called to gracefully destroy the lory instance
     */
    function destroy() {
        dispatchSliderEvent('before', 'destroy');

        // remove event listeners
        frame.removeEventListener(prefixes.transitionEnd, onTransitionEnd);
        frame.removeEventListener('touchstart', onTouchstart, touchEventParams);
        frame.removeEventListener('touchmove', onTouchmove, touchEventParams);
        frame.removeEventListener('touchend', onTouchend);
        frame.removeEventListener('mousemove', onTouchmove);
        frame.removeEventListener('mousedown', onTouchstart);
        frame.removeEventListener('mouseup', onTouchend);
        frame.removeEventListener('mouseleave', onTouchend);
        frame.removeEventListener('click', onClick);

        options.window.removeEventListener('resize', onResize);

        if (prevCtrl) {
            prevCtrl.removeEventListener('click', prev);
        }

        if (nextCtrl) {
            nextCtrl.removeEventListener('click', next);
        }

        // remove cloned slides if infinite is set
        if (options.infinite) {
            Array.apply(null, Array(options.infinite)).forEach(function () {
                slideContainer.removeChild(slideContainer.firstChild);
                slideContainer.removeChild(slideContainer.lastChild);
            });
        }

        dispatchSliderEvent('after', 'destroy');
    }

    // event handling

    var touchOffset = void 0;
    var delta = void 0;
    var isScrolling = void 0;

    function onTransitionEnd() {
        if (transitionEndCallback) {
            transitionEndCallback();

            transitionEndCallback = undefined;
        }
    }

    function onTouchstart(event) {
        var _options6 = options,
            enableMouseEvents = _options6.enableMouseEvents;

        var touches = event.touches ? event.touches[0] : event;

        if (enableMouseEvents) {
            frame.addEventListener('mousemove', onTouchmove);
            frame.addEventListener('mouseup', onTouchend);
            frame.addEventListener('mouseleave', onTouchend);
        }

        frame.addEventListener('touchmove', onTouchmove, touchEventParams);
        frame.addEventListener('touchend', onTouchend);

        var pageX = touches.pageX,
            pageY = touches.pageY;


        touchOffset = {
            x: pageX,
            y: pageY,
            time: Date.now()
        };

        isScrolling = undefined;

        delta = {};

        dispatchSliderEvent('on', 'touchstart', {
            event: event
        });
    }

    function onTouchmove(event) {
        var touches = event.touches ? event.touches[0] : event;
        var pageX = touches.pageX,
            pageY = touches.pageY;


        delta = {
            x: pageX - touchOffset.x,
            y: pageY - touchOffset.y
        };

        if (typeof isScrolling === 'undefined') {
            isScrolling = !!(isScrolling || Math.abs(delta.x) < Math.abs(delta.y));
        }

        if (!isScrolling && touchOffset) {
            translate(position.x + delta.x, 0, null);
        }

        // may be
        dispatchSliderEvent('on', 'touchmove', {
            event: event
        });
    }

    function onTouchend(event) {
        /**
         * time between touchstart and touchend in milliseconds
         * @duration {number}
         */
        var duration = touchOffset ? Date.now() - touchOffset.time : undefined;

        /**
         * is valid if:
         *
         * -> swipe attempt time is over 300 ms
         * and
         * -> swipe distance is greater than 25px
         * or
         * -> swipe distance is more then a third of the swipe area
         *
         * @isValidSlide {Boolean}
         */
        var isValid = Number(duration) < 300 && Math.abs(delta.x) > 25 || Math.abs(delta.x) > frameWidth / 3;

        /**
         * is out of bounds if:
         *
         * -> index is 0 and delta x is greater than 0
         * or
         * -> index is the last slide and delta is smaller than 0
         *
         * @isOutOfBounds {Boolean}
         */
        var isOutOfBounds = !index && delta.x > 0 || index === slides.length - 1 && delta.x < 0;

        var direction = delta.x < 0;

        if (!isScrolling) {
            if (isValid && !isOutOfBounds) {
                slide(false, direction);
            } else {
                translate(position.x, options.snapBackSpeed);
            }
        }

        touchOffset = undefined;

        /**
         * remove eventlisteners after swipe attempt
         */
        frame.removeEventListener('touchmove', onTouchmove);
        frame.removeEventListener('touchend', onTouchend);
        frame.removeEventListener('mousemove', onTouchmove);
        frame.removeEventListener('mouseup', onTouchend);
        frame.removeEventListener('mouseleave', onTouchend);

        dispatchSliderEvent('on', 'touchend', {
            event: event
        });
    }

    function onClick(event) {
        if (delta.x) {
            event.preventDefault();
        }
    }

    function onResize(event) {
        if (frameWidth !== elementWidth(frame)) {
            reset();

            dispatchSliderEvent('on', 'resize', {
                event: event
            });
        }
    }

    // trigger initial setup
    setup();

    // expose public api
    return {
        setup: setup,
        reset: reset,
        slideTo: slideTo,
        returnIndex: returnIndex,
        prev: prev,
        next: next,
        destroy: destroy
    };
}

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = detectPrefixes;
/**
 * Detecting prefixes for saving time and bytes
 */
function detectPrefixes() {
    var transform = void 0;
    var transition = void 0;
    var transitionEnd = void 0;
    var hasTranslate3d = void 0;

    (function () {
        var el = document.createElement('_');
        var style = el.style;

        var prop = void 0;

        if (style[prop = 'webkitTransition'] === '') {
            transitionEnd = 'webkitTransitionEnd';
            transition = prop;
        }

        if (style[prop = 'transition'] === '') {
            transitionEnd = 'transitionend';
            transition = prop;
        }

        if (style[prop = 'webkitTransform'] === '') {
            transform = prop;
        }

        if (style[prop = 'msTransform'] === '') {
            transform = prop;
        }

        if (style[prop = 'transform'] === '') {
            transform = prop;
        }

        document.body.insertBefore(el, null);
        style[transform] = 'translate3d(0, 0, 0)';
        hasTranslate3d = !!global.getComputedStyle(el).getPropertyValue(transform);
        document.body.removeChild(el);
    })();

    return {
        transform: transform,
        transition: transition,
        transitionEnd: transitionEnd,
        hasTranslate3d: hasTranslate3d
    };
}
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = detectSupportsPassive;
function detectSupportsPassive() {
    var supportsPassive = false;

    try {
        var opts = Object.defineProperty({}, 'passive', {
            get: function get() {
                supportsPassive = true;
            }
        });

        window.addEventListener('testPassive', null, opts);
        window.removeEventListener('testPassive', null, opts);
    } catch (e) {}

    return supportsPassive;
}

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = dispatchEvent;

var _customEvent = __webpack_require__(5);

var _customEvent2 = _interopRequireDefault(_customEvent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * dispatch custom events
 *
 * @param  {element} el         slideshow element
 * @param  {string}  type       custom event name
 * @param  {object}  detail     custom detail information
 */
function dispatchEvent(target, type, detail) {
    var event = new _customEvent2.default(type, {
        bubbles: true,
        cancelable: true,
        detail: detail
    });

    target.dispatchEvent(event);
}

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {
var NativeCustomEvent = global.CustomEvent;

function useNative () {
  try {
    var p = new NativeCustomEvent('cat', { detail: { foo: 'bar' } });
    return  'cat' === p.type && 'bar' === p.detail.foo;
  } catch (e) {
  }
  return false;
}

/**
 * Cross-browser `CustomEvent` constructor.
 *
 * https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent.CustomEvent
 *
 * @public
 */

module.exports = useNative() ? NativeCustomEvent :

// IE >= 9
'undefined' !== typeof document && 'function' === typeof document.createEvent ? function CustomEvent (type, params) {
  var e = document.createEvent('CustomEvent');
  if (params) {
    e.initCustomEvent(type, params.bubbles, params.cancelable, params.detail);
  } else {
    e.initCustomEvent(type, false, false, void 0);
  }
  return e;
} :

// IE <= 8
function CustomEvent (type, params) {
  var e = document.createEventObject();
  e.type = type;
  if (params) {
    e.bubbles = Boolean(params.bubbles);
    e.cancelable = Boolean(params.cancelable);
    e.detail = params.detail;
  } else {
    e.bubbles = false;
    e.cancelable = false;
    e.detail = void 0;
  }
  return e;
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = {
  /**
   * slides scrolled at once
   * @slidesToScroll {Number}
   */
  slidesToScroll: 1,

  /**
   * time in milliseconds for the animation of a valid slide attempt
   * @slideSpeed {Number}
   */
  slideSpeed: 300,

  /**
   * time in milliseconds for the animation of the rewind after the last slide
   * @rewindSpeed {Number}
   */
  rewindSpeed: 600,

  /**
   * time for the snapBack of the slider if the slide attempt was not valid
   * @snapBackSpeed {Number}
   */
  snapBackSpeed: 200,

  /**
   * Basic easing functions: https://developer.mozilla.org/de/docs/Web/CSS/transition-timing-function
   * cubic bezier easing functions: http://easings.net/de
   * @ease {String}
   */
  ease: 'ease',

  /**
   * if slider reached the last slide, with next click the slider goes back to the startindex.
   * use infinite or rewind, not both
   * @rewind {Boolean}
   */
  rewind: false,

  /**
   * number of visible slides or false
   * use infinite or rewind, not both
   * @infinite {number}
   */
  infinite: false,

  /**
   * the slide index to show when the slider is initialized.
   * @initialIndex {number}
   */
  initialIndex: 0,

  /**
   * class name for slider frame
   * @classNameFrame {string}
   */
  classNameFrame: 'js_frame',

  /**
   * class name for slides container
   * @classNameSlideContainer {string}
   */
  classNameSlideContainer: 'js_slides',

  /**
   * class name for slider prev control
   * @classNamePrevCtrl {string}
   */
  classNamePrevCtrl: 'js_prev',

  /**
   * class name for slider next control
   * @classNameNextCtrl {string}
   */
  classNameNextCtrl: 'js_next',

  /**
   * class name for current active slide
   * if emptyString then no class is set
   * @classNameActiveSlide {string}
   */
  classNameActiveSlide: 'active',

  /**
   * enables mouse events for swiping on desktop devices
   * @enableMouseEvents {boolean}
   */
  enableMouseEvents: false,

  /**
   * window instance
   * @window {object}
   */
  window: typeof window !== 'undefined' ? window : null,

  /**
   * If false, slides lory to the first slide on window resize.
   * @rewindOnResize {boolean}
   */
  rewindOnResize: true
};

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(1);


/***/ })
/******/ ]);
});
// https://github.com/lewiscollard/horsepower/blob/29d406877d74705c61f27cc656a95ecfde86b987/assets/js/50-carousel.js
    function makeCarousel(selector) {
        var simple = document.querySelector(selector);
        if (!simple) {
            return;
        }
        var loryCarousel = lory(simple, {
            infinite: 1,
            enableMouseEvents: true,
            classNamePrevCtrl:'slider__prev',
            classNameNextCtrl:'slider__next',
            classNameSlideContainer: 'slider__slides',
            classNameFrame: 'slider__frame',
        });

        // Autoplay
        var timer = window.setInterval(function () {
            loryCarousel.next();
        }, 5000);

        function cancelTimer() {
            window.clearInterval(timer);
        }

        simple.querySelector('.slider__next').addEventListener('click', cancelTimer);
        simple.querySelector('.slider__prev').addEventListener('click', cancelTimer);
        simple.addEventListener('on.lory.touchstart', cancelTimer);
    }

    window.addEventListener('load', function() {
        makeCarousel('.js_simple');
    });
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiIiwic291cmNlcyI6WyJtYWluLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImpRdWVyeShmdW5jdGlvbigkKSB7XG5cbiAgICAgICBmdW5jdGlvbiBjYXJkRXhjZXJwdCgpIHtcbiAgICAgICAgJChcIi5jYXJkX19leGNlcnB0XCIpLnRleHQoZnVuY3Rpb24oaW5kZXgsIGN1cnJlbnRUZXh0KSB7XG4gICAgICAgICAgcmV0dXJuIGN1cnJlbnRUZXh0LnN1YnN0cigwLCAxMjUpICsgJ1xcdTIwMjYnO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGNhcmRFeGNlcnB0KCk7XG4gICAgICBmdW5jdGlvbiBmZWF0dXJlZFRpdGxlKCkge1xuICAgICAgICQoXCIuZmVhdHVyZWRfX3RpdGxlXCIpLnRleHQoZnVuY3Rpb24oaW5kZXgsIGN1cnJlbnRUZXh0KSB7XG4gICAgICAgICByZXR1cm4gY3VycmVudFRleHQuc3Vic3RyKDAsIDcyKSArICdcXHUyMDI2JztcbiAgICAgICB9KTtcbiAgICAgfVxuICAgICBmZWF0dXJlZFRpdGxlKCk7XG5cbiAgICAkKGRvY3VtZW50KS5yZWFkeShmdW5jdGlvbigpIHtcblxuICAgICAgICAoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAkKCcuc3BvcnRzcHJlc3Mgc3R5bGUnKS5yZW1vdmUoKTtcbiAgICAgICAgICAgICQoJy5nYWxsZXJ5LWl0ZW0gYScpLmFkZENsYXNzKCdsaW5rJyk7XG4gICAgICAgIFxuICAgICAgICAgICAgJCgnLnNwLXRlYW0tbmFtZScpLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgJCh0aGlzKS5pbnNlcnRBZnRlcigkKHRoaXMpLnBhcmVudCgpLmZpbmQoJ2ltZycpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KSgpO1xuXG4gICAgICAgICAgICAvLyAkKFwiI25hdi1tb2JpbGVcIikuaHRtbCgkKFwiI25hdi1tYWluXCIpLmh0bWwoKSk7XG4gICAgICAgICAgICAkKFwiI25hdi10cmlnZ2VyIC5uYXZpY29uLWJ1dHRvblwiKS5jbGljayhmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmluZm8oJ0J1cmdlciBjbGlja2VkJyk7XG4gICAgICAgICAgICAgICAgaWYgKCQoXCIudG9wYmFyXCIpLmhhc0NsYXNzKFwidG9wYmFyLS1leHBhbmRlZFwiKSkge1xuICAgICAgICAgICAgICAgICAgICAkKFwiLnRvcGJhclwiKS5yZW1vdmVDbGFzcyhcInRvcGJhci0tZXhwYW5kZWRcIik7XG4gICAgICAgICAgICAgICAgICAgICQodGhpcykucmVtb3ZlQ2xhc3MoXCJvcGVuXCIpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICQoXCIudG9wYmFyXCIpLmFkZENsYXNzKFwidG9wYmFyLS1leHBhbmRlZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgJCh0aGlzKS5hZGRDbGFzcyhcIm9wZW5cIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgXG4gICAgICAgIHZhciBiTGF6eSA9IG5ldyBCbGF6eSh7XG4gICAgICAgICAgb2Zmc2V0OiAyMCxcbiAgICAgICAgICBzZWxlY3RvcjogJy5ibGF6eScsXG4gICAgICAgICAgbG9hZEludmlzaWJsZTogZmFsc2UsXG4gICAgICAgICAgYnJlYWtwb2ludHM6IFt7XG4gICAgICAgICAgICB3aWR0aDogMzYwLCAvLyBNYXgtd2lkdGhcbiAgICAgICAgICAgIHNyYzogJ2RhdGEtc3JjLXNtYWxsJ1xuICAgICAgICAgIH1dLFxuICAgICAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgICAgICAgICQoZWxlbWVudCkucGFyZW50KCkucmVtb3ZlQ2xhc3MoJ2xvYWRpbmcnLCA1MDApO1xuICAgICAgICAgICAgdXBkYXRlQ291bnRlcigpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZXJyb3I6IGZ1bmN0aW9uKGVsZW1lbnQsIG1zZykge1xuICAgICAgICAgICAgaWYgKG1zZyA9PT0gJ21pc3NpbmcnKSB7XG4gICAgICAgICAgICAgICQoZWxlbWVudCkucGFyZW50KCkucmVtb3ZlQ2xhc3MoJ2xvYWRpbmcnLCA1MDApOyAvLyBEYXRhLXNyYyBpcyBtaXNzaW5nXG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJiTGF6eTogZGF0YS1zcmMgaXMgbWlzc2luZ1wiKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobXNnID09PSAnaW52YWxpZCcpIHtcbiAgICAgICAgICAgICAgJChlbGVtZW50KS5wYXJlbnQoKS5yZW1vdmVDbGFzcygnbG9hZGluZycsIDUwMCk7XG4gICAgICAgICAgICAgIC8vIERhdGEtc3JjIGlzIGludmFsaWRcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcImJMYXp5OiBkYXRhLXNyYyBpcyBpbnZhbGlkXCIpO1xuICAgICAgICBcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBub3QgbmVlZGVkLCBvbmx5IGhlcmUgdG8gaWxsdXN0cmF0ZSBhbW91bnQgb2YgbG9hZGVkIGltYWdlc1xuICAgICAgICB2YXIgaW1hZ2VMb2FkZWQgPSAwO1xuICAgICAgICBcbiAgICAgICAgZnVuY3Rpb24gdXBkYXRlQ291bnRlcigpIHtcbiAgICAgICAgICBpbWFnZUxvYWRlZCsrO1xuICAgICAgICAgIGNvbnNvbGUuaW5mbyhcImJMYXp5OiBJbWFnZXMgbG9hZGVkOiAlZFwiLCBpbWFnZUxvYWRlZCk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIHRhYnMoYkxhenkpO1xuXG4gICAgICAgIChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBhamF4X3VybCA9ICQoJ2JvZHknKS5hdHRyKCdkYXRhLWFqYXgtdXJsJyk7XG4gICAgICAgICAgICB2YXIgcG9zdF9vZmZzZXQgPSAwO1xuICAgICAgICAgICAgdmFyIGluY051bWJlciA9IDY7IC8vIGlsb8WbxIcgcG9zdMOzdyBkbyB6YcWCYWRvd2FuaWFcbiAgICAgICAgXG4gICAgICAgICAgICAkKCcjbG9hZF9tb3JlX3Bvc3RzJykub24oJ2NsaWNrJywgbG9hZE1vcmUpO1xuICAgICAgICAgICAgJCgnI2xvYWRfbW9yZV9zZWFyY2hlZF9wb3N0cycpLm9uKCdjbGljaycsIGxvYWRNb3JlU2VhcmNoZWQpO1xuICAgICAgICBcbiAgICAgICAgICAgIGZ1bmN0aW9uIGxvYWRNb3JlKCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdDbGlja2VkIGxvYWRfbW9yZScpO1xuICAgICAgICAgICAgICAgICQodGhpcykuaHRtbCgnxYFhZHVqxJkuLi4nKTtcbiAgICAgICAgICAgICAgICBwb3N0X29mZnNldCA9IHBhcnNlSW50KHBvc3Rfb2Zmc2V0KSArIDY7XG4gICAgICAgICAgICAgICAgJC5hamF4KHtcbiAgICAgICAgICAgICAgICAgICAgdXJsOiBhamF4X3VybCxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ1BPU1QnLFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb246ICdsb2FkX3Bvc3RzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc3Rfb2Zmc2V0OiBwb3N0X29mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgc3VjY2VzczogZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgJCgnI2xvYWRfbW9yZV9wb3N0cycpLmh0bWwoJ1pvYmFjeiBzdGFyc3plJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAkKCcjZmVlZCcpLmFwcGVuZChkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuaW5mbygnQWpheDogT0snKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJMYXp5LnJldmFsaWRhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhcmRFeGNlcnB0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIFxuICAgICAgICBcbiAgICAgICAgICAgIGZ1bmN0aW9uIGxvYWRNb3JlU2VhcmNoZWQoKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ0NsaWNrZWQgbG9hZF9tb3JlX3NlYXJjaGVkJyk7XG4gICAgICAgICAgICAgICAgJCh0aGlzKS5odG1sKCfFgWFkdWrEmS4uLicpO1xuICAgICAgICAgICAgICAgIHBvc3Rfb2Zmc2V0ID0gcGFyc2VJbnQocG9zdF9vZmZzZXQpICsgNjtcbiAgICAgICAgICAgICAgICAkLmFqYXgoe1xuICAgICAgICAgICAgICAgICAgICB1cmw6IGFqYXhfdXJsLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbjogJ2xvYWRfc2VhcmNoZWRfcG9zdHMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zdF9vZmZzZXQ6IHBvc3Rfb2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgczogZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJzZWFyY2hRdWVyeVwiKS5nZXRBdHRyaWJ1dGUoXCJkYXRhLXNlYXJjaC1xdWVyeVwiKVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBzdWNjZXNzOiBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAkKCcjbG9hZF9tb3JlX3NlYXJjaGVkX3Bvc3RzJykuaHRtbCgnV2nEmWNlaiB3eW5pa8OzdycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgJCgnI2ZlZWQnKS5hcHBlbmQoZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmluZm8oJ0FqYXg6IE9LJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBiTGF6eS5yZXZhbGlkYXRlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXJkRXhjZXJwdCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICB9KSgpO1xuXG4gICAgfSk7XG59KTtcblxuKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoW10sIGZhY3RvcnkpO1xuXHRlbHNlIHtcblx0XHR2YXIgYSA9IGZhY3RvcnkoKTtcblx0XHRmb3IodmFyIGkgaW4gYSkgKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyA/IGV4cG9ydHMgOiByb290KVtpXSA9IGFbaV07XG5cdH1cbn0pKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyA/IHNlbGYgOiB0aGlzLCBmdW5jdGlvbigpIHtcbnJldHVybiAvKioqKioqLyAoZnVuY3Rpb24obW9kdWxlcykgeyAvLyB3ZWJwYWNrQm9vdHN0cmFwXG4vKioqKioqLyBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4vKioqKioqLyBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4vKioqKioqLyBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbi8qKioqKiovIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuLyoqKioqKi8gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbi8qKioqKiovIFx0XHRcdGk6IG1vZHVsZUlkLFxuLyoqKioqKi8gXHRcdFx0bDogZmFsc2UsXG4vKioqKioqLyBcdFx0XHRleHBvcnRzOiB7fVxuLyoqKioqKi8gXHRcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuLyoqKioqKi8gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4vKioqKioqLyBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuLyoqKioqKi8gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbi8qKioqKiovIFx0fVxuLyoqKioqKi9cbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuLyoqKioqKi8gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbi8qKioqKiovIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7XG4vKioqKioqLyBcdFx0XHRcdGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4vKioqKioqLyBcdFx0XHRcdGVudW1lcmFibGU6IHRydWUsXG4vKioqKioqLyBcdFx0XHRcdGdldDogZ2V0dGVyXG4vKioqKioqLyBcdFx0XHR9KTtcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbi8qKioqKiovIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbi8qKioqKiovIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4vKioqKioqLyBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuLyoqKioqKi8gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbi8qKioqKiovIFx0XHRyZXR1cm4gZ2V0dGVyO1xuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbi8qKioqKiovIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gNyk7XG4vKioqKioqLyB9KVxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIChbXG4vKiAwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbnZhciBnO1xuXG4vLyBUaGlzIHdvcmtzIGluIG5vbi1zdHJpY3QgbW9kZVxuZyA9IChmdW5jdGlvbigpIHtcblx0cmV0dXJuIHRoaXM7XG59KSgpO1xuXG50cnkge1xuXHQvLyBUaGlzIHdvcmtzIGlmIGV2YWwgaXMgYWxsb3dlZCAoc2VlIENTUClcblx0ZyA9IGcgfHwgRnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpIHx8ICgxLGV2YWwpKFwidGhpc1wiKTtcbn0gY2F0Y2goZSkge1xuXHQvLyBUaGlzIHdvcmtzIGlmIHRoZSB3aW5kb3cgcmVmZXJlbmNlIGlzIGF2YWlsYWJsZVxuXHRpZih0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiKVxuXHRcdGcgPSB3aW5kb3c7XG59XG5cbi8vIGcgY2FuIHN0aWxsIGJlIHVuZGVmaW5lZCwgYnV0IG5vdGhpbmcgdG8gZG8gYWJvdXQgaXQuLi5cbi8vIFdlIHJldHVybiB1bmRlZmluZWQsIGluc3RlYWQgb2Ygbm90aGluZyBoZXJlLCBzbyBpdCdzXG4vLyBlYXNpZXIgdG8gaGFuZGxlIHRoaXMgY2FzZS4gaWYoIWdsb2JhbCkgeyAuLi59XG5cbm1vZHVsZS5leHBvcnRzID0gZztcblxuXG4vKioqLyB9KSxcbi8qIDEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9OyAvKiBnbG9iYWxzIGpRdWVyeSAqL1xuXG5leHBvcnRzLmxvcnkgPSBsb3J5O1xuXG52YXIgX2RldGVjdFByZWZpeGVzID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcblxudmFyIF9kZXRlY3RQcmVmaXhlczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9kZXRlY3RQcmVmaXhlcyk7XG5cbnZhciBfZGV0ZWN0U3VwcG9ydHNQYXNzaXZlID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcblxudmFyIF9kZXRlY3RTdXBwb3J0c1Bhc3NpdmUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZGV0ZWN0U3VwcG9ydHNQYXNzaXZlKTtcblxudmFyIF9kaXNwYXRjaEV2ZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcblxudmFyIF9kaXNwYXRjaEV2ZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2Rpc3BhdGNoRXZlbnQpO1xuXG52YXIgX2RlZmF1bHRzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcblxudmFyIF9kZWZhdWx0czIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9kZWZhdWx0cyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBzbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcblxuZnVuY3Rpb24gbG9yeShzbGlkZXIsIG9wdHMpIHtcbiAgICB2YXIgcG9zaXRpb24gPSB2b2lkIDA7XG4gICAgdmFyIHNsaWRlc1dpZHRoID0gdm9pZCAwO1xuICAgIHZhciBmcmFtZVdpZHRoID0gdm9pZCAwO1xuICAgIHZhciBzbGlkZXMgPSB2b2lkIDA7XG5cbiAgICAvKipcbiAgICAgKiBzbGlkZXIgRE9NIGVsZW1lbnRzXG4gICAgICovXG4gICAgdmFyIGZyYW1lID0gdm9pZCAwO1xuICAgIHZhciBzbGlkZUNvbnRhaW5lciA9IHZvaWQgMDtcbiAgICB2YXIgcHJldkN0cmwgPSB2b2lkIDA7XG4gICAgdmFyIG5leHRDdHJsID0gdm9pZCAwO1xuICAgIHZhciBwcmVmaXhlcyA9IHZvaWQgMDtcbiAgICB2YXIgdHJhbnNpdGlvbkVuZENhbGxiYWNrID0gdm9pZCAwO1xuXG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICB2YXIgb3B0aW9ucyA9IHt9O1xuICAgIHZhciB0b3VjaEV2ZW50UGFyYW1zID0gKDAsIF9kZXRlY3RTdXBwb3J0c1Bhc3NpdmUyLmRlZmF1bHQpKCkgPyB7IHBhc3NpdmU6IHRydWUgfSA6IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogaWYgb2JqZWN0IGlzIGpRdWVyeSBjb252ZXJ0IHRvIG5hdGl2ZSBET00gZWxlbWVudFxuICAgICAqL1xuICAgIGlmICh0eXBlb2YgalF1ZXJ5ICE9PSAndW5kZWZpbmVkJyAmJiBzbGlkZXIgaW5zdGFuY2VvZiBqUXVlcnkpIHtcbiAgICAgICAgc2xpZGVyID0gc2xpZGVyWzBdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHByaXZhdGVcbiAgICAgKiBzZXQgYWN0aXZlIGNsYXNzIHRvIGVsZW1lbnQgd2hpY2ggaXMgdGhlIGN1cnJlbnQgc2xpZGVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzZXRBY3RpdmVFbGVtZW50KHNsaWRlcywgY3VycmVudEluZGV4KSB7XG4gICAgICAgIHZhciBfb3B0aW9ucyA9IG9wdGlvbnMsXG4gICAgICAgICAgICBjbGFzc05hbWVBY3RpdmVTbGlkZSA9IF9vcHRpb25zLmNsYXNzTmFtZUFjdGl2ZVNsaWRlO1xuXG5cbiAgICAgICAgc2xpZGVzLmZvckVhY2goZnVuY3Rpb24gKGVsZW1lbnQsIGluZGV4KSB7XG4gICAgICAgICAgICBpZiAoZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoY2xhc3NOYW1lQWN0aXZlU2xpZGUpKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKGNsYXNzTmFtZUFjdGl2ZVNsaWRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgc2xpZGVzW2N1cnJlbnRJbmRleF0uY2xhc3NMaXN0LmFkZChjbGFzc05hbWVBY3RpdmVTbGlkZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogcHJpdmF0ZVxuICAgICAqIHNldHVwSW5maW5pdGU6IGZ1bmN0aW9uIHRvIHNldHVwIGlmIGluZmluaXRlIGlzIHNldFxuICAgICAqXG4gICAgICogQHBhcmFtICB7YXJyYXl9IHNsaWRlQXJyYXlcbiAgICAgKiBAcmV0dXJuIHthcnJheX0gYXJyYXkgb2YgdXBkYXRlZCBzbGlkZUNvbnRhaW5lciBlbGVtZW50c1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNldHVwSW5maW5pdGUoc2xpZGVBcnJheSkge1xuICAgICAgICB2YXIgX29wdGlvbnMyID0gb3B0aW9ucyxcbiAgICAgICAgICAgIGluZmluaXRlID0gX29wdGlvbnMyLmluZmluaXRlO1xuXG5cbiAgICAgICAgdmFyIGZyb250ID0gc2xpZGVBcnJheS5zbGljZSgwLCBpbmZpbml0ZSk7XG4gICAgICAgIHZhciBiYWNrID0gc2xpZGVBcnJheS5zbGljZShzbGlkZUFycmF5Lmxlbmd0aCAtIGluZmluaXRlLCBzbGlkZUFycmF5Lmxlbmd0aCk7XG5cbiAgICAgICAgZnJvbnQuZm9yRWFjaChmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICAgICAgdmFyIGNsb25lZCA9IGVsZW1lbnQuY2xvbmVOb2RlKHRydWUpO1xuXG4gICAgICAgICAgICBzbGlkZUNvbnRhaW5lci5hcHBlbmRDaGlsZChjbG9uZWQpO1xuICAgICAgICB9KTtcblxuICAgICAgICBiYWNrLnJldmVyc2UoKS5mb3JFYWNoKGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgICAgICB2YXIgY2xvbmVkID0gZWxlbWVudC5jbG9uZU5vZGUodHJ1ZSk7XG5cbiAgICAgICAgICAgIHNsaWRlQ29udGFpbmVyLmluc2VydEJlZm9yZShjbG9uZWQsIHNsaWRlQ29udGFpbmVyLmZpcnN0Q2hpbGQpO1xuICAgICAgICB9KTtcblxuICAgICAgICBzbGlkZUNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKHByZWZpeGVzLnRyYW5zaXRpb25FbmQsIG9uVHJhbnNpdGlvbkVuZCk7XG5cbiAgICAgICAgcmV0dXJuIHNsaWNlLmNhbGwoc2xpZGVDb250YWluZXIuY2hpbGRyZW4pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFtkaXNwYXRjaFNsaWRlckV2ZW50IGRlc2NyaXB0aW9uXVxuICAgICAqIEByZXR1cm4ge1t0eXBlXX0gW2Rlc2NyaXB0aW9uXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRpc3BhdGNoU2xpZGVyRXZlbnQocGhhc2UsIHR5cGUsIGRldGFpbCkge1xuICAgICAgICAoMCwgX2Rpc3BhdGNoRXZlbnQyLmRlZmF1bHQpKHNsaWRlciwgcGhhc2UgKyAnLmxvcnkuJyArIHR5cGUsIGRldGFpbCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogdHJhbnNsYXRlcyB0byBhIGdpdmVuIHBvc2l0aW9uIGluIGEgZ2l2ZW4gdGltZSBpbiBtaWxsaXNlY29uZHNcbiAgICAgKlxuICAgICAqIEB0byAgICAgICAge251bWJlcn0gbnVtYmVyIGluIHBpeGVscyB3aGVyZSB0byB0cmFuc2xhdGUgdG9cbiAgICAgKiBAZHVyYXRpb24gIHtudW1iZXJ9IHRpbWUgaW4gbWlsbGlzZWNvbmRzIGZvciB0aGUgdHJhbnNpc3Rpb25cbiAgICAgKiBAZWFzZSAgICAgIHtzdHJpbmd9IGVhc2luZyBjc3MgcHJvcGVydHlcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0cmFuc2xhdGUodG8sIGR1cmF0aW9uLCBlYXNlKSB7XG4gICAgICAgIHZhciBzdHlsZSA9IHNsaWRlQ29udGFpbmVyICYmIHNsaWRlQ29udGFpbmVyLnN0eWxlO1xuXG4gICAgICAgIGlmIChzdHlsZSkge1xuICAgICAgICAgICAgc3R5bGVbcHJlZml4ZXMudHJhbnNpdGlvbiArICdUaW1pbmdGdW5jdGlvbiddID0gZWFzZTtcbiAgICAgICAgICAgIHN0eWxlW3ByZWZpeGVzLnRyYW5zaXRpb24gKyAnRHVyYXRpb24nXSA9IGR1cmF0aW9uICsgJ21zJztcblxuICAgICAgICAgICAgaWYgKHByZWZpeGVzLmhhc1RyYW5zbGF0ZTNkKSB7XG4gICAgICAgICAgICAgICAgc3R5bGVbcHJlZml4ZXMudHJhbnNmb3JtXSA9ICd0cmFuc2xhdGUzZCgnICsgdG8gKyAncHgsIDAsIDApJztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc3R5bGVbcHJlZml4ZXMudHJhbnNmb3JtXSA9ICd0cmFuc2xhdGUoJyArIHRvICsgJ3B4LCAwKSc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiByZXR1cm5zIGFuIGVsZW1lbnQncyB3aWR0aFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGVsZW1lbnRXaWR0aChlbGVtZW50KSB7XG4gICAgICAgIHJldHVybiBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoIHx8IGVsZW1lbnQub2Zmc2V0V2lkdGg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogc2xpZGVmdW5jdGlvbiBjYWxsZWQgYnkgcHJldiwgbmV4dCAmIHRvdWNoZW5kXG4gICAgICpcbiAgICAgKiBkZXRlcm1pbmUgbmV4dEluZGV4IGFuZCBzbGlkZSB0byBuZXh0IHBvc3Rpb25cbiAgICAgKiB1bmRlciByZXN0cmljdGlvbnMgb2YgdGhlIGRlZmluZWQgb3B0aW9uc1xuICAgICAqXG4gICAgICogQGRpcmVjdGlvbiAge2Jvb2xlYW59XG4gICAgICovXG4gICAgZnVuY3Rpb24gc2xpZGUobmV4dEluZGV4LCBkaXJlY3Rpb24pIHtcbiAgICAgICAgdmFyIF9vcHRpb25zMyA9IG9wdGlvbnMsXG4gICAgICAgICAgICBzbGlkZVNwZWVkID0gX29wdGlvbnMzLnNsaWRlU3BlZWQsXG4gICAgICAgICAgICBzbGlkZXNUb1Njcm9sbCA9IF9vcHRpb25zMy5zbGlkZXNUb1Njcm9sbCxcbiAgICAgICAgICAgIGluZmluaXRlID0gX29wdGlvbnMzLmluZmluaXRlLFxuICAgICAgICAgICAgcmV3aW5kID0gX29wdGlvbnMzLnJld2luZCxcbiAgICAgICAgICAgIHJld2luZFNwZWVkID0gX29wdGlvbnMzLnJld2luZFNwZWVkLFxuICAgICAgICAgICAgZWFzZSA9IF9vcHRpb25zMy5lYXNlLFxuICAgICAgICAgICAgY2xhc3NOYW1lQWN0aXZlU2xpZGUgPSBfb3B0aW9uczMuY2xhc3NOYW1lQWN0aXZlU2xpZGU7XG5cblxuICAgICAgICB2YXIgZHVyYXRpb24gPSBzbGlkZVNwZWVkO1xuXG4gICAgICAgIHZhciBuZXh0U2xpZGUgPSBkaXJlY3Rpb24gPyBpbmRleCArIDEgOiBpbmRleCAtIDE7XG4gICAgICAgIHZhciBtYXhPZmZzZXQgPSBNYXRoLnJvdW5kKHNsaWRlc1dpZHRoIC0gZnJhbWVXaWR0aCk7XG5cbiAgICAgICAgZGlzcGF0Y2hTbGlkZXJFdmVudCgnYmVmb3JlJywgJ3NsaWRlJywge1xuICAgICAgICAgICAgaW5kZXg6IGluZGV4LFxuICAgICAgICAgICAgbmV4dFNsaWRlOiBuZXh0U2xpZGVcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlc2V0IGNvbnRyb2wgY2xhc3Nlc1xuICAgICAgICAgKi9cbiAgICAgICAgaWYgKHByZXZDdHJsKSB7XG4gICAgICAgICAgICBwcmV2Q3RybC5jbGFzc0xpc3QucmVtb3ZlKCdkaXNhYmxlZCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuZXh0Q3RybCkge1xuICAgICAgICAgICAgbmV4dEN0cmwuY2xhc3NMaXN0LnJlbW92ZSgnZGlzYWJsZWQnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgbmV4dEluZGV4ICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgaWYgKGRpcmVjdGlvbikge1xuICAgICAgICAgICAgICAgIGlmIChpbmZpbml0ZSAmJiBpbmRleCArIGluZmluaXRlICogMiAhPT0gc2xpZGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBuZXh0SW5kZXggPSBpbmRleCArIChpbmZpbml0ZSAtIGluZGV4ICUgaW5maW5pdGUpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG5leHRJbmRleCA9IGluZGV4ICsgc2xpZGVzVG9TY3JvbGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5maW5pdGUgJiYgaW5kZXggJSBpbmZpbml0ZSAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBuZXh0SW5kZXggPSBpbmRleCAtIGluZGV4ICUgaW5maW5pdGU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dEluZGV4ID0gaW5kZXggLSBzbGlkZXNUb1Njcm9sbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBuZXh0SW5kZXggPSBNYXRoLm1pbihNYXRoLm1heChuZXh0SW5kZXgsIDApLCBzbGlkZXMubGVuZ3RoIC0gMSk7XG5cbiAgICAgICAgaWYgKGluZmluaXRlICYmIGRpcmVjdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBuZXh0SW5kZXggKz0gaW5maW5pdGU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbmV4dE9mZnNldCA9IE1hdGgubWluKE1hdGgubWF4KHNsaWRlc1tuZXh0SW5kZXhdLm9mZnNldExlZnQgKiAtMSwgbWF4T2Zmc2V0ICogLTEpLCAwKTtcblxuICAgICAgICBpZiAocmV3aW5kICYmIE1hdGguYWJzKHBvc2l0aW9uLngpID09PSBtYXhPZmZzZXQgJiYgZGlyZWN0aW9uKSB7XG4gICAgICAgICAgICBuZXh0T2Zmc2V0ID0gMDtcbiAgICAgICAgICAgIG5leHRJbmRleCA9IDA7XG4gICAgICAgICAgICBkdXJhdGlvbiA9IHJld2luZFNwZWVkO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHRyYW5zbGF0ZSB0byB0aGUgbmV4dE9mZnNldCBieSBhIGRlZmluZWQgZHVyYXRpb24gYW5kIGVhc2UgZnVuY3Rpb25cbiAgICAgICAgICovXG4gICAgICAgIHRyYW5zbGF0ZShuZXh0T2Zmc2V0LCBkdXJhdGlvbiwgZWFzZSk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHVwZGF0ZSB0aGUgcG9zaXRpb24gd2l0aCB0aGUgbmV4dCBwb3NpdGlvblxuICAgICAgICAgKi9cbiAgICAgICAgcG9zaXRpb24ueCA9IG5leHRPZmZzZXQ7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHVwZGF0ZSB0aGUgaW5kZXggd2l0aCB0aGUgbmV4dEluZGV4IG9ubHkgaWZcbiAgICAgICAgICogdGhlIG9mZnNldCBvZiB0aGUgbmV4dEluZGV4IGlzIGluIHRoZSByYW5nZSBvZiB0aGUgbWF4T2Zmc2V0XG4gICAgICAgICAqL1xuICAgICAgICBpZiAoc2xpZGVzW25leHRJbmRleF0ub2Zmc2V0TGVmdCA8PSBtYXhPZmZzZXQpIHtcbiAgICAgICAgICAgIGluZGV4ID0gbmV4dEluZGV4O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGluZmluaXRlICYmIChuZXh0SW5kZXggPT09IHNsaWRlcy5sZW5ndGggLSBpbmZpbml0ZSB8fCBuZXh0SW5kZXggPT09IHNsaWRlcy5sZW5ndGggLSBzbGlkZXMubGVuZ3RoICUgaW5maW5pdGUgfHwgbmV4dEluZGV4ID09PSAwKSkge1xuICAgICAgICAgICAgaWYgKGRpcmVjdGlvbikge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gaW5maW5pdGU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghZGlyZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBzbGlkZXMubGVuZ3RoIC0gaW5maW5pdGUgKiAyO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwb3NpdGlvbi54ID0gc2xpZGVzW2luZGV4XS5vZmZzZXRMZWZ0ICogLTE7XG5cbiAgICAgICAgICAgIHRyYW5zaXRpb25FbmRDYWxsYmFjayA9IGZ1bmN0aW9uIHRyYW5zaXRpb25FbmRDYWxsYmFjaygpIHtcbiAgICAgICAgICAgICAgICB0cmFuc2xhdGUoc2xpZGVzW2luZGV4XS5vZmZzZXRMZWZ0ICogLTEsIDAsIHVuZGVmaW5lZCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNsYXNzTmFtZUFjdGl2ZVNsaWRlKSB7XG4gICAgICAgICAgICBzZXRBY3RpdmVFbGVtZW50KHNsaWNlLmNhbGwoc2xpZGVzKSwgaW5kZXgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHVwZGF0ZSBjbGFzc2VzIGZvciBuZXh0IGFuZCBwcmV2IGFycm93c1xuICAgICAgICAgKiBiYXNlZCBvbiB1c2VyIHNldHRpbmdzXG4gICAgICAgICAqL1xuICAgICAgICBpZiAocHJldkN0cmwgJiYgIWluZmluaXRlICYmIG5leHRJbmRleCA9PT0gMCkge1xuICAgICAgICAgICAgcHJldkN0cmwuY2xhc3NMaXN0LmFkZCgnZGlzYWJsZWQnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChuZXh0Q3RybCAmJiAhaW5maW5pdGUgJiYgIXJld2luZCAmJiBuZXh0SW5kZXggKyAxID09PSBzbGlkZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBuZXh0Q3RybC5jbGFzc0xpc3QuYWRkKCdkaXNhYmxlZCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgZGlzcGF0Y2hTbGlkZXJFdmVudCgnYWZ0ZXInLCAnc2xpZGUnLCB7XG4gICAgICAgICAgICBjdXJyZW50U2xpZGU6IGluZGV4XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHB1YmxpY1xuICAgICAqIHNldHVwIGZ1bmN0aW9uXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2V0dXAoKSB7XG4gICAgICAgIGRpc3BhdGNoU2xpZGVyRXZlbnQoJ2JlZm9yZScsICdpbml0Jyk7XG5cbiAgICAgICAgcHJlZml4ZXMgPSAoMCwgX2RldGVjdFByZWZpeGVzMi5kZWZhdWx0KSgpO1xuICAgICAgICBvcHRpb25zID0gX2V4dGVuZHMoe30sIF9kZWZhdWx0czIuZGVmYXVsdCwgb3B0cyk7XG5cbiAgICAgICAgdmFyIF9vcHRpb25zNCA9IG9wdGlvbnMsXG4gICAgICAgICAgICBjbGFzc05hbWVGcmFtZSA9IF9vcHRpb25zNC5jbGFzc05hbWVGcmFtZSxcbiAgICAgICAgICAgIGNsYXNzTmFtZVNsaWRlQ29udGFpbmVyID0gX29wdGlvbnM0LmNsYXNzTmFtZVNsaWRlQ29udGFpbmVyLFxuICAgICAgICAgICAgY2xhc3NOYW1lUHJldkN0cmwgPSBfb3B0aW9uczQuY2xhc3NOYW1lUHJldkN0cmwsXG4gICAgICAgICAgICBjbGFzc05hbWVOZXh0Q3RybCA9IF9vcHRpb25zNC5jbGFzc05hbWVOZXh0Q3RybCxcbiAgICAgICAgICAgIGVuYWJsZU1vdXNlRXZlbnRzID0gX29wdGlvbnM0LmVuYWJsZU1vdXNlRXZlbnRzLFxuICAgICAgICAgICAgY2xhc3NOYW1lQWN0aXZlU2xpZGUgPSBfb3B0aW9uczQuY2xhc3NOYW1lQWN0aXZlU2xpZGUsXG4gICAgICAgICAgICBpbml0aWFsSW5kZXggPSBfb3B0aW9uczQuaW5pdGlhbEluZGV4O1xuXG5cbiAgICAgICAgaW5kZXggPSBpbml0aWFsSW5kZXg7XG4gICAgICAgIGZyYW1lID0gc2xpZGVyLmdldEVsZW1lbnRzQnlDbGFzc05hbWUoY2xhc3NOYW1lRnJhbWUpWzBdO1xuICAgICAgICBzbGlkZUNvbnRhaW5lciA9IGZyYW1lLmdldEVsZW1lbnRzQnlDbGFzc05hbWUoY2xhc3NOYW1lU2xpZGVDb250YWluZXIpWzBdO1xuICAgICAgICBwcmV2Q3RybCA9IHNsaWRlci5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKGNsYXNzTmFtZVByZXZDdHJsKVswXTtcbiAgICAgICAgbmV4dEN0cmwgPSBzbGlkZXIuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShjbGFzc05hbWVOZXh0Q3RybClbMF07XG5cbiAgICAgICAgcG9zaXRpb24gPSB7XG4gICAgICAgICAgICB4OiBzbGlkZUNvbnRhaW5lci5vZmZzZXRMZWZ0LFxuICAgICAgICAgICAgeTogc2xpZGVDb250YWluZXIub2Zmc2V0VG9wXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuaW5maW5pdGUpIHtcbiAgICAgICAgICAgIHNsaWRlcyA9IHNldHVwSW5maW5pdGUoc2xpY2UuY2FsbChzbGlkZUNvbnRhaW5lci5jaGlsZHJlbikpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2xpZGVzID0gc2xpY2UuY2FsbChzbGlkZUNvbnRhaW5lci5jaGlsZHJlbik7XG5cbiAgICAgICAgICAgIGlmIChwcmV2Q3RybCkge1xuICAgICAgICAgICAgICAgIHByZXZDdHJsLmNsYXNzTGlzdC5hZGQoJ2Rpc2FibGVkJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChuZXh0Q3RybCAmJiBzbGlkZXMubGVuZ3RoID09PSAxICYmICFvcHRpb25zLnJld2luZCkge1xuICAgICAgICAgICAgICAgIG5leHRDdHJsLmNsYXNzTGlzdC5hZGQoJ2Rpc2FibGVkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXNldCgpO1xuXG4gICAgICAgIGlmIChjbGFzc05hbWVBY3RpdmVTbGlkZSkge1xuICAgICAgICAgICAgc2V0QWN0aXZlRWxlbWVudChzbGlkZXMsIGluZGV4KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwcmV2Q3RybCAmJiBuZXh0Q3RybCkge1xuICAgICAgICAgICAgcHJldkN0cmwuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBwcmV2KTtcbiAgICAgICAgICAgIG5leHRDdHJsLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgbmV4dCk7XG4gICAgICAgIH1cblxuICAgICAgICBmcmFtZS5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0Jywgb25Ub3VjaHN0YXJ0LCB0b3VjaEV2ZW50UGFyYW1zKTtcblxuICAgICAgICBpZiAoZW5hYmxlTW91c2VFdmVudHMpIHtcbiAgICAgICAgICAgIGZyYW1lLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIG9uVG91Y2hzdGFydCk7XG4gICAgICAgICAgICBmcmFtZS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIG9uQ2xpY2spO1xuICAgICAgICB9XG5cbiAgICAgICAgb3B0aW9ucy53aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgb25SZXNpemUpO1xuXG4gICAgICAgIGRpc3BhdGNoU2xpZGVyRXZlbnQoJ2FmdGVyJywgJ2luaXQnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBwdWJsaWNcbiAgICAgKiByZXNldCBmdW5jdGlvbjogY2FsbGVkIG9uIHJlc2l6ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgICAgICB2YXIgX29wdGlvbnM1ID0gb3B0aW9ucyxcbiAgICAgICAgICAgIGluZmluaXRlID0gX29wdGlvbnM1LmluZmluaXRlLFxuICAgICAgICAgICAgZWFzZSA9IF9vcHRpb25zNS5lYXNlLFxuICAgICAgICAgICAgcmV3aW5kU3BlZWQgPSBfb3B0aW9uczUucmV3aW5kU3BlZWQsXG4gICAgICAgICAgICByZXdpbmRPblJlc2l6ZSA9IF9vcHRpb25zNS5yZXdpbmRPblJlc2l6ZSxcbiAgICAgICAgICAgIGNsYXNzTmFtZUFjdGl2ZVNsaWRlID0gX29wdGlvbnM1LmNsYXNzTmFtZUFjdGl2ZVNsaWRlLFxuICAgICAgICAgICAgaW5pdGlhbEluZGV4ID0gX29wdGlvbnM1LmluaXRpYWxJbmRleDtcblxuXG4gICAgICAgIHNsaWRlc1dpZHRoID0gZWxlbWVudFdpZHRoKHNsaWRlQ29udGFpbmVyKTtcbiAgICAgICAgZnJhbWVXaWR0aCA9IGVsZW1lbnRXaWR0aChmcmFtZSk7XG5cbiAgICAgICAgaWYgKGZyYW1lV2lkdGggPT09IHNsaWRlc1dpZHRoKSB7XG4gICAgICAgICAgICBzbGlkZXNXaWR0aCA9IHNsaWRlcy5yZWR1Y2UoZnVuY3Rpb24gKHByZXZpb3VzVmFsdWUsIHNsaWRlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByZXZpb3VzVmFsdWUgKyBlbGVtZW50V2lkdGgoc2xpZGUpO1xuICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmV3aW5kT25SZXNpemUpIHtcbiAgICAgICAgICAgIGluZGV4ID0gaW5pdGlhbEluZGV4O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZWFzZSA9IG51bGw7XG4gICAgICAgICAgICByZXdpbmRTcGVlZCA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaW5maW5pdGUpIHtcbiAgICAgICAgICAgIHRyYW5zbGF0ZShzbGlkZXNbaW5kZXggKyBpbmZpbml0ZV0ub2Zmc2V0TGVmdCAqIC0xLCAwLCBudWxsKTtcblxuICAgICAgICAgICAgaW5kZXggPSBpbmRleCArIGluZmluaXRlO1xuICAgICAgICAgICAgcG9zaXRpb24ueCA9IHNsaWRlc1tpbmRleF0ub2Zmc2V0TGVmdCAqIC0xO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdHJhbnNsYXRlKHNsaWRlc1tpbmRleF0ub2Zmc2V0TGVmdCAqIC0xLCByZXdpbmRTcGVlZCwgZWFzZSk7XG4gICAgICAgICAgICBwb3NpdGlvbi54ID0gc2xpZGVzW2luZGV4XS5vZmZzZXRMZWZ0ICogLTE7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY2xhc3NOYW1lQWN0aXZlU2xpZGUpIHtcbiAgICAgICAgICAgIHNldEFjdGl2ZUVsZW1lbnQoc2xpY2UuY2FsbChzbGlkZXMpLCBpbmRleCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBwdWJsaWNcbiAgICAgKiBzbGlkZVRvOiBjYWxsZWQgb24gY2xpY2toYW5kbGVyXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2xpZGVUbyhpbmRleCkge1xuICAgICAgICBzbGlkZShpbmRleCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogcHVibGljXG4gICAgICogcmV0dXJuSW5kZXggZnVuY3Rpb246IGNhbGxlZCBvbiBjbGlja2hhbmRsZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZXR1cm5JbmRleCgpIHtcbiAgICAgICAgcmV0dXJuIGluZGV4IC0gb3B0aW9ucy5pbmZpbml0ZSB8fCAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHB1YmxpY1xuICAgICAqIHByZXYgZnVuY3Rpb246IGNhbGxlZCBvbiBjbGlja2hhbmRsZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwcmV2KCkge1xuICAgICAgICBzbGlkZShmYWxzZSwgZmFsc2UpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHB1YmxpY1xuICAgICAqIG5leHQgZnVuY3Rpb246IGNhbGxlZCBvbiBjbGlja2hhbmRsZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgICBzbGlkZShmYWxzZSwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogcHVibGljXG4gICAgICogZGVzdHJveSBmdW5jdGlvbjogY2FsbGVkIHRvIGdyYWNlZnVsbHkgZGVzdHJveSB0aGUgbG9yeSBpbnN0YW5jZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICAgIGRpc3BhdGNoU2xpZGVyRXZlbnQoJ2JlZm9yZScsICdkZXN0cm95Jyk7XG5cbiAgICAgICAgLy8gcmVtb3ZlIGV2ZW50IGxpc3RlbmVyc1xuICAgICAgICBmcmFtZS5yZW1vdmVFdmVudExpc3RlbmVyKHByZWZpeGVzLnRyYW5zaXRpb25FbmQsIG9uVHJhbnNpdGlvbkVuZCk7XG4gICAgICAgIGZyYW1lLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCBvblRvdWNoc3RhcnQsIHRvdWNoRXZlbnRQYXJhbXMpO1xuICAgICAgICBmcmFtZS5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCBvblRvdWNobW92ZSwgdG91Y2hFdmVudFBhcmFtcyk7XG4gICAgICAgIGZyYW1lLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgb25Ub3VjaGVuZCk7XG4gICAgICAgIGZyYW1lLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIG9uVG91Y2htb3ZlKTtcbiAgICAgICAgZnJhbWUucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgb25Ub3VjaHN0YXJ0KTtcbiAgICAgICAgZnJhbWUucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIG9uVG91Y2hlbmQpO1xuICAgICAgICBmcmFtZS5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWxlYXZlJywgb25Ub3VjaGVuZCk7XG4gICAgICAgIGZyYW1lLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgb25DbGljayk7XG5cbiAgICAgICAgb3B0aW9ucy53aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgb25SZXNpemUpO1xuXG4gICAgICAgIGlmIChwcmV2Q3RybCkge1xuICAgICAgICAgICAgcHJldkN0cmwucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCBwcmV2KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChuZXh0Q3RybCkge1xuICAgICAgICAgICAgbmV4dEN0cmwucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCBuZXh0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJlbW92ZSBjbG9uZWQgc2xpZGVzIGlmIGluZmluaXRlIGlzIHNldFxuICAgICAgICBpZiAob3B0aW9ucy5pbmZpbml0ZSkge1xuICAgICAgICAgICAgQXJyYXkuYXBwbHkobnVsbCwgQXJyYXkob3B0aW9ucy5pbmZpbml0ZSkpLmZvckVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHNsaWRlQ29udGFpbmVyLnJlbW92ZUNoaWxkKHNsaWRlQ29udGFpbmVyLmZpcnN0Q2hpbGQpO1xuICAgICAgICAgICAgICAgIHNsaWRlQ29udGFpbmVyLnJlbW92ZUNoaWxkKHNsaWRlQ29udGFpbmVyLmxhc3RDaGlsZCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRpc3BhdGNoU2xpZGVyRXZlbnQoJ2FmdGVyJywgJ2Rlc3Ryb3knKTtcbiAgICB9XG5cbiAgICAvLyBldmVudCBoYW5kbGluZ1xuXG4gICAgdmFyIHRvdWNoT2Zmc2V0ID0gdm9pZCAwO1xuICAgIHZhciBkZWx0YSA9IHZvaWQgMDtcbiAgICB2YXIgaXNTY3JvbGxpbmcgPSB2b2lkIDA7XG5cbiAgICBmdW5jdGlvbiBvblRyYW5zaXRpb25FbmQoKSB7XG4gICAgICAgIGlmICh0cmFuc2l0aW9uRW5kQ2FsbGJhY2spIHtcbiAgICAgICAgICAgIHRyYW5zaXRpb25FbmRDYWxsYmFjaygpO1xuXG4gICAgICAgICAgICB0cmFuc2l0aW9uRW5kQ2FsbGJhY2sgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvblRvdWNoc3RhcnQoZXZlbnQpIHtcbiAgICAgICAgdmFyIF9vcHRpb25zNiA9IG9wdGlvbnMsXG4gICAgICAgICAgICBlbmFibGVNb3VzZUV2ZW50cyA9IF9vcHRpb25zNi5lbmFibGVNb3VzZUV2ZW50cztcblxuICAgICAgICB2YXIgdG91Y2hlcyA9IGV2ZW50LnRvdWNoZXMgPyBldmVudC50b3VjaGVzWzBdIDogZXZlbnQ7XG5cbiAgICAgICAgaWYgKGVuYWJsZU1vdXNlRXZlbnRzKSB7XG4gICAgICAgICAgICBmcmFtZS5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBvblRvdWNobW92ZSk7XG4gICAgICAgICAgICBmcmFtZS5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgb25Ub3VjaGVuZCk7XG4gICAgICAgICAgICBmcmFtZS5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWxlYXZlJywgb25Ub3VjaGVuZCk7XG4gICAgICAgIH1cblxuICAgICAgICBmcmFtZS5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCBvblRvdWNobW92ZSwgdG91Y2hFdmVudFBhcmFtcyk7XG4gICAgICAgIGZyYW1lLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgb25Ub3VjaGVuZCk7XG5cbiAgICAgICAgdmFyIHBhZ2VYID0gdG91Y2hlcy5wYWdlWCxcbiAgICAgICAgICAgIHBhZ2VZID0gdG91Y2hlcy5wYWdlWTtcblxuXG4gICAgICAgIHRvdWNoT2Zmc2V0ID0ge1xuICAgICAgICAgICAgeDogcGFnZVgsXG4gICAgICAgICAgICB5OiBwYWdlWSxcbiAgICAgICAgICAgIHRpbWU6IERhdGUubm93KClcbiAgICAgICAgfTtcblxuICAgICAgICBpc1Njcm9sbGluZyA9IHVuZGVmaW5lZDtcblxuICAgICAgICBkZWx0YSA9IHt9O1xuXG4gICAgICAgIGRpc3BhdGNoU2xpZGVyRXZlbnQoJ29uJywgJ3RvdWNoc3RhcnQnLCB7XG4gICAgICAgICAgICBldmVudDogZXZlbnRcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25Ub3VjaG1vdmUoZXZlbnQpIHtcbiAgICAgICAgdmFyIHRvdWNoZXMgPSBldmVudC50b3VjaGVzID8gZXZlbnQudG91Y2hlc1swXSA6IGV2ZW50O1xuICAgICAgICB2YXIgcGFnZVggPSB0b3VjaGVzLnBhZ2VYLFxuICAgICAgICAgICAgcGFnZVkgPSB0b3VjaGVzLnBhZ2VZO1xuXG5cbiAgICAgICAgZGVsdGEgPSB7XG4gICAgICAgICAgICB4OiBwYWdlWCAtIHRvdWNoT2Zmc2V0LngsXG4gICAgICAgICAgICB5OiBwYWdlWSAtIHRvdWNoT2Zmc2V0LnlcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAodHlwZW9mIGlzU2Nyb2xsaW5nID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgaXNTY3JvbGxpbmcgPSAhIShpc1Njcm9sbGluZyB8fCBNYXRoLmFicyhkZWx0YS54KSA8IE1hdGguYWJzKGRlbHRhLnkpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNTY3JvbGxpbmcgJiYgdG91Y2hPZmZzZXQpIHtcbiAgICAgICAgICAgIHRyYW5zbGF0ZShwb3NpdGlvbi54ICsgZGVsdGEueCwgMCwgbnVsbCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBtYXkgYmVcbiAgICAgICAgZGlzcGF0Y2hTbGlkZXJFdmVudCgnb24nLCAndG91Y2htb3ZlJywge1xuICAgICAgICAgICAgZXZlbnQ6IGV2ZW50XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9uVG91Y2hlbmQoZXZlbnQpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIHRpbWUgYmV0d2VlbiB0b3VjaHN0YXJ0IGFuZCB0b3VjaGVuZCBpbiBtaWxsaXNlY29uZHNcbiAgICAgICAgICogQGR1cmF0aW9uIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB2YXIgZHVyYXRpb24gPSB0b3VjaE9mZnNldCA/IERhdGUubm93KCkgLSB0b3VjaE9mZnNldC50aW1lIDogdW5kZWZpbmVkO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBpcyB2YWxpZCBpZjpcbiAgICAgICAgICpcbiAgICAgICAgICogLT4gc3dpcGUgYXR0ZW1wdCB0aW1lIGlzIG92ZXIgMzAwIG1zXG4gICAgICAgICAqIGFuZFxuICAgICAgICAgKiAtPiBzd2lwZSBkaXN0YW5jZSBpcyBncmVhdGVyIHRoYW4gMjVweFxuICAgICAgICAgKiBvclxuICAgICAgICAgKiAtPiBzd2lwZSBkaXN0YW5jZSBpcyBtb3JlIHRoZW4gYSB0aGlyZCBvZiB0aGUgc3dpcGUgYXJlYVxuICAgICAgICAgKlxuICAgICAgICAgKiBAaXNWYWxpZFNsaWRlIHtCb29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIGlzVmFsaWQgPSBOdW1iZXIoZHVyYXRpb24pIDwgMzAwICYmIE1hdGguYWJzKGRlbHRhLngpID4gMjUgfHwgTWF0aC5hYnMoZGVsdGEueCkgPiBmcmFtZVdpZHRoIC8gMztcblxuICAgICAgICAvKipcbiAgICAgICAgICogaXMgb3V0IG9mIGJvdW5kcyBpZjpcbiAgICAgICAgICpcbiAgICAgICAgICogLT4gaW5kZXggaXMgMCBhbmQgZGVsdGEgeCBpcyBncmVhdGVyIHRoYW4gMFxuICAgICAgICAgKiBvclxuICAgICAgICAgKiAtPiBpbmRleCBpcyB0aGUgbGFzdCBzbGlkZSBhbmQgZGVsdGEgaXMgc21hbGxlciB0aGFuIDBcbiAgICAgICAgICpcbiAgICAgICAgICogQGlzT3V0T2ZCb3VuZHMge0Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICB2YXIgaXNPdXRPZkJvdW5kcyA9ICFpbmRleCAmJiBkZWx0YS54ID4gMCB8fCBpbmRleCA9PT0gc2xpZGVzLmxlbmd0aCAtIDEgJiYgZGVsdGEueCA8IDA7XG5cbiAgICAgICAgdmFyIGRpcmVjdGlvbiA9IGRlbHRhLnggPCAwO1xuXG4gICAgICAgIGlmICghaXNTY3JvbGxpbmcpIHtcbiAgICAgICAgICAgIGlmIChpc1ZhbGlkICYmICFpc091dE9mQm91bmRzKSB7XG4gICAgICAgICAgICAgICAgc2xpZGUoZmFsc2UsIGRpcmVjdGlvbik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRyYW5zbGF0ZShwb3NpdGlvbi54LCBvcHRpb25zLnNuYXBCYWNrU3BlZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdG91Y2hPZmZzZXQgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHJlbW92ZSBldmVudGxpc3RlbmVycyBhZnRlciBzd2lwZSBhdHRlbXB0XG4gICAgICAgICAqL1xuICAgICAgICBmcmFtZS5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCBvblRvdWNobW92ZSk7XG4gICAgICAgIGZyYW1lLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgb25Ub3VjaGVuZCk7XG4gICAgICAgIGZyYW1lLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIG9uVG91Y2htb3ZlKTtcbiAgICAgICAgZnJhbWUucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIG9uVG91Y2hlbmQpO1xuICAgICAgICBmcmFtZS5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWxlYXZlJywgb25Ub3VjaGVuZCk7XG5cbiAgICAgICAgZGlzcGF0Y2hTbGlkZXJFdmVudCgnb24nLCAndG91Y2hlbmQnLCB7XG4gICAgICAgICAgICBldmVudDogZXZlbnRcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25DbGljayhldmVudCkge1xuICAgICAgICBpZiAoZGVsdGEueCkge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9uUmVzaXplKGV2ZW50KSB7XG4gICAgICAgIGlmIChmcmFtZVdpZHRoICE9PSBlbGVtZW50V2lkdGgoZnJhbWUpKSB7XG4gICAgICAgICAgICByZXNldCgpO1xuXG4gICAgICAgICAgICBkaXNwYXRjaFNsaWRlckV2ZW50KCdvbicsICdyZXNpemUnLCB7XG4gICAgICAgICAgICAgICAgZXZlbnQ6IGV2ZW50XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIHRyaWdnZXIgaW5pdGlhbCBzZXR1cFxuICAgIHNldHVwKCk7XG5cbiAgICAvLyBleHBvc2UgcHVibGljIGFwaVxuICAgIHJldHVybiB7XG4gICAgICAgIHNldHVwOiBzZXR1cCxcbiAgICAgICAgcmVzZXQ6IHJlc2V0LFxuICAgICAgICBzbGlkZVRvOiBzbGlkZVRvLFxuICAgICAgICByZXR1cm5JbmRleDogcmV0dXJuSW5kZXgsXG4gICAgICAgIHByZXY6IHByZXYsXG4gICAgICAgIG5leHQ6IG5leHQsXG4gICAgICAgIGRlc3Ryb3k6IGRlc3Ryb3lcbiAgICB9O1xufVxuXG4vKioqLyB9KSxcbi8qIDIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi8oZnVuY3Rpb24oZ2xvYmFsKSB7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGRldGVjdFByZWZpeGVzO1xuLyoqXG4gKiBEZXRlY3RpbmcgcHJlZml4ZXMgZm9yIHNhdmluZyB0aW1lIGFuZCBieXRlc1xuICovXG5mdW5jdGlvbiBkZXRlY3RQcmVmaXhlcygpIHtcbiAgICB2YXIgdHJhbnNmb3JtID0gdm9pZCAwO1xuICAgIHZhciB0cmFuc2l0aW9uID0gdm9pZCAwO1xuICAgIHZhciB0cmFuc2l0aW9uRW5kID0gdm9pZCAwO1xuICAgIHZhciBoYXNUcmFuc2xhdGUzZCA9IHZvaWQgMDtcblxuICAgIChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ18nKTtcbiAgICAgICAgdmFyIHN0eWxlID0gZWwuc3R5bGU7XG5cbiAgICAgICAgdmFyIHByb3AgPSB2b2lkIDA7XG5cbiAgICAgICAgaWYgKHN0eWxlW3Byb3AgPSAnd2Via2l0VHJhbnNpdGlvbiddID09PSAnJykge1xuICAgICAgICAgICAgdHJhbnNpdGlvbkVuZCA9ICd3ZWJraXRUcmFuc2l0aW9uRW5kJztcbiAgICAgICAgICAgIHRyYW5zaXRpb24gPSBwcm9wO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN0eWxlW3Byb3AgPSAndHJhbnNpdGlvbiddID09PSAnJykge1xuICAgICAgICAgICAgdHJhbnNpdGlvbkVuZCA9ICd0cmFuc2l0aW9uZW5kJztcbiAgICAgICAgICAgIHRyYW5zaXRpb24gPSBwcm9wO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN0eWxlW3Byb3AgPSAnd2Via2l0VHJhbnNmb3JtJ10gPT09ICcnKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm0gPSBwcm9wO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN0eWxlW3Byb3AgPSAnbXNUcmFuc2Zvcm0nXSA9PT0gJycpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybSA9IHByb3A7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3R5bGVbcHJvcCA9ICd0cmFuc2Zvcm0nXSA9PT0gJycpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybSA9IHByb3A7XG4gICAgICAgIH1cblxuICAgICAgICBkb2N1bWVudC5ib2R5Lmluc2VydEJlZm9yZShlbCwgbnVsbCk7XG4gICAgICAgIHN0eWxlW3RyYW5zZm9ybV0gPSAndHJhbnNsYXRlM2QoMCwgMCwgMCknO1xuICAgICAgICBoYXNUcmFuc2xhdGUzZCA9ICEhZ2xvYmFsLmdldENvbXB1dGVkU3R5bGUoZWwpLmdldFByb3BlcnR5VmFsdWUodHJhbnNmb3JtKTtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChlbCk7XG4gICAgfSkoKTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIHRyYW5zZm9ybTogdHJhbnNmb3JtLFxuICAgICAgICB0cmFuc2l0aW9uOiB0cmFuc2l0aW9uLFxuICAgICAgICB0cmFuc2l0aW9uRW5kOiB0cmFuc2l0aW9uRW5kLFxuICAgICAgICBoYXNUcmFuc2xhdGUzZDogaGFzVHJhbnNsYXRlM2RcbiAgICB9O1xufVxuLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovfS5jYWxsKGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18oMCkpKVxuXG4vKioqLyB9KSxcbi8qIDMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gZGV0ZWN0U3VwcG9ydHNQYXNzaXZlO1xuZnVuY3Rpb24gZGV0ZWN0U3VwcG9ydHNQYXNzaXZlKCkge1xuICAgIHZhciBzdXBwb3J0c1Bhc3NpdmUgPSBmYWxzZTtcblxuICAgIHRyeSB7XG4gICAgICAgIHZhciBvcHRzID0gT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAncGFzc2l2ZScsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHN1cHBvcnRzUGFzc2l2ZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd0ZXN0UGFzc2l2ZScsIG51bGwsIG9wdHMpO1xuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigndGVzdFBhc3NpdmUnLCBudWxsLCBvcHRzKTtcbiAgICB9IGNhdGNoIChlKSB7fVxuXG4gICAgcmV0dXJuIHN1cHBvcnRzUGFzc2l2ZTtcbn1cblxuLyoqKi8gfSksXG4vKiA0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGRpc3BhdGNoRXZlbnQ7XG5cbnZhciBfY3VzdG9tRXZlbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xuXG52YXIgX2N1c3RvbUV2ZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2N1c3RvbUV2ZW50KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuLyoqXG4gKiBkaXNwYXRjaCBjdXN0b20gZXZlbnRzXG4gKlxuICogQHBhcmFtICB7ZWxlbWVudH0gZWwgICAgICAgICBzbGlkZXNob3cgZWxlbWVudFxuICogQHBhcmFtICB7c3RyaW5nfSAgdHlwZSAgICAgICBjdXN0b20gZXZlbnQgbmFtZVxuICogQHBhcmFtICB7b2JqZWN0fSAgZGV0YWlsICAgICBjdXN0b20gZGV0YWlsIGluZm9ybWF0aW9uXG4gKi9cbmZ1bmN0aW9uIGRpc3BhdGNoRXZlbnQodGFyZ2V0LCB0eXBlLCBkZXRhaWwpIHtcbiAgICB2YXIgZXZlbnQgPSBuZXcgX2N1c3RvbUV2ZW50Mi5kZWZhdWx0KHR5cGUsIHtcbiAgICAgICAgYnViYmxlczogdHJ1ZSxcbiAgICAgICAgY2FuY2VsYWJsZTogdHJ1ZSxcbiAgICAgICAgZGV0YWlsOiBkZXRhaWxcbiAgICB9KTtcblxuICAgIHRhcmdldC5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbn1cblxuLyoqKi8gfSksXG4vKiA1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqLyhmdW5jdGlvbihnbG9iYWwpIHtcbnZhciBOYXRpdmVDdXN0b21FdmVudCA9IGdsb2JhbC5DdXN0b21FdmVudDtcblxuZnVuY3Rpb24gdXNlTmF0aXZlICgpIHtcbiAgdHJ5IHtcbiAgICB2YXIgcCA9IG5ldyBOYXRpdmVDdXN0b21FdmVudCgnY2F0JywgeyBkZXRhaWw6IHsgZm9vOiAnYmFyJyB9IH0pO1xuICAgIHJldHVybiAgJ2NhdCcgPT09IHAudHlwZSAmJiAnYmFyJyA9PT0gcC5kZXRhaWwuZm9vO1xuICB9IGNhdGNoIChlKSB7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIENyb3NzLWJyb3dzZXIgYEN1c3RvbUV2ZW50YCBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQ3VzdG9tRXZlbnQuQ3VzdG9tRXZlbnRcbiAqXG4gKiBAcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSB1c2VOYXRpdmUoKSA/IE5hdGl2ZUN1c3RvbUV2ZW50IDpcblxuLy8gSUUgPj0gOVxuJ3VuZGVmaW5lZCcgIT09IHR5cGVvZiBkb2N1bWVudCAmJiAnZnVuY3Rpb24nID09PSB0eXBlb2YgZG9jdW1lbnQuY3JlYXRlRXZlbnQgPyBmdW5jdGlvbiBDdXN0b21FdmVudCAodHlwZSwgcGFyYW1zKSB7XG4gIHZhciBlID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0N1c3RvbUV2ZW50Jyk7XG4gIGlmIChwYXJhbXMpIHtcbiAgICBlLmluaXRDdXN0b21FdmVudCh0eXBlLCBwYXJhbXMuYnViYmxlcywgcGFyYW1zLmNhbmNlbGFibGUsIHBhcmFtcy5kZXRhaWwpO1xuICB9IGVsc2Uge1xuICAgIGUuaW5pdEN1c3RvbUV2ZW50KHR5cGUsIGZhbHNlLCBmYWxzZSwgdm9pZCAwKTtcbiAgfVxuICByZXR1cm4gZTtcbn0gOlxuXG4vLyBJRSA8PSA4XG5mdW5jdGlvbiBDdXN0b21FdmVudCAodHlwZSwgcGFyYW1zKSB7XG4gIHZhciBlID0gZG9jdW1lbnQuY3JlYXRlRXZlbnRPYmplY3QoKTtcbiAgZS50eXBlID0gdHlwZTtcbiAgaWYgKHBhcmFtcykge1xuICAgIGUuYnViYmxlcyA9IEJvb2xlYW4ocGFyYW1zLmJ1YmJsZXMpO1xuICAgIGUuY2FuY2VsYWJsZSA9IEJvb2xlYW4ocGFyYW1zLmNhbmNlbGFibGUpO1xuICAgIGUuZGV0YWlsID0gcGFyYW1zLmRldGFpbDtcbiAgfSBlbHNlIHtcbiAgICBlLmJ1YmJsZXMgPSBmYWxzZTtcbiAgICBlLmNhbmNlbGFibGUgPSBmYWxzZTtcbiAgICBlLmRldGFpbCA9IHZvaWQgMDtcbiAgfVxuICByZXR1cm4gZTtcbn1cblxuLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovfS5jYWxsKGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18oMCkpKVxuXG4vKioqLyB9KSxcbi8qIDYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHtcbiAgLyoqXG4gICAqIHNsaWRlcyBzY3JvbGxlZCBhdCBvbmNlXG4gICAqIEBzbGlkZXNUb1Njcm9sbCB7TnVtYmVyfVxuICAgKi9cbiAgc2xpZGVzVG9TY3JvbGw6IDEsXG5cbiAgLyoqXG4gICAqIHRpbWUgaW4gbWlsbGlzZWNvbmRzIGZvciB0aGUgYW5pbWF0aW9uIG9mIGEgdmFsaWQgc2xpZGUgYXR0ZW1wdFxuICAgKiBAc2xpZGVTcGVlZCB7TnVtYmVyfVxuICAgKi9cbiAgc2xpZGVTcGVlZDogMzAwLFxuXG4gIC8qKlxuICAgKiB0aW1lIGluIG1pbGxpc2Vjb25kcyBmb3IgdGhlIGFuaW1hdGlvbiBvZiB0aGUgcmV3aW5kIGFmdGVyIHRoZSBsYXN0IHNsaWRlXG4gICAqIEByZXdpbmRTcGVlZCB7TnVtYmVyfVxuICAgKi9cbiAgcmV3aW5kU3BlZWQ6IDYwMCxcblxuICAvKipcbiAgICogdGltZSBmb3IgdGhlIHNuYXBCYWNrIG9mIHRoZSBzbGlkZXIgaWYgdGhlIHNsaWRlIGF0dGVtcHQgd2FzIG5vdCB2YWxpZFxuICAgKiBAc25hcEJhY2tTcGVlZCB7TnVtYmVyfVxuICAgKi9cbiAgc25hcEJhY2tTcGVlZDogMjAwLFxuXG4gIC8qKlxuICAgKiBCYXNpYyBlYXNpbmcgZnVuY3Rpb25zOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kZS9kb2NzL1dlYi9DU1MvdHJhbnNpdGlvbi10aW1pbmctZnVuY3Rpb25cbiAgICogY3ViaWMgYmV6aWVyIGVhc2luZyBmdW5jdGlvbnM6IGh0dHA6Ly9lYXNpbmdzLm5ldC9kZVxuICAgKiBAZWFzZSB7U3RyaW5nfVxuICAgKi9cbiAgZWFzZTogJ2Vhc2UnLFxuXG4gIC8qKlxuICAgKiBpZiBzbGlkZXIgcmVhY2hlZCB0aGUgbGFzdCBzbGlkZSwgd2l0aCBuZXh0IGNsaWNrIHRoZSBzbGlkZXIgZ29lcyBiYWNrIHRvIHRoZSBzdGFydGluZGV4LlxuICAgKiB1c2UgaW5maW5pdGUgb3IgcmV3aW5kLCBub3QgYm90aFxuICAgKiBAcmV3aW5kIHtCb29sZWFufVxuICAgKi9cbiAgcmV3aW5kOiBmYWxzZSxcblxuICAvKipcbiAgICogbnVtYmVyIG9mIHZpc2libGUgc2xpZGVzIG9yIGZhbHNlXG4gICAqIHVzZSBpbmZpbml0ZSBvciByZXdpbmQsIG5vdCBib3RoXG4gICAqIEBpbmZpbml0ZSB7bnVtYmVyfVxuICAgKi9cbiAgaW5maW5pdGU6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiB0aGUgc2xpZGUgaW5kZXggdG8gc2hvdyB3aGVuIHRoZSBzbGlkZXIgaXMgaW5pdGlhbGl6ZWQuXG4gICAqIEBpbml0aWFsSW5kZXgge251bWJlcn1cbiAgICovXG4gIGluaXRpYWxJbmRleDogMCxcblxuICAvKipcbiAgICogY2xhc3MgbmFtZSBmb3Igc2xpZGVyIGZyYW1lXG4gICAqIEBjbGFzc05hbWVGcmFtZSB7c3RyaW5nfVxuICAgKi9cbiAgY2xhc3NOYW1lRnJhbWU6ICdqc19mcmFtZScsXG5cbiAgLyoqXG4gICAqIGNsYXNzIG5hbWUgZm9yIHNsaWRlcyBjb250YWluZXJcbiAgICogQGNsYXNzTmFtZVNsaWRlQ29udGFpbmVyIHtzdHJpbmd9XG4gICAqL1xuICBjbGFzc05hbWVTbGlkZUNvbnRhaW5lcjogJ2pzX3NsaWRlcycsXG5cbiAgLyoqXG4gICAqIGNsYXNzIG5hbWUgZm9yIHNsaWRlciBwcmV2IGNvbnRyb2xcbiAgICogQGNsYXNzTmFtZVByZXZDdHJsIHtzdHJpbmd9XG4gICAqL1xuICBjbGFzc05hbWVQcmV2Q3RybDogJ2pzX3ByZXYnLFxuXG4gIC8qKlxuICAgKiBjbGFzcyBuYW1lIGZvciBzbGlkZXIgbmV4dCBjb250cm9sXG4gICAqIEBjbGFzc05hbWVOZXh0Q3RybCB7c3RyaW5nfVxuICAgKi9cbiAgY2xhc3NOYW1lTmV4dEN0cmw6ICdqc19uZXh0JyxcblxuICAvKipcbiAgICogY2xhc3MgbmFtZSBmb3IgY3VycmVudCBhY3RpdmUgc2xpZGVcbiAgICogaWYgZW1wdHlTdHJpbmcgdGhlbiBubyBjbGFzcyBpcyBzZXRcbiAgICogQGNsYXNzTmFtZUFjdGl2ZVNsaWRlIHtzdHJpbmd9XG4gICAqL1xuICBjbGFzc05hbWVBY3RpdmVTbGlkZTogJ2FjdGl2ZScsXG5cbiAgLyoqXG4gICAqIGVuYWJsZXMgbW91c2UgZXZlbnRzIGZvciBzd2lwaW5nIG9uIGRlc2t0b3AgZGV2aWNlc1xuICAgKiBAZW5hYmxlTW91c2VFdmVudHMge2Jvb2xlYW59XG4gICAqL1xuICBlbmFibGVNb3VzZUV2ZW50czogZmFsc2UsXG5cbiAgLyoqXG4gICAqIHdpbmRvdyBpbnN0YW5jZVxuICAgKiBAd2luZG93IHtvYmplY3R9XG4gICAqL1xuICB3aW5kb3c6IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogbnVsbCxcblxuICAvKipcbiAgICogSWYgZmFsc2UsIHNsaWRlcyBsb3J5IHRvIHRoZSBmaXJzdCBzbGlkZSBvbiB3aW5kb3cgcmVzaXplLlxuICAgKiBAcmV3aW5kT25SZXNpemUge2Jvb2xlYW59XG4gICAqL1xuICByZXdpbmRPblJlc2l6ZTogdHJ1ZVxufTtcblxuLyoqKi8gfSksXG4vKiA3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxuXG4vKioqLyB9KVxuLyoqKioqKi8gXSk7XG59KTtcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9sZXdpc2NvbGxhcmQvaG9yc2Vwb3dlci9ibG9iLzI5ZDQwNjg3N2Q3NDcwNWM2MWYyN2NjNjU2YTk1ZWNmZGU4NmI5ODcvYXNzZXRzL2pzLzUwLWNhcm91c2VsLmpzXG4gICAgZnVuY3Rpb24gbWFrZUNhcm91c2VsKHNlbGVjdG9yKSB7XG4gICAgICAgIHZhciBzaW1wbGUgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKTtcbiAgICAgICAgaWYgKCFzaW1wbGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbG9yeUNhcm91c2VsID0gbG9yeShzaW1wbGUsIHtcbiAgICAgICAgICAgIGluZmluaXRlOiAxLFxuICAgICAgICAgICAgZW5hYmxlTW91c2VFdmVudHM6IHRydWUsXG4gICAgICAgICAgICBjbGFzc05hbWVQcmV2Q3RybDonc2xpZGVyX19wcmV2JyxcbiAgICAgICAgICAgIGNsYXNzTmFtZU5leHRDdHJsOidzbGlkZXJfX25leHQnLFxuICAgICAgICAgICAgY2xhc3NOYW1lU2xpZGVDb250YWluZXI6ICdzbGlkZXJfX3NsaWRlcycsXG4gICAgICAgICAgICBjbGFzc05hbWVGcmFtZTogJ3NsaWRlcl9fZnJhbWUnLFxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBBdXRvcGxheVxuICAgICAgICB2YXIgdGltZXIgPSB3aW5kb3cuc2V0SW50ZXJ2YWwoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgbG9yeUNhcm91c2VsLm5leHQoKTtcbiAgICAgICAgfSwgNTAwMCk7XG5cbiAgICAgICAgZnVuY3Rpb24gY2FuY2VsVGltZXIoKSB7XG4gICAgICAgICAgICB3aW5kb3cuY2xlYXJJbnRlcnZhbCh0aW1lcik7XG4gICAgICAgIH1cblxuICAgICAgICBzaW1wbGUucXVlcnlTZWxlY3RvcignLnNsaWRlcl9fbmV4dCcpLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgY2FuY2VsVGltZXIpO1xuICAgICAgICBzaW1wbGUucXVlcnlTZWxlY3RvcignLnNsaWRlcl9fcHJldicpLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgY2FuY2VsVGltZXIpO1xuICAgICAgICBzaW1wbGUuYWRkRXZlbnRMaXN0ZW5lcignb24ubG9yeS50b3VjaHN0YXJ0JywgY2FuY2VsVGltZXIpO1xuICAgIH1cblxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIG1ha2VDYXJvdXNlbCgnLmpzX3NpbXBsZScpO1xuICAgIH0pOyJdLCJmaWxlIjoibWFpbi5taW4uanMifQ==
